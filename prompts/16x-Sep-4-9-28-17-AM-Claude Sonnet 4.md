User:
<task-type>
You are tasked to implement a feature. Instructions are as follows:
</task-type>
<task-instruction>
Add a feature that is 100% compatible with the current architecture and UX/UI that does the following:

- Generate original tweets from topics
- Trend-based content suggestions using API like Grok or EXA

</task-instruction>
<custom-instruction>
Instructions for the output format:
- Output code without descriptions, unless it is important.
- Minimize prose, comments and empty lines.
- Only show the relevant code that needs to be modified. Use comments to represent the parts that are not modified.
- Make it easy to copy and paste.
- Consider other possibilities to achieve the result, do not be limited by the prompt.
</custom-instruction>
<files>
popup\config.ts
```ts
import './popup.scss';document.addEventListener('DOMContentLoaded', async () => {  const backBtn = document.getElementById('back-to-settings');  const statusDiv = document.getElementById('api-status');  const statusText = document.getElementById('status-text');  const modelCount = document.getElementById('model-count');  const lastCheck = document.getElementById('last-check');  if (backBtn) {    backBtn.addEventListener('click', () => {      window.close();    });  }  checkApiStatus();  async function checkApiStatus() {    try {      const response = await chrome.runtime.sendMessage({        type: 'TEST_API_KEY'      });      if (response?.success) {        const modelsResponse = await chrome.runtime.sendMessage({          type: 'FETCH_MODELS'        });        if (modelsResponse?.success && modelsResponse?.models) {          if (modelCount) {            modelCount.textContent = `${modelsResponse.models.length} models available`;            modelCount.style.color = '#2e7d32';          }        }        if (lastCheck) {          lastCheck.textContent = `Last checked: ${new Date().toLocaleTimeString()}`;        }      } else {        if (statusDiv) {          statusDiv.style.background = '#fff3cd';          statusDiv.style.border = '1px solid #ffc107';        }        if (statusText) {          statusText.textContent = '⚠️ API Key Not Configured';          statusText.style.color = '#856404';        }        if (modelCount) {          modelCount.textContent = 'Please configure the API key in apiConfig.ts';          modelCount.style.color = '#856404';        }      }    } catch (error) {      console.error('API status check failed:', error);      if (statusDiv) {        statusDiv.style.background = '#f8d7da';        statusDiv.style.border = '1px solid #dc3545';      }      if (statusText) {        statusText.textContent = '❌ Connection error';        statusText.style.color = '#721c24';      }    }  }});
```

popup\popup-simple.ts
```ts
import './popup.scss';import { MessageType } from '@/types/messages';interface StorageConfig {  model?: string;  systemPrompt?: string;  contextMode?: string;  temperature?: number;  replyLengthDefault?: string;}interface Features {  imageUnderstanding?: {    enabled: boolean;    model?: string;    maxImagesPerRequest?: number;  };  smartSuggestions?: {    enabled: boolean;    maxSuggestions?: number;  };  arsenalMode?: {    enabled: boolean;    maxReplies?: number;  };}const MAX_IMAGES_PER_REQUEST = 2;console.log('popup-simple.ts: Script loaded');document.addEventListener('DOMContentLoaded', () => {  console.log('popup-simple.ts: DOM loaded');  const systemPromptInput = document.getElementById('system-prompt') as HTMLTextAreaElement | null;  const contextModeSelect = document.getElementById('context-mode') as HTMLSelectElement | null;  const modelSelect = document.getElementById('model-select') as HTMLSelectElement | null;  const temperatureInput = document.getElementById('temperature') as HTMLInputElement | null;  const temperatureValue = document.getElementById('temperature-value');  const refreshModelsBtn = document.getElementById('refresh-models') as HTMLButtonElement | null;  const replyLengthSelect = document.getElementById('reply-length') as HTMLSelectElement | null;  if (!modelSelect || !systemPromptInput) {    console.error('Critical form elements missing');    return;  }  const autoFetchModels = async () => {    if (!refreshModelsBtn || !modelSelect) return;    console.log('Auto-fetching models on popup load...');    try {      const response = await chrome.runtime.sendMessage({ type: MessageType.FETCH_MODELS });      if (response?.success && response?.data) {        modelSelect.innerHTML = '';        response.data.forEach((model: any) => {          const option = document.createElement('option');          option.value = model.id;          option.textContent = `${model.name} (${model.context_length} tokens, $${model.pricing?.prompt || 0}/${model.pricing?.completion || 0})`;          modelSelect.appendChild(option);        });        const savedResult = await new Promise<{ smartReply_config?: StorageConfig }>((resolve) => {          chrome.storage.sync.get(['smartReply_config'], resolve);        });        const savedModel = savedResult.smartReply_config?.model;        if (savedModel) {          const modelExists = Array.from(modelSelect.options).some(opt => opt.value === savedModel);          if (modelExists) {            modelSelect.value = savedModel;            console.log('Restored saved model:', savedModel);          } else {            console.log('Saved model not found in fetched list:', savedModel);            if (modelSelect.options.length > 0) {              const firstModel = modelSelect.options[0].value;              modelSelect.value = firstModel;              const config = savedResult.smartReply_config || {};              config.model = firstModel;              await chrome.storage.sync.set({ smartReply_config: config });            }          }        } else if (modelSelect.options.length > 0) {          const firstModel = modelSelect.options[0].value;          modelSelect.value = firstModel;          const config = savedResult.smartReply_config || {};          config.model = firstModel;          await chrome.storage.sync.set({ smartReply_config: config });        }        console.log(`Loaded ${response.data.length} models`);      } else {        console.error('Failed to fetch models:', response?.error);      }    } catch (error) {      console.error('Error auto-fetching models:', error);    }  };  autoFetchModels();  chrome.storage.sync.get(['smartReply_config', 'features'], (result: { smartReply_config?: StorageConfig; features?: Features }) => {    if (result.smartReply_config) {      const config = result.smartReply_config;      if (config.systemPrompt && systemPromptInput) {        systemPromptInput.value = config.systemPrompt;      }      if (config.temperature !== undefined && temperatureInput) {        temperatureInput.value = config.temperature.toString();        if (temperatureValue) {          temperatureValue.textContent = config.temperature.toString();        }      }      if (config.contextMode && contextModeSelect) {        contextModeSelect.value = config.contextMode;      } else if (contextModeSelect) {        contextModeSelect.value = 'thread';      }      if (config.replyLengthDefault && replyLengthSelect) {        replyLengthSelect.value = config.replyLengthDefault;      }      console.log('%c📂 POPUP SETTINGS LOADED', 'color: #17BF63; font-weight: bold; font-size: 14px');      console.log('%c  Model:', 'color: #657786', config.model || 'Not set');      console.log('%c  Temperature:', 'color: #657786', config.temperature || 0.7);      console.log('%c  Context Mode:', 'color: #657786', config.contextMode || 'thread');      console.log('%c  Reply Length Default:', 'color: #657786', config.replyLengthDefault || 'Auto');      console.log('%c  System Prompt Length:', 'color: #657786', config.systemPrompt?.length || 0, 'characters');    }  });  if (temperatureInput) {    temperatureInput.addEventListener('input', () => {      if (temperatureValue) {        temperatureValue.textContent = temperatureInput.value;      }    });  }  if (modelSelect) {    modelSelect.addEventListener('change', async () => {      const selectedModel = modelSelect.value;      console.log('Model changed to:', selectedModel);      const result = await new Promise<{ smartReply_config?: StorageConfig }>((resolve) => {        chrome.storage.sync.get(['smartReply_config'], resolve);      });      const config = result.smartReply_config || {};      config.model = selectedModel;      await chrome.storage.sync.set({ smartReply_config: config });      console.log('Model selection saved:', selectedModel);      const statusDiv = document.getElementById('status-message');      if (statusDiv) {        statusDiv.textContent = 'Model saved!';        statusDiv.style.display = 'block';        statusDiv.style.color = 'green';        setTimeout(() => {          statusDiv.style.display = 'none';        }, 2000);      }    });  }  const saveBtn = document.getElementById('save-settings');  const resetUsageBtn = document.getElementById('reset-usage');  if (saveBtn) {    console.log('popup-simple.ts: Save button found');    saveBtn.addEventListener('click', async () => {      console.log('popup-simple.ts: Save button clicked!');      const systemPrompt = systemPromptInput?.value?.trim();      const contextMode = contextModeSelect?.value || 'thread';      const model = modelSelect?.value;      const temperature = parseFloat(temperatureInput?.value || '0.7');      const replyLengthDefault = replyLengthSelect?.value || '';        const existingConfig = await new Promise<{ config: StorageConfig; features: Features }>((resolve, reject) => {          chrome.storage.sync.get(['smartReply_config', 'features'], (result) => {            if (chrome.runtime.lastError) {              reject(new Error(chrome.runtime.lastError.message));            } else {              resolve({ config: result.smartReply_config || {}, features: result.features || {} });            }          });        }).catch(error => {          console.error('Failed to get existing config:', error);          return { config: {}, features: {} };        });        const config: StorageConfig = {          ...existingConfig.config,          model: model || modelSelect?.value || 'openai/gpt-4o',          systemPrompt: systemPrompt || 'I am a helpful assistant',          contextMode: contextMode,          temperature,          replyLengthDefault: replyLengthDefault || undefined        };        const features: Features = {          ...existingConfig.features,          imageUnderstanding: {            enabled: true,             model: 'gemini-2-flash',             maxImagesPerRequest: MAX_IMAGES_PER_REQUEST          }        };        await chrome.storage.sync.set({           smartReply_config: config,          features: features         });        console.log('%c💾 POPUP SETTINGS SAVED', 'color: #1DA1F2; font-weight: bold; font-size: 14px');        console.log('%c  Model:', 'color: #657786', config.model);        console.log('%c  Temperature:', 'color: #657786', config.temperature);        console.log('%c  Context Mode:', 'color: #657786', config.contextMode);        console.log('%c  Reply Length Default:', 'color: #657786', config.replyLengthDefault || 'Auto');        console.log('%c  System Prompt Length:', 'color: #657786', config.systemPrompt?.length || 0, 'characters');        console.log('%c  Image Understanding:', 'color: #657786', features.imageUnderstanding?.enabled ? '✅ ENABLED' : '❌ DISABLED');        console.log('%c  Vision Model:', 'color: #657786', features.imageUnderstanding?.model);        console.log('%c  Max Images Per Request:', 'color: #657786', features.imageUnderstanding?.maxImagesPerRequest);        const statusDiv = document.getElementById('status-message');        if (statusDiv) {          statusDiv.textContent = 'Settings saved!';          statusDiv.style.display = 'block';          statusDiv.style.color = 'green';          setTimeout(() => {            statusDiv.style.display = 'none';          }, 3000);        }        console.log('Settings saved:', config);    });  } else {    console.error('popup-simple.ts: Save button not found');  }  if (resetUsageBtn) {    console.log('popup-simple.ts: Reset usage button found');    resetUsageBtn.addEventListener('click', async () => {      console.log('popup-simple.ts: Reset usage button clicked!');      const confirmed = confirm('Are you sure you want to reset all usage counters? This cannot be undone.');      if (confirmed) {        try {          (resetUsageBtn as HTMLButtonElement).disabled = true;          resetUsageBtn.textContent = '🔄 Resetting...';          const response = await chrome.runtime.sendMessage({            type: MessageType.RESET_USAGE_STATS          });          if (response?.success) {            const statusDiv = document.getElementById('status-message');            if (statusDiv) {              statusDiv.textContent = '✅ Usage counters reset successfully!';              statusDiv.style.display = 'block';              statusDiv.style.color = 'green';              setTimeout(() => {                statusDiv.style.display = 'none';              }, 3000);            }            console.log('Usage stats reset successfully');          } else {            throw new Error('Failed to reset usage stats');          }        } catch (error) {          console.error('Error resetting usage stats:', error);          const statusDiv = document.getElementById('status-message');          if (statusDiv) {            statusDiv.textContent = '❌ Failed to reset usage counters';            statusDiv.style.display = 'block';            statusDiv.style.color = 'red';            setTimeout(() => {              statusDiv.style.display = 'none';            }, 3000);          }        } finally {          (resetUsageBtn as HTMLButtonElement).disabled = false;          resetUsageBtn.textContent = '🔄 Reset Usage';        }      }    });  } else {    console.error('popup-simple.ts: Reset usage button not found');  }  if (refreshModelsBtn && modelSelect) {    refreshModelsBtn.addEventListener('click', async () => {      console.log('Fetching models from OpenRouter...');      refreshModelsBtn.disabled = true;      refreshModelsBtn.textContent = '⏳';      try {        const response = await chrome.runtime.sendMessage({          type: MessageType.FETCH_MODELS        });        if (response?.success && response?.data) {          modelSelect.innerHTML = '';          const savedResult = await new Promise<{ smartReply_config?: StorageConfig }>((resolve) => {            chrome.storage.sync.get(['smartReply_config'], resolve);          });          const savedModel = savedResult.smartReply_config?.model;          response.data.forEach((model: any) => {            const option = document.createElement('option');            option.value = model.id;            option.textContent = `${model.name} (${model.context_length} tokens, $${model.pricing?.prompt || 0}/${model.pricing?.completion || 0})`;            modelSelect.appendChild(option);          });          if (savedModel) {            const modelExists = Array.from(modelSelect.options).some(opt => opt.value === savedModel);            if (modelExists) {              modelSelect.value = savedModel;              console.log('Restored saved model:', savedModel);            } else {              console.log('Saved model not found in fetched list:', savedModel);              if (modelSelect.options.length > 0) {                const firstModel = modelSelect.options[0].value;                modelSelect.value = firstModel;                const config = savedResult.smartReply_config || {};                config.model = firstModel;                await chrome.storage.sync.set({ smartReply_config: config });              }            }          } else if (modelSelect.options.length > 0) {            const firstModel = modelSelect.options[0].value;            modelSelect.value = firstModel;            const config = savedResult.smartReply_config || {};            config.model = firstModel;            await chrome.storage.sync.set({ smartReply_config: config });          }          const modelInfo = document.getElementById('model-info');          if (modelInfo) {            modelInfo.textContent = `Found ${response.data.length} models`;            modelInfo.style.color = 'green';          }        } else {          console.error('Failed to fetch models:', response?.error);          const modelInfo = document.getElementById('model-info');          if (modelInfo) {            modelInfo.textContent = 'Failed to fetch models';            modelInfo.style.color = 'red';          }        }      } catch (error) {        console.error('Error fetching models:', error);        const modelInfo = document.getElementById('model-info');        if (modelInfo) {          modelInfo.textContent = 'Error fetching models';          modelInfo.style.color = 'red';        }      } finally {        refreshModelsBtn.disabled = false;        refreshModelsBtn.textContent = '↻';      }    });  }});
```

popup\popup.scss
```scss
body {  margin: 0;  padding: 0;  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;  background-color: #ffffff;  color: #0f1419;  width: 400px;  min-height: 500px;}.popup-container {  display: flex;  flex-direction: column;  height: 100vh;  max-height: 600px;}.popup-header {  padding: 20px;  background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);  color: white;  text-align: center;  h1 {    margin: 0 0 5px 0;    font-size: 24px;    font-weight: 700;  }  p {    margin: 0;    opacity: 0.9;    font-size: 14px;  }}.popup-content {  flex: 1;  padding: 20px;  overflow-y: auto;}.setting-group {  margin-bottom: 20px;  label {    display: block;    margin-bottom: 6px;    font-weight: 500;    font-size: 14px;    color: #536471;  }  input[type="password"],  input[type="text"],  select,  textarea {    width: 100%;    padding: 10px 12px;    border: 2px solid #e1e8ed;    border-radius: 8px;    font-size: 14px;    font-family: inherit;    transition: border-color 0.2s ease, box-shadow 0.2s ease;    box-sizing: border-box;    &:focus {      outline: none;      border-color: #1da1f2;      box-shadow: 0 0 0 3px rgba(29, 161, 242, 0.1);    }    &.valid {      border-color: #10b981;      background-color: rgba(16, 185, 129, 0.05);    }    &.invalid {      border-color: #ef4444;      background-color: rgba(239, 68, 68, 0.05);    }  }  textarea {    min-height: 80px;    resize: vertical;    font-family: inherit;  }  select {    cursor: pointer;    background-color: white;    background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");    background-position: right 8px center;    background-repeat: no-repeat;    background-size: 16px;    padding-right: 40px;    appearance: none;  }  small {    display: block;    margin-top: 4px;    color: #657786;    font-size: 12px;    a {      color: #1da1f2;      text-decoration: none;      &:hover {        text-decoration: underline;      }    }  }  label:has(input[type="checkbox"]) {    display: flex;    align-items: center;    gap: 8px;    cursor: pointer;    font-weight: normal;    margin-bottom: 0;    input[type="checkbox"] {      width: auto;      margin: 0;      accent-color: #1da1f2;    }  }  input[type="range"] {    width: 100%;    height: 6px;    background: #e1e8ed;    border-radius: 3px;    outline: none;    -webkit-appearance: none;    margin: 10px 0;    &::-webkit-slider-thumb {      -webkit-appearance: none;      appearance: none;      width: 18px;      height: 18px;      background: #1da1f2;      border-radius: 50%;      cursor: pointer;      transition: all 0.2s;      &:hover {        transform: scale(1.1);        box-shadow: 0 2px 8px rgba(29, 161, 242, 0.3);      }    }    &::-moz-range-thumb {      width: 18px;      height: 18px;      background: #1da1f2;      border-radius: 50%;      cursor: pointer;      border: none;      transition: all 0.2s;      &:hover {        transform: scale(1.1);        box-shadow: 0 2px 8px rgba(29, 161, 242, 0.3);      }    }  }  .temperature-info {    display: block;    margin-top: -5px;    margin-bottom: 10px;    color: #8899a6;    font-size: 10px;    overflow: hidden;  }}.api-key-row, .model-select-row {  display: flex;  gap: 8px;  align-items: stretch;  input, select {    flex: 1;  }  .btn-secondary {    padding: 8px 16px;    background-color: #ffffff;    color: #1da1f2;    border: 1px solid #1da1f2;    border-radius: 4px;    font-size: 14px;    font-weight: 500;    cursor: pointer;    transition: all 0.2s;    &:hover:not(:disabled) {      background-color: #e8f5fd;    }    &:disabled {      opacity: 0.5;      cursor: not-allowed;    }  }  .btn-icon {    padding: 8px 10px;    background-color: transparent;    border: 1px solid #e1e8ed;    border-radius: 4px;    font-size: 16px;    cursor: pointer;    transition: all 0.2s;    min-width: 40px;    &:hover {      background-color: #f7f9fa;      border-color: #1da1f2;    }    &.active {      background-color: #e8f5fd;      border-color: #1da1f2;    }  }}.model-info {  display: block;  margin-top: 4px;  color: #657786;  font-size: 11px;  line-height: 1.4;}.test-result {  margin-top: 8px;  padding: 8px;  border-radius: 4px;  font-size: 13px;  display: none;  &.success {    display: block;    background-color: #d4edda;    color: #155724;    border: 1px solid #c3e6cb;  }  &.error {    display: block;    background-color: #f8d7da;    color: #721c24;    border: 1px solid #f5c6cb;  }  &.testing {    display: block;    background-color: #d1ecf1;    color: #0c5460;    border: 1px solid #bee5eb;  }}@keyframes spin {  from { transform: rotate(0deg); }  to { transform: rotate(360deg); }}.popup-footer {  padding: 20px;  border-top: 1px solid #e1e8ed;  background-color: #f7f9fa;  .footer-buttons {    display: flex;    gap: 12px;    margin-bottom: 12px;  }  .btn-primary {    flex: 1;    padding: 12px 24px;    background: linear-gradient(135deg, #1da1f2 0%, #0d8bd9 100%);    color: white;    border: none;    border-radius: 8px;    font-size: 14px;    font-weight: 600;    cursor: pointer;    transition: all 0.2s ease;    &:hover:not(:disabled) {      transform: translateY(-1px);      box-shadow: 0 4px 12px rgba(29, 161, 242, 0.3);    }    &:active:not(:disabled) {      transform: translateY(0);    }  }  .reset-btn {    padding: 10px 16px;    background: rgba(239, 68, 68, 0.1);    color: #dc3545;    border: 1px solid rgba(239, 68, 68, 0.3);    border-radius: 6px;    font-size: 13px;    font-weight: 500;    cursor: pointer;    transition: all 0.2s ease;    white-space: nowrap;    &:hover:not(:disabled) {      background: rgba(239, 68, 68, 0.15);      border-color: rgba(239, 68, 68, 0.5);    }    &:active:not(:disabled) {      transform: translateY(1px);    }    &:disabled {      opacity: 0.6;      cursor: not-allowed;    }  }}.status-message {  margin-top: 12px;  padding: 8px 12px;  border-radius: 6px;  font-size: 13px;  text-align: center;  display: none;  &.info {    background-color: #e1f5fe;    color: #0277bd;    border: 1px solid #b3e5fc;  }  &.success {    background-color: #e8f5e8;    color: #2e7d32;    border: 1px solid #c8e6c9;  }  &.warning {    background-color: #fff3e0;    color: #f57c00;    border: 1px solid #ffcc02;  }  &.error {    background-color: #ffebee;    color: #d32f2f;    border: 1px solid #ffcdd2;  }}@media (prefers-color-scheme: dark) {  body {    background-color: #15202b;    color: #ffffff;  }  .popup-content {    background-color: #15202b;  }  .setting-group {    label {      color: #8b98a5;    }    input[type="password"],    input[type="text"],    select,    textarea {      background-color: #192734;      border-color: #38444d;      color: #ffffff;      &:focus {        border-color: #1da1f2;        box-shadow: 0 0 0 3px rgba(29, 161, 242, 0.2);      }    }    select {      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23ffffff' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");    }    small {      color: #8b98a5;    }  }  .popup-footer {    background-color: #192734;    border-top-color: #38444d;  }  .status-message {    &.info {      background-color: rgba(29, 161, 242, 0.2);      color: #1da1f2;      border-color: rgba(29, 161, 242, 0.3);    }    &.success {      background-color: rgba(16, 185, 129, 0.2);      color: #10b981;      border-color: rgba(16, 185, 129, 0.3);    }    &.warning {      background-color: rgba(245, 124, 0, 0.2);      color: #f57c00;      border-color: rgba(245, 124, 0, 0.3);    }    &.error {      background-color: rgba(239, 68, 68, 0.2);      color: #ef4444;      border-color: rgba(239, 68, 68, 0.3);    }  }}::-webkit-scrollbar {  width: 6px;}::-webkit-scrollbar-track {  background: transparent;}::-webkit-scrollbar-thumb {  background: #ccd6dd;  border-radius: 3px;  &:hover {    background: #aab8c2;  }}@media (prefers-color-scheme: dark) {  ::-webkit-scrollbar-thumb {    background: #38444d;    &:hover {      background: #536471;    }  }}
```

popup\popup.ts
```ts
import { StorageService } from '@/services/storage';import { OpenRouterService } from '@/services/openRouter';import { AppConfig } from '@/types';import './popup.scss';class SmartReplyPopup {  private elements: { [key: string]: HTMLElement } = {};  constructor() {    console.log('Smart Reply Popup: Constructor called');    this.init();    const container = document.querySelector('.popup-container');    if (container) {      container.setAttribute('data-initialized', 'true');    }  }  private init(): void {    console.log('Smart Reply Popup: Init method called');    this.bindElements();    this.bindEvents();    this.loadSettings();    console.log('Smart Reply Popup: Init complete');  }  private bindElements(): void {    console.log('Smart Reply Popup: Binding elements...');    const requiredElements = {      apiKey: 'api-key',      modelSelect: 'model-select',      systemPrompt: 'system-prompt',      contextAware: 'context-aware',      saveButton: 'save-settings',      statusMessage: 'status-message',      testApiButton: 'test-api-key',      apiTestResult: 'api-test-result',      refreshModelsButton: 'refresh-models',      modelInfo: 'model-info',      temperature: 'temperature',      temperatureValue: 'temperature-value',      toggleApiKeyButton: 'toggle-api-key'    };    let foundCount = 0;    for (const [key, id] of Object.entries(requiredElements)) {      const element = document.getElementById(id);      if (!element) {        console.error(`Smart Reply Popup: Required element with id '${id}' not found`);      } else {        this.elements[key] = element;        foundCount++;      }    }    console.log(`Smart Reply Popup: Found ${foundCount}/${Object.keys(requiredElements).length} elements`);  }  private bindEvents(): void {    console.log('Smart Reply Popup: Binding events...');    if (this.elements.saveButton) {      this.elements.saveButton.addEventListener('click', () => {        console.log('Save button clicked');        this.saveSettings();      });    } else {      console.error('Save button not found');    }    if (this.elements.testApiButton) {      this.elements.testApiButton.addEventListener('click', () => {        console.log('Test API button clicked');        this.testApiKey();      });    } else {      console.error('Test API button not found');    }    if (this.elements.toggleApiKeyButton) {      this.elements.toggleApiKeyButton.addEventListener('click', () => {        console.log('Toggle API key button clicked');        this.toggleApiKeyVisibility();      });    } else {      console.error('Toggle API key button not found');    }    if (this.elements.refreshModelsButton) {      this.elements.refreshModelsButton.addEventListener('click', () => {        console.log('Refresh models button clicked');        this.refreshModels();      });    } else {      console.error('Refresh models button not found');    }    if (this.elements.modelSelect) {      this.elements.modelSelect.addEventListener('change', () => {        console.log('Model select changed');        this.updateModelInfo();      });    } else {      console.error('Model select not found');    }    if (this.elements.temperature && this.elements.temperatureValue) {      this.elements.temperature.addEventListener('input', (e) => {        const value = (e.target as HTMLInputElement).value;        this.elements.temperatureValue.textContent = value;        console.log('Temperature changed to:', value);      });    } else {      console.error('Temperature slider or value element not found');    }    this.elements.apiKey.addEventListener('blur', () => {      this.validateApiKey();    });    let promptTimeout: NodeJS.Timeout;    this.elements.systemPrompt.addEventListener('input', () => {      clearTimeout(promptTimeout);      promptTimeout = setTimeout(() => {        this.autoSavePrompt();      }, 1000);    });    document.addEventListener('keydown', (e) => {      if (e.ctrlKey && e.key === 's') {        e.preventDefault();        this.saveSettings();      }    });  }  private async loadSettings(): Promise<void> {    try {      this.showMessage('Loading settings...', 'info');      const apiKey = await StorageService.getApiKey();      if (apiKey) {        (this.elements.apiKey as HTMLInputElement).value = apiKey;        this.updateApiKeyDisplay(true);       }      const config = await StorageService.getConfig();      if (config.model) {        (this.elements.modelSelect as HTMLSelectElement).value = config.model;      }      if (config.systemPrompt) {        (this.elements.systemPrompt as HTMLTextAreaElement).value = config.systemPrompt;      }      if (config.temperature !== undefined) {        (this.elements.temperature as HTMLInputElement).value = config.temperature.toString();        this.elements.temperatureValue.textContent = config.temperature.toString();      }      this.clearMessage();      console.log('Smart Reply Popup: Settings loaded successfully');    } catch (error) {      console.error('Smart Reply Popup: Failed to load settings:', error);      this.showMessage('Failed to load settings', 'error');    }  }  private async saveSettings(): Promise<void> {    try {      this.showMessage('Saving settings...', 'info');      (this.elements.saveButton as HTMLButtonElement).disabled = true;      const apiKeyInput = this.elements.apiKey as HTMLInputElement;      const apiKey = (apiKeyInput.dataset.realKey || apiKeyInput.value).trim();      const model = (this.elements.modelSelect as HTMLSelectElement).value;      const systemPrompt = (this.elements.systemPrompt as HTMLTextAreaElement).value.trim();      const contextAware = (this.elements.contextAware as HTMLInputElement).checked;      const temperature = parseFloat((this.elements.temperature as HTMLInputElement).value);      if (!apiKey) {        this.showMessage('API key is required', 'error');        return;      }      if (!this.validateApiKeyFormat(apiKey)) {        this.showMessage('Invalid API key format. Should start with "sk-or-"', 'warning');      }      if (!systemPrompt) {        this.showMessage('System prompt is required', 'error');        return;      }      await StorageService.setApiKey(apiKey);      const config: Partial<AppConfig> = {        model,        systemPrompt,        temperature      };      await StorageService.setConfig(config);      const isValid = await this.validateApiKey();      if (!isValid) {        this.showMessage('Settings saved, but API key validation failed', 'warning');      } else {        this.showMessage('Settings saved successfully!', 'success');      }      console.log('Smart Reply Popup: Settings saved successfully');    } catch (error) {      console.error('Smart Reply Popup: Failed to save settings:', error);      this.showMessage('Failed to save settings', 'error');    } finally {      (this.elements.saveButton as HTMLButtonElement).disabled = false;    }  }  private async validateApiKey(): Promise<boolean> {    const apiKey = (this.elements.apiKey as HTMLInputElement).value.trim();    if (!apiKey) {      return false;    }    try {      const isValid = await OpenRouterService.validateApiKey(apiKey);      if (isValid) {        this.elements.apiKey?.classList.remove('invalid');        this.elements.apiKey?.classList.add('valid');        return true;      } else {        this.elements.apiKey?.classList.remove('valid');        this.elements.apiKey?.classList.add('invalid');        return false;      }    } catch (error) {      console.error('Smart Reply Popup: API key validation failed:', error);      this.elements.apiKey?.classList.remove('valid');      this.elements.apiKey?.classList.add('invalid');      return false;    }  }  private async testApiKey(): Promise<void> {    const apiKey = (this.elements.apiKey as HTMLInputElement).value.trim();    const testButton = this.elements.testApiButton as HTMLButtonElement;    const resultDiv = this.elements.apiTestResult;    if (!apiKey) {      resultDiv.className = 'test-result error';      resultDiv.textContent = 'Please enter an API key first';      return;    }    testButton.disabled = true;    testButton.textContent = 'Testing...';    resultDiv.className = 'test-result testing';    resultDiv.textContent = 'Validating API key with OpenRouter...';    try {      const isValid = await OpenRouterService.validateApiKey(apiKey);      if (isValid) {        resultDiv.className = 'test-result success';        resultDiv.textContent = '✓ API key is valid and working!';        this.elements.apiKey?.classList.remove('invalid');        this.elements.apiKey?.classList.add('valid');      } else {        resultDiv.className = 'test-result error';        resultDiv.textContent = '✗ Invalid API key. Get your key at openrouter.ai/keys';        this.elements.apiKey?.classList.remove('valid');        this.elements.apiKey?.classList.add('invalid');      }    } catch (error: any) {      console.error('Smart Reply Popup: API key test failed:', error);      resultDiv.className = 'test-result error';      if (error?.message?.includes('Failed to fetch') || error?.message?.includes('NetworkError')) {        resultDiv.textContent = '✗ Connection failed. Check your internet connection';      } else {        resultDiv.textContent = '✗ Test failed. Check your connection and try again';      }      this.elements.apiKey?.classList.remove('valid');      this.elements.apiKey?.classList.add('invalid');    } finally {      testButton.disabled = false;      testButton.textContent = 'Test';      setTimeout(() => {        resultDiv.className = 'test-result';        resultDiv.textContent = '';      }, 5000);    }  }  private async autoSavePrompt(): Promise<void> {    try {      const config = await StorageService.getConfig();      config.systemPrompt = (this.elements.systemPrompt as HTMLTextAreaElement).value.trim();      await StorageService.setConfig(config);      console.log('Smart Reply Popup: System prompt auto-saved');    } catch (error) {      console.error('Smart Reply Popup: Failed to auto-save prompt:', error);    }  }  private async refreshModels(): Promise<void> {    const refreshButton = this.elements.refreshModelsButton as HTMLButtonElement;    const modelSelect = this.elements.modelSelect as HTMLSelectElement;    const apiKey = (this.elements.apiKey as HTMLInputElement).value.trim();    if (!apiKey) {      this.showMessage('Please enter an API key first', 'error');      return;    }    refreshButton.disabled = true;    refreshButton.textContent = '⟳';    refreshButton.style.animation = 'spin 1s linear infinite';    try {      const models = await OpenRouterService.fetchAvailableModels(apiKey);      if (models.length === 0) {        this.showMessage('No models available or invalid API key', 'error');        return;      }      const currentModel = modelSelect.value;      modelSelect.innerHTML = '';      models.forEach(model => {        const option = document.createElement('option');        option.value = model.id;        option.textContent = model.name;        modelSelect.appendChild(option);      });      if (currentModel && models.find(m => m.id === currentModel)) {        modelSelect.value = currentModel;      }      (window as any).cachedModels = models;      this.updateModelInfo();      this.showMessage(`Loaded ${models.length} models`, 'success');    } catch (error) {      console.error('Failed to refresh models:', error);      this.showMessage('Failed to load models', 'error');    } finally {      refreshButton.disabled = false;      refreshButton.textContent = '↻';      refreshButton.style.animation = '';    }  }  private updateModelInfo(): void {    const modelSelect = this.elements.modelSelect as HTMLSelectElement;    const modelInfo = this.elements.modelInfo;    const models = (window as any).cachedModels || [];    const selectedModel = models.find((m: any) => m.id === modelSelect.value);    if (selectedModel) {      const inputPrice = (selectedModel.pricing.input * 1000000).toFixed(2);      const outputPrice = (selectedModel.pricing.output * 1000000).toFixed(2);      modelInfo.textContent = `Context: ${selectedModel.contextWindow.toLocaleString()} tokens | Cost: $${inputPrice}/$${outputPrice} per 1M tokens`;    } else {      modelInfo.textContent = '';    }  }  private toggleApiKeyVisibility(): void {    const apiKeyInput = this.elements.apiKey as HTMLInputElement;    const toggleButton = this.elements.toggleApiKeyButton as HTMLButtonElement;    const isPassword = apiKeyInput.type === 'password';    apiKeyInput.type = isPassword ? 'text' : 'password';    toggleButton.textContent = isPassword ? '🙈' : '👁️';    toggleButton.classList.toggle('active', isPassword);    this.updateApiKeyDisplay(!isPassword);  }  private updateApiKeyDisplay(shouldMask: boolean): void {    const apiKeyInput = this.elements.apiKey as HTMLInputElement;    const currentValue = apiKeyInput.value;    if (!currentValue || !shouldMask) return;    if (!apiKeyInput.dataset.realKey) {      apiKeyInput.dataset.realKey = currentValue;    }    if (shouldMask && currentValue.length > 8) {      const masked = currentValue.slice(0, 4) + '•'.repeat(currentValue.length - 8) + currentValue.slice(-4);      apiKeyInput.value = masked;    } else if (!shouldMask && apiKeyInput.dataset.realKey) {      apiKeyInput.value = apiKeyInput.dataset.realKey;    }  }  private validateApiKeyFormat(apiKey: string): boolean {    const legacyPattern = /^sk-or-[a-zA-Z0-9]{40,}$/;    const newPattern = /^sk-or-v1-[a-fA-F0-9]{64}$/;    return legacyPattern.test(apiKey) || newPattern.test(apiKey);  }  private showMessage(message: string, type: 'info' | 'success' | 'warning' | 'error'): void {    if (this.elements.statusMessage) {      this.elements.statusMessage.textContent = message;      this.elements.statusMessage.className = `status-message ${type}`;      this.elements.statusMessage.style.display = 'block';    }  }  private clearMessage(): void {    if (this.elements.statusMessage) {      this.elements.statusMessage.style.display = 'none';      this.elements.statusMessage.textContent = '';      this.elements.statusMessage.className = 'status-message';    }  }  private openExternalLink(url: string): void {    chrome.tabs.create({ url });  }}function initializePopup() {  console.log('Smart Reply Popup: Initializing...');  const statusDiv = document.getElementById('status-message');  if (statusDiv) {    statusDiv.textContent = 'Loading...';    statusDiv.style.display = 'block';  }  try {    new SmartReplyPopup();    console.log('Smart Reply Popup: Initialized successfully');    if (statusDiv) {      statusDiv.textContent = '';      statusDiv.style.display = 'none';    }  } catch (error) {    console.error('Smart Reply Popup: Failed to initialize', error);    if (statusDiv) {      statusDiv.textContent = 'Error: ' + error;      statusDiv.style.display = 'block';      statusDiv.style.color = 'red';    }  }  document.addEventListener('click', (e) => {    const target = e.target as HTMLElement;    if (target.tagName === 'A' && target.getAttribute('target') === '_blank') {      e.preventDefault();      const url = target.getAttribute('href');      if (url) {        chrome.tabs.create({ url });      }    }  });}if (document.readyState === 'loading') {  document.addEventListener('DOMContentLoaded', initializePopup);} else {  initializePopup();}setTimeout(() => {  if (!document.querySelector('.popup-container')?.hasAttribute('data-initialized')) {    console.log('Smart Reply Popup: Fallback initialization');    initializePopup();  }}, 100);
```

services\arsenalService.ts
```ts
/** * Arsenal Mode Service for TweetCraft * Pre-generate and store ready-to-use replies */import { TEMPLATES } from '@/content/presetTemplates';import { TONES } from '@/content/toneSelector';import type { PresetTemplate } from '@/content/presetTemplates';import type { ToneOption } from '@/content/toneSelector';import arsenalRepliesData from '@/data/arsenalReplies.json';interface ArsenalReply {  id: string;  templateId: string;  toneId: string;  text: string;  category: string;  tags: string[];  usageCount: number;  lastUsed?: Date;  createdAt: Date;  temperature: number;  isFavorite: boolean;}export interface ArsenalCategory {  id: string;  name: string;  emoji: string;  icon?: string;  replies: ArsenalReply[];}interface GenerationOptions {  count: number;  templates?: string[];  tones?: string[];  categories?: string[];}export class ArsenalService {  private arsenal: Map<string, ArsenalReply> = new Map();  private categories: Map<string, ArsenalCategory> = new Map();  private db: IDBDatabase | null = null;  private readonly DB_NAME = 'TweetCraftArsenal';  private readonly DB_VERSION = 1;  private readonly STORE_NAME = 'replies';  constructor() {    this.initializeDB();    this.initializeCategories();    console.log('%c⚔️ ArsenalService initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Initialize IndexedDB for storing pre-generated replies   */  private async initializeDB(): Promise<void> {    return new Promise((resolve, reject) => {      try {        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);        request.onerror = () => {          console.error('Failed to open IndexedDB:', request.error);          resolve();        };        request.onsuccess = () => {          this.db = request.result;          console.log('%c⚔️ Arsenal database opened', 'color: #17BF63');          this.loadFromDB().catch(error => {            console.error('Failed to load from DB:', error);          });          resolve();        };        request.onupgradeneeded = (event: IDBVersionChangeEvent) => {          const db = (event.target as IDBOpenDBRequest).result;          if (!db.objectStoreNames.contains(this.STORE_NAME)) {            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });            store.createIndex('category', 'category', { unique: false });            store.createIndex('templateId', 'templateId', { unique: false });            store.createIndex('toneId', 'toneId', { unique: false });            store.createIndex('usageCount', 'usageCount', { unique: false });            store.createIndex('lastUsed', 'lastUsed', { unique: false });            console.log('%c⚔️ Arsenal database created', 'color: #17BF63');          }        };      } catch (error) {        console.error('Failed to initialize IndexedDB:', error);        resolve();       }    });  }  /**   * Initialize reply categories   */  private initializeCategories(): void {    const defaultCategories = [      { id: 'quick', name: 'Quick Responses', emoji: '⚡', icon: '⚡' },      { id: 'debate', name: 'Debate Arsenal', emoji: '⚔️', icon: '⚔️' },      { id: 'humor', name: 'Humor Bank', emoji: '😂', icon: '😂' },      { id: 'support', name: 'Support Replies', emoji: '💪', icon: '💪' },      { id: 'professional', name: 'Professional', emoji: '💼', icon: '💼' },      { id: 'viral', name: 'Viral Potential', emoji: '🔥', icon: '🔥' }    ];    defaultCategories.forEach(cat => {      this.categories.set(cat.id, { ...cat, replies: [] });    });    this.loadPreGeneratedReplies();  }  /**   * Load pre-generated replies from JSON   */  private loadPreGeneratedReplies(): void {    try {      if (arsenalRepliesData && arsenalRepliesData.categories) {        arsenalRepliesData.categories.forEach((category: any) => {          category.replies.forEach((reply: any) => {            const arsenalReply: ArsenalReply = {              id: reply.id || `${category.id}-${Date.now()}-${Math.random()}`,              templateId: reply.templateId || '',              toneId: reply.toneId || '',              text: reply.text,              category: category.id,              tags: reply.tags || [],              usageCount: 0,              createdAt: new Date(),              temperature: reply.temperature || 0.7,              isFavorite: false            };            this.arsenal.set(arsenalReply.id, arsenalReply);            const cat = this.categories.get(category.id);            if (cat) {              cat.replies.push(arsenalReply);            }          });        });        console.log(`%c⚔️ Loaded ${this.arsenal.size} pre-generated replies`, 'color: #17BF63');      }    } catch (error) {      console.error('Failed to load pre-generated replies:', error);    }  }  /**   * Pre-generate replies for arsenal   */  async generateArsenal(options: GenerationOptions): Promise<ArsenalReply[]> {    console.log('%c⚔️ Generating arsenal', 'color: #1DA1F2', options);    const generated: ArsenalReply[] = [];    const templates = options.templates       ? options.templates.map(id => TEMPLATES.find((t: PresetTemplate) => t.id === id)).filter(Boolean) as PresetTemplate[]      : TEMPLATES;    const tones = options.tones      ? options.tones.map(id => TONES.find((t: ToneOption) => t.id === id)).filter(Boolean) as ToneOption[]      : TONES;    const combinations: Array<{ template: PresetTemplate, tone: ToneOption }> = [];    templates.forEach((template: PresetTemplate) => {      tones.forEach((tone: ToneOption) => {        if (options.categories && !options.categories.includes(template.category)) {          return;        }        combinations.push({ template, tone });      });    });    const shuffled = this.shuffle(combinations);    const limited = shuffled.slice(0, options.count);    for (const { template, tone } of limited) {      const reply = this.createMockReply(template, tone);      generated.push(reply);      this.addReply(reply);    }    console.log(`%c⚔️ Generated ${generated.length} replies`, 'color: #17BF63');    return generated;  }  /**   * Create a mock reply (placeholder for actual API generation)   */  private createMockReply(template: PresetTemplate, tone: ToneOption): ArsenalReply {    const id = `arsenal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;    const mockTexts = {      'ask_question:professional': "That's an interesting point. Could you elaborate on how this approach differs from traditional methods?",      'ask_question:witty': "Fascinating take! Quick question though - is this the innovation we've been waiting for, or just old wine in new bottles? 🍷",      'agree_expand:enthusiastic': "YES! This is exactly what I've been saying! And to add to your brilliant point - this could revolutionize how we approach the entire industry! 🚀",      'challenge:contrarian': "Interesting perspective, but have you considered the opposite might be true? The data suggests a completely different conclusion when viewed through a critical lens.",      'hot_take:savage': "Unpopular opinion: Everyone's overthinking this. The solution is ridiculously simple, we're just too invested in complexity to see it. 🔥",      'meme_response:gen_z': "no bc this is literally me trying to explain why this matters and everyone's just... not getting it fr fr 💀",      'default': `${template.prompt} [${tone.label} style]`    };    const key = `${template.id}:${tone.id}`;    const text = mockTexts[key as keyof typeof mockTexts] || mockTexts.default;    return {      id,      templateId: template.id,      toneId: tone.id,      text,      category: template.category,      tags: [template.category, tone.id, 'pre-generated'],      usageCount: 0,      createdAt: new Date(),      temperature: this.getTemperatureForTone(tone.id),      isFavorite: false    };  }  /**   * Add reply to arsenal with validation   */  async addReply(reply: ArsenalReply): Promise<void> {    if (!reply.id || !reply.text || !reply.category) {      console.error('Invalid reply: missing required fields', reply);      return;    }    this.arsenal.set(reply.id, reply);    const category = this.categories.get(reply.category);    if (category) {      if (!category.replies.find(r => r.id === reply.id)) {        category.replies.push(reply);      }    }    if (this.db) {      try {        const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');        const store = transaction.objectStore(this.STORE_NAME);        store.put(reply);      } catch (error) {        console.error('Failed to save reply to DB:', error);      }    }  }  /**   * Get all categories   */  getCategories(): ArsenalCategory[] {    return Array.from(this.categories.values());  }  /**   * Get reply by ID   */  getReply(id: string): ArsenalReply | undefined {    return this.arsenal.get(id);  }  /**   * Get replies by category   */  getRepliesByCategory(categoryId: string): ArsenalReply[] {    const category = this.categories.get(categoryId);    return category ? category.replies : [];  }  /**   * Track usage of a reply (unified with useReply)   */  async trackUsage(replyId: string): Promise<void> {    await this.useReply(replyId);  }  /**   * Get suggested replies based on context   */  getSuggestedReplies(context: {    text?: string;    category?: string;    limit?: number;  }): ArsenalReply[] {    let replies = Array.from(this.arsenal.values());    if (context.category) {      replies = replies.filter(r => r.category === context.category);    }    replies.sort((a, b) => {      if (a.isFavorite && !b.isFavorite) return -1;      if (!a.isFavorite && b.isFavorite) return 1;      if (a.usageCount !== b.usageCount) {        return b.usageCount - a.usageCount;      }      const aTime = a.lastUsed?.getTime() || 0;      const bTime = b.lastUsed?.getTime() || 0;      return bTime - aTime;    });    return replies.slice(0, context.limit || 10);  }  /**   * Use a reply (increment usage count)   */  async useReply(id: string): Promise<void> {    const reply = this.arsenal.get(id);    if (reply) {      reply.usageCount++;      reply.lastUsed = new Date();      if (this.db) {        try {          const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');          const store = transaction.objectStore(this.STORE_NAME);          const request = store.put(reply);          request.onerror = () => {            console.error('Failed to update reply usage in DB:', request.error);          };        } catch (error) {          console.error('Database transaction failed:', error);        }      }      console.log('%c⚔️ Reply used:', 'color: #657786', id, `(count: ${reply.usageCount})`);    }  }  /**   * Toggle favorite status   */  async toggleFavorite(id: string): Promise<boolean> {    const reply = this.arsenal.get(id);    if (reply) {      reply.isFavorite = !reply.isFavorite;      if (this.db) {        try {          const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');          const store = transaction.objectStore(this.STORE_NAME);          const request = store.put(reply);          request.onerror = () => {            console.error('Failed to update favorite status in DB:', request.error);          };        } catch (error) {          console.error('Database transaction failed:', error);        }      }      console.log('%c⚔️ Favorite toggled:', 'color: #FFA500', id, reply.isFavorite);      return reply.isFavorite;    }    return false;  }  /**   * Delete reply from arsenal   */  async deleteReply(id: string): Promise<void> {    const reply = this.arsenal.get(id);    if (reply) {      this.arsenal.delete(id);      const category = this.categories.get(reply.category);      if (category) {        const index = category.replies.findIndex(r => r.id === id);        if (index > -1) {          category.replies.splice(index, 1);        }      }      if (this.db) {        try {          const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');          const store = transaction.objectStore(this.STORE_NAME);          const request = store.delete(id);          request.onerror = () => {            console.error('Failed to delete reply from DB:', request.error);          };        } catch (error) {          console.error('Database transaction failed:', error);        }      }      console.log('%c⚔️ Reply deleted:', 'color: #DC3545', id);    }  }  /**   * Load replies from IndexedDB   */  private async loadFromDB(): Promise<void> {    if (!this.db) return;    const transaction = this.db.transaction([this.STORE_NAME], 'readonly');    const store = transaction.objectStore(this.STORE_NAME);    const request = store.getAll();    request.onsuccess = () => {      const replies = request.result as ArsenalReply[];      replies.forEach(reply => {        reply.createdAt = new Date(reply.createdAt);        if (reply.lastUsed) {          reply.lastUsed = new Date(reply.lastUsed);        }        this.arsenal.set(reply.id, reply);        const category = this.categories.get(reply.category);        if (category) {          category.replies.push(reply);        }      });      console.log(`%c⚔️ Loaded ${replies.length} replies from database`, 'color: #17BF63');    };  }  /**   * Clear all replies   */  async clearArsenal(): Promise<void> {    this.arsenal.clear();    this.categories.forEach(cat => cat.replies = []);    if (this.db) {      const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');      const store = transaction.objectStore(this.STORE_NAME);      store.clear();    }    console.log('%c⚔️ Arsenal cleared', 'color: #FFA500');  }  /**   * Get arsenal statistics   */  getStats(): {    totalReplies: number;    byCategory: Record<string, number>;    favorites: number;    mostUsed: ArsenalReply | null;    averageUsage: number;  } {    const replies = Array.from(this.arsenal.values());    const byCategory: Record<string, number> = {};    this.categories.forEach((cat, id) => {      byCategory[id] = cat.replies.length;    });    const favorites = replies.filter(r => r.isFavorite).length;    const mostUsed = replies.reduce((max, r) =>       !max || r.usageCount > max.usageCount ? r : max, null as ArsenalReply | null    );    const totalUsage = replies.reduce((sum, r) => sum + r.usageCount, 0);    const averageUsage = replies.length > 0 ? totalUsage / replies.length : 0;    return {      totalReplies: replies.length,      byCategory,      favorites,      mostUsed,      averageUsage    };  }  /**   * Get temperature for tone   */  private getTemperatureForTone(toneId: string): number {    const temperatureMap: Record<string, number> = {      'professional': 0.3,      'witty': 0.7,      'enthusiastic': 0.6,      'casual': 0.5,      'academic': 0.2,      'sarcastic': 0.8,      'motivational': 0.6,      'contrarian': 0.7,      'gen_z': 0.9,      'philosophical': 0.5,      'minimalist': 0.1,      'savage': 0.9,      'dismissive': 0.4    };    return temperatureMap[toneId] || 0.5;  }  /**   * Shuffle array   */  private shuffle<T>(array: T[]): T[] {    const result = [...array];    for (let i = result.length - 1; i > 0; i--) {      const j = Math.floor(Math.random() * (i + 1));      [result[i], result[j]] = [result[j], result[i]];    }    return result;  }  /**   * Export arsenal to JSON   */  exportToJSON(): string {    const data = {      replies: Array.from(this.arsenal.values()),      stats: this.getStats(),      exportedAt: new Date().toISOString()    };    return JSON.stringify(data, null, 2);  }  /**   * Import arsenal from JSON   */  async importFromJSON(json: string): Promise<void> {    try {      const data = JSON.parse(json);      if (data.replies && Array.isArray(data.replies)) {        for (const reply of data.replies) {          if (reply.id && reply.templateId && reply.toneId && reply.text) {            await this.addReply(reply);          }        }        console.log(`%c⚔️ Imported ${data.replies.length} replies`, 'color: #17BF63');      }    } catch (error) {      console.error('Failed to import arsenal:', error);      throw error;    }  }}export const arsenalService = new ArsenalService();
```

services\cache.ts
```ts
interface CacheEntry {  reply: string;  timestamp: number;  tweetId: string;  tone: string;}export class CacheService {  private static cache = new Map<string, CacheEntry>();  private static readonly CACHE_DURATION = 30 * 60 * 1000;   static generateCacheKey(tweetId: string, tone: string): string {    return `${tweetId}-${tone}`;  }  static get(tweetId: string, tone: string): string | null {    const key = this.generateCacheKey(tweetId, tone);    const entry = this.cache.get(key);    if (!entry) return null;    const now = Date.now();    if (now - entry.timestamp > this.CACHE_DURATION) {      this.cache.delete(key);      return null;    }    console.log('Smart Reply: Cache hit for tweet', tweetId, 'with tone', tone);    return entry.reply;  }  static set(tweetId: string, tone: string, reply: string): void {    const key = this.generateCacheKey(tweetId, tone);    const entry: CacheEntry = {      reply,      timestamp: Date.now(),      tweetId,      tone    };    this.cache.set(key, entry);    console.log('Smart Reply: Cached reply for tweet', tweetId, 'with tone', tone);    this.cleanupOldEntries();  }  static clear(): void {    this.cache.clear();    console.log('Smart Reply: Cache cleared');  }  private static cleanupOldEntries(): void {    const now = Date.now();    const entriesToDelete: string[] = [];    this.cache.forEach((entry, key) => {      if (now - entry.timestamp > this.CACHE_DURATION) {        entriesToDelete.push(key);      }    });    entriesToDelete.forEach(key => this.cache.delete(key));    if (entriesToDelete.length > 0) {      console.log(`Smart Reply: Cleaned up ${entriesToDelete.length} expired cache entries`);    }  }  static getCacheSize(): number {    return this.cache.size;  }  static getCacheStats(): { size: number; entries: string[] } {    return {      size: this.cache.size,      entries: Array.from(this.cache.keys())    };  }}
```

services\imageService.ts
```ts
/** * Image Service for TweetCraft * Handles AI image generation and web image search */import { API_CONFIG } from '@/config/apiConfig';export interface ImageResult {  url: string;  alt: string;  source: 'generated' | 'web';  thumbnail?: string;  width?: number;  height?: number;}export interface ImageGenerationOptions {  prompt: string;  style?: 'realistic' | 'cartoon' | 'artistic' | 'sketch';  size?: '256x256' | '512x512' | '1024x1024';  model?: 'dall-e-2' | 'dall-e-3' | 'stable-diffusion' | 'gemini';}export interface ImageSearchOptions {  query: string;  safeSearch?: boolean;  license?: 'creative-commons' | 'commercial' | 'any';  limit?: number;}interface CachedKeywords {  keywords: string[];  timestamp: number;}export class ImageService {  private UNSPLASH_ACCESS_KEY = '';   private keywordsCache = new Map<string, CachedKeywords>();  private readonly CACHE_TTL = 3600000;   private PEXELS_API_KEY = '';   private imageCache = new Map<string, ImageResult[]>();  constructor() {    this.loadApiKeys();    console.log('%c🖼️ ImageService initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Load API keys from storage via service worker   */  private async loadApiKeys(): Promise<void> {    try {      await new Promise<void>((resolve) => {        const timeoutId = setTimeout(() => {          console.warn('Image API keys load timeout after 5s');          resolve();        }, 5000);        chrome.runtime.sendMessage({ type: 'GET_STORAGE', keys: ['imageApiKeys'] }, (response) => {          clearTimeout(timeoutId);          if (chrome.runtime.lastError) {            console.error('Runtime error loading image API keys:', chrome.runtime.lastError.message);            resolve();            return;          }          if (response && response.success && response.data?.imageApiKeys) {            Object.assign(this, response.data.imageApiKeys);          }          resolve();        });      });    } catch (error) {      console.warn('Failed to load image API keys:', error);    }  }  /**   * Generate image using AI with retry logic   */  async generateImage(options: ImageGenerationOptions, retries: number = 3): Promise<ImageResult> {    console.log('%c🎨 Generating image', 'color: #9146FF', options);    if (retries < 3) {      console.log('%c🔄 Retry attempt', 'color: #FFA500', `${4 - retries}/3`);    }    const apiKey = await this.getOpenRouterApiKey();    if (!apiKey) {      throw new Error('OpenRouter API key not found. Please configure in extension settings.');    }    try {      const imageResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${apiKey}`,          'Content-Type': 'application/json',          'HTTP-Referer': 'https://tweetcraft.extension',          'X-Title': 'TweetCraft'        },        body: JSON.stringify({          model: 'google/gemini-2.5-flash-image-preview',          messages: [            {              role: 'user',              content: `Find or generate an image for: "${options.prompt}"                       Style: ${options.style || 'realistic'}                       Return a JSON object with a direct image URL:                       {                         "url": "https://actual-image-url.jpg",                         "alt": "description of the image"                       }`            }          ],          temperature: 0.3,          max_tokens: 50        })      });      if (!imageResponse.ok) {        throw new Error(`Image generation failed: ${imageResponse.status}`);      }      const imageData = await imageResponse.json();      const aiResponse = imageData.choices?.[0]?.message?.content?.trim();      console.log('%c🎨 AI Response:', 'color: #657786', aiResponse);      const searchPrompt = `Find high-quality ${options.style || 'realistic'} images for: "${options.prompt}"Return a JSON array of 4-6 image results with this exact format:[  {    "url": "direct image URL (must be a real, accessible image URL)",    "alt": "brief description",    "source": "website name"  }]Focus on finding actual direct image URLs from sources like Unsplash, Pexels, Pixabay, or other free image sites. Return ONLY the JSON array.`;      let searchData: any = null;      let lastError: Error | null = null;      const maxRetries = 2;      for (let attempt = 0; attempt < maxRetries; attempt++) {        if (attempt > 0) {          await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(3, attempt - 1)));        }        try {          const searchResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {            method: 'POST',            headers: {              'Authorization': `Bearer ${apiKey}`,              'Content-Type': 'application/json',              'HTTP-Referer': 'chrome-extension://tweetcraft',              'X-Title': 'TweetCraft Image Generation'            },            body: JSON.stringify({              model: 'perplexity/llama-3.1-sonar-small-128k-online',              messages: [                {                  role: 'system',                  content: 'You are an image search assistant. Find and return real, accessible image URLs.'                },                {                  role: 'user',                  content: searchPrompt                }              ],              temperature: 0.3,              max_tokens: 300              })          });          if (searchResponse.status === 401 || searchResponse.status === 403 || searchResponse.status === 429) {            throw new Error(`API error: ${searchResponse.status} - ${searchResponse.statusText}`);          }          if (!searchResponse.ok) {            throw new Error(`Image search failed: ${searchResponse.status}`);          }          searchData = await searchResponse.json();          break;         } catch (error) {          lastError = error as Error;          if (error instanceof Error && error.message.includes('401')) break;          if (error instanceof Error && error.message.includes('403')) break;          if (error instanceof Error && error.message.includes('429')) break;          if (attempt === maxRetries - 1) {            throw lastError;           }        }      }      const searchResultContent = searchData.choices?.[0]?.message?.content;      if (searchResultContent) {        try {          let jsonStr: string | null = null;          const fencedMatch = searchResultContent.match(/```(?:json)?\s*([\s\S]*?)```/);          if (fencedMatch) {            jsonStr = fencedMatch[1].trim();          } else {            const jsonMatch = searchResultContent.match(/\[[\s\S]*\]/);            if (jsonMatch) {              jsonStr = jsonMatch[0];            }          }          if (jsonStr) {            const results = JSON.parse(jsonStr);            if (Array.isArray(results) && results.length > 0) {              const firstResult = results[0];              const result: ImageResult = {                url: firstResult.url,                alt: firstResult.alt || options.prompt,                source: 'generated',                width: parseInt(options.size?.split('x')[0] || '512'),                height: parseInt(options.size?.split('x')[1] || '512')              };              console.log('%c✅ Image found via AI search', 'color: #17BF63', result);              return result;            }          }        } catch (parseError) {          console.warn('Failed to parse image results:', parseError);        }      }      throw new Error('Could not generate image from AI. Please try again.');    } catch (error: any) {      console.error('Failed to generate image:', error);      if (retries > 0 && !error.message?.includes('401') && !error.message?.includes('API key') && !error.message?.includes('429')) {        const delay = (4 - retries) * 1000;         console.log(`%c⏱️ Retrying in ${delay}ms...`, 'color: #FFA500');        await new Promise(resolve => setTimeout(resolve, delay));        return this.generateImage(options, retries - 1);      }      throw error;    }  }  /**   * Search for images on the web   */  async searchImages(options: ImageSearchOptions): Promise<ImageResult[]> {    console.log('%c🔍 Searching images', 'color: #1DA1F2', options);    const cacheKey = JSON.stringify(options);    if (this.imageCache.has(cacheKey)) {      console.log('%c💾 Using cached images', 'color: #657786');      return this.imageCache.get(cacheKey)!;    }    try {      const apiKey = await this.getOpenRouterApiKey();      if (apiKey) {        const results = await this.searchImagesPerplexity(options);        if (results.length > 0) {          this.imageCache.set(cacheKey, results);          return results;        }      }      if (this.UNSPLASH_ACCESS_KEY) {        const results = await this.searchUnsplash(options);        if (results.length > 0) {          this.imageCache.set(cacheKey, results);          return results;        }      }      if (this.PEXELS_API_KEY) {        const results = await this.searchPexels(options);        if (results.length > 0) {          this.imageCache.set(cacheKey, results);          return results;        }      }      console.log('%c⚠️ Search failed, no results available', 'color: #FFA500');      return [];    } catch (error) {      console.error('Failed to search images:', error);      return [];    }  }  /**   * Search for images using Perplexity via OpenRouter   */  async searchImagesPerplexity(options: ImageSearchOptions): Promise<ImageResult[]> {    console.log('%c🔍 IMAGE SEARCH (Perplexity)', 'color: #1DA1F2; font-weight: bold');    console.log('%c  Query:', 'color: #657786', options.query);    const apiKey = await this.getOpenRouterApiKey();    if (!apiKey) {      throw new Error('OpenRouter API key not configured');    }    const prompt = `Find and return real image URLs for: "${options.query}"Search the web for actual images related to this query. Look for:- News images from Reuters, AP, Getty Images- Stock photos from Unsplash, Pexels, Shutterstock  - Relevant memes or reaction images- Political cartoons if applicable- Real photographs that match the search termsReturn a JSON array with 4-6 REAL image URLs that actually exist:[  {    "url": "https://actual-image-url.jpg",    "thumbnail": "thumbnail URL or same as url",    "alt": "what the image shows",    "source": "website name"  }]IMPORTANT: Return only REAL, working image URLs that you find on the web. No placeholders.Return ONLY the JSON array, no explanations.`;    try {      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${apiKey}`,          'Content-Type': 'application/json',          'HTTP-Referer': 'chrome-extension://tweetcraft',          'X-Title': 'TweetCraft Image Search'        },        body: JSON.stringify({          model: 'perplexity/sonar',          messages: [            {              role: 'system',              content: 'You are an image search assistant. Return only valid JSON arrays of image results.'            },            {              role: 'user',              content: prompt            }          ],          temperature: 0.3,          max_tokens: 800        })      });      if (!response.ok) {        const errorData = await response.json().catch(() => ({}));        console.error('Perplexity search error:', errorData);        throw new Error(`Search failed: ${response.status}`);      }      const data = await response.json();      const content = data.choices[0]?.message?.content;      if (content) {        try {          const jsonMatch = content.match(/\[[\s\S]*\]/);          if (jsonMatch) {            const results = JSON.parse(jsonMatch[0]);            const imageResults = results.map((item: any) => ({              url: item.url,              thumbnail: item.thumbnail || item.url,              alt: item.alt || item.description || options.query,              source: 'web' as const,              width: 800,              height: 600            }));            console.log('%c✅ Found images:', 'color: #17BF63', imageResults.length);            return imageResults;          }        } catch (parseError) {          console.warn('Failed to parse search results:', parseError);        }      }    } catch (error) {      console.error('Perplexity search error:', error);    }    console.log('%c⚠️ No search results available', 'color: #FFA500');    return [];  }  /**   * Search Unsplash for images   */  private async searchUnsplash(options: ImageSearchOptions): Promise<ImageResult[]> {    const params = new URLSearchParams({      query: options.query,      per_page: String(options.limit || 5),      orientation: 'landscape'    });    const response = await fetch(`https://api.unsplash.com/search/photos?${params}`, {      headers: {        'Authorization': `Client-ID ${this.UNSPLASH_ACCESS_KEY}`      }    });    if (!response.ok) {      throw new Error(`Unsplash API error: ${response.statusText}`);    }    const data = await response.json();    return data.results.map((photo: any) => ({      url: photo.urls.regular,      thumbnail: photo.urls.thumb,      alt: photo.description || photo.alt_description || options.query,      source: 'web' as const,      width: photo.width,      height: photo.height    }));  }  /**   * Search Pexels for images   */  private async searchPexels(options: ImageSearchOptions): Promise<ImageResult[]> {    const params = new URLSearchParams({      query: options.query,      per_page: String(options.limit || 5),      orientation: 'landscape'    });    const response = await fetch(`https://api.pexels.com/v1/search?${params}`, {      headers: {        'Authorization': this.PEXELS_API_KEY      }    });    if (!response.ok) {      throw new Error(`Pexels API error: ${response.statusText}`);    }    const data = await response.json();    return data.photos.map((photo: any) => ({      url: photo.src.large,      thumbnail: photo.src.tiny,      alt: photo.alt || options.query,      source: 'web' as const,      width: photo.width,      height: photo.height    }));  }  /**   * Get OpenRouter API key from storage via service worker   */  private async getOpenRouterApiKey(): Promise<string | null> {    const apiKey = API_CONFIG.OPENROUTER_API_KEY;    if (!apiKey || apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {      console.error('API key not configured in apiConfig.ts');      return null;    }    return apiKey;  }  /**   * Generate a mock image URL (placeholder)   */  private async generateMockImage(prompt: string): Promise<string> {    const seed = prompt.split(' ').join('-').toLowerCase();    return `https://picsum.photos/seed/${seed}/512/512`;  }  /**   * Get mock images for testing   */  private getMockImages(query: string): ImageResult[] {    const mockImages: ImageResult[] = [];    for (let i = 1; i <= 3; i++) {      mockImages.push({        url: `https://picsum.photos/seed/${query}-${i}/800/600`,        thumbnail: `https://picsum.photos/seed/${query}-${i}/200/150`,        alt: `${query} image ${i}`,        source: 'web',        width: 800,        height: 600      });    }    return mockImages;  }  /**   * Suggest images based on tweet context   */  async suggestImages(tweetText: string, replyText: string): Promise<ImageResult[]> {    console.log('%c🤖 Suggesting images based on context', 'color: #FFA500');    console.log('%c  Tweet text:', 'color: #657786', tweetText);    console.log('%c  Reply text:', 'color: #657786', replyText);    const combinedText = `${tweetText} ${replyText}`.trim();    if (!combinedText) {      console.log('%c  No text available for suggestions', 'color: #FFA500');      return [];    }    const keywords = this.extractKeywords(combinedText);    console.log('%c  Extracted keywords:', 'color: #657786', keywords);    if (keywords.length === 0) {      const simpleWords = combinedText        .toLowerCase()        .split(/\s+/)        .filter(word => word.length > 4)        .slice(0, 3);      if (simpleWords.length > 0) {        const searchQuery = simpleWords.join(' ');        console.log('%c  Using simple words:', 'color: #657786', searchQuery);        return this.searchImages({          query: searchQuery,          limit: 3,          safeSearch: true        });      }      return [];    }    const searchQuery = keywords.slice(0, 3).join(' ');    console.log('%c  Search query:', 'color: #657786', searchQuery);    return this.searchImages({      query: searchQuery,      limit: 3,      safeSearch: true    });  }  /**   * Extract smart contextual search terms using AI   */  private async extractSmartContext(text: string): Promise<string | null> {    try {      const apiKey = await this.getOpenRouterApiKey();      if (!apiKey) {        return null;      }      const prompt = `Analyze this text and extract the most relevant image search terms. Focus on the underlying meaning, emotions, and implications rather than just literal keywords.Text: "${text}"Provide 3-5 highly relevant search terms that would find appropriate images for this context. Consider:- The actual topic being discussed- Emotional undertones and implications- Visual metaphors that match the sentiment- Related concepts that aren't explicitly mentionedFor example:- "Trump is old and sick" → "elderly politician, hospital bed, medical care, frail leader"- "Biden cognitive decline" → "confused elderly, dementia symptoms, nursing home, memory loss"- "Economic collapse coming" → "stock market crash, recession graph, empty shelves, unemployment line"Return ONLY the search terms, separated by commas. No explanation.`;      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${apiKey}`,          'Content-Type': 'application/json',          'HTTP-Referer': 'chrome-extension://tweetcraft',          'X-Title': 'TweetCraft Context Analysis'        },        body: JSON.stringify({          model: 'anthropic/claude-3-haiku',          messages: [            {              role: 'user',              content: prompt            }          ],          temperature: 0.8,          max_tokens: 150        })      });      if (!response.ok) {        console.error('Context extraction failed:', response.status);        return null;      }      const data = await response.json();      const searchTerms = data.choices[0]?.message?.content?.trim();      if (searchTerms) {        const terms = searchTerms          .split(',')          .map((term: string) => term.trim())          .filter((term: string) => term.length > 0)          .slice(0, 4)          .join(' ');        return terms;      }    } catch (error) {      console.error('Smart context extraction error:', error);    }    return null;  }  /**   * Generate smart image prompt from context   */  async generateSmartPrompt(tweetText: string, replyText: string): Promise<string> {    console.log('%c🎨 Generating smart image prompt', 'color: #1DA1F2');    try {      const apiKey = await this.getOpenRouterApiKey();      if (!apiKey) {        throw new Error('OpenRouter API key not found. Please configure your API key in the extension settings.');      }      const combinedText = `${tweetText} ${replyText}`.trim() || 'general topic';      const prompt = `Based on this Twitter conversation, generate a creative and relevant image generation prompt that captures the essence of what's being discussed.Context: "${combinedText}"Create a detailed, visual prompt for image generation that:- Captures the main theme or sentiment- Includes relevant visual elements- Specifies style, mood, and composition- Is appropriate for social mediaExample outputs:- "Professional photo of elderly politician in hospital bed, concerned doctors nearby, dramatic lighting"- "Digital art of stock market crash chart, red arrows pointing down, panicked traders in background"- "Realistic photo of empty store shelves, dystopian atmosphere, worried shoppers"Return ONLY the image generation prompt, no explanation.`;      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${apiKey}`,          'Content-Type': 'application/json',          'HTTP-Referer': 'chrome-extension://tweetcraft',          'X-Title': 'TweetCraft Prompt Generation'        },        body: JSON.stringify({          model: 'anthropic/claude-3-haiku',          messages: [            {              role: 'user',              content: prompt            }          ],          temperature: 0.9,          max_tokens: 200        })      });      if (!response.ok) {        const errorMsg = `Prompt generation failed with status ${response.status}`;        console.error(errorMsg);        throw new Error(errorMsg);      }      const data = await response.json();      const generatedPrompt = data.choices[0]?.message?.content?.trim();      if (generatedPrompt) {        console.log('%c✅ Generated prompt:', 'color: #17BF63', generatedPrompt);        return generatedPrompt;      }      throw new Error('Failed to generate prompt: No content in response');    } catch (error) {      console.error('Smart prompt generation error:', error);      throw error;    }  }  /**   * Clear the keywords cache   */  public clearKeywordsCache(): void {    this.keywordsCache.clear();  }  /**   * Clean expired cache entries   */  private cleanExpiredCache(): void {    const now = Date.now();    for (const [key, value] of this.keywordsCache.entries()) {      if (now - value.timestamp > this.CACHE_TTL) {        this.keywordsCache.delete(key);      }    }  }  /**   * Extract keywords from text   */  private extractKeywords(text: string): string[] {    const cached = this.keywordsCache.get(text);    if (cached && (Date.now() - cached.timestamp < this.CACHE_TTL)) {      console.log('%c💾 Keywords cache hit', 'color: #657786');      return cached.keywords;    }    if (Math.random() < 0.1) {      this.cleanExpiredCache();    }    let cleanText = text      .replace(/https?:\/\/\S+/g, '')      .replace(/@\w+/g, '');    const hashtags = text.match(/#(\w+)/g)?.map(tag => tag.slice(1).toLowerCase()) || [];    cleanText = cleanText.replace(/#\w+/g, '');    const stopWords = new Set([      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',      'of', 'with', 'by', 'from', 'is', 'are', 'was', 'were', 'been', 'be',      'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',      'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these',      'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'what', 'which',      'who', 'when', 'where', 'why', 'how', 'all', 'each', 'every', 'some',      'any', 'few', 'more', 'most', 'other', 'such', 'only', 'own', 'same',      'so', 'than', 'too', 'very', 'just', 'now', 'also', 'about', 'after',      'before', 'because', 'between', 'both', 'during', 'either', 'however',      'if', 'into', 'its', 'no', 'not', 'of', 'off', 'once', 'only', 'or',      'over', 'since', 'still', 'such', 'then', 'there', 'therefore', 'though',      'through', 'throughout', 'thus', 'together', 'under', 'until', 'upon',      'us', 'use', 'used', 'using', 'via', 'while', 'within', 'without', 'yet'    ]);    const words = cleanText      .toLowerCase()      .replace(/[^\w\s]/g, ' ')       .split(/\s+/)      .filter(word => word.length > 2 && !stopWords.has(word) && !/^\d+$/.test(word));    const wordFreq = new Map<string, number>();    words.forEach(word => {      wordFreq.set(word, (wordFreq.get(word) || 0) + 1);    });    hashtags.forEach(tag => {      if (tag.length > 2 && !stopWords.has(tag)) {        wordFreq.set(tag, (wordFreq.get(tag) || 0) + 2);      }    });    const keywords = Array.from(wordFreq.entries())      .sort((a, b) => b[1] - a[1])      .map(([word]) => word)      .slice(0, 5);    if (this.keywordsCache.size >= 100) {      const firstKey = this.keywordsCache.keys().next().value;      if (firstKey) {        this.keywordsCache.delete(firstKey);      }    }    this.keywordsCache.set(text, { keywords, timestamp: Date.now() });    console.log('%c🔍 Keywords extracted and cached', 'color: #657786', keywords);    return keywords;  }  /**   * Download image to blob for upload   */  async downloadImage(url: string): Promise<Blob> {    const response = await fetch(url);    if (!response.ok) {      throw new Error(`Failed to download image: ${response.statusText}`);    }    return response.blob();  }  /**   * Clear image cache   */  clearCache(): void {    this.imageCache.clear();    console.log('%c🗑️ Image cache cleared', 'color: #FFA500');  }}export const imageService = new ImageService();
```

services\lazyLoader.ts
```ts
/** * Lazy Loading Service for TweetCraft * Efficient loading of templates and resources on demand */import { Template, Tone } from '@/config/templatesAndTones';import { configManager } from '@/config/configurationManager';interface LoaderConfig {  chunkSize: number;  preloadDelay: number;  priorityItems: string[];}interface LoadingState {  isLoading: boolean;  loadedChunks: Set<number>;  totalChunks: number;  loadedItems: Set<string>;}export class LazyLoader {  private config: LoaderConfig = {    chunkSize: 6,     preloadDelay: 100,     priorityItems: []   };  private loadingState: LoadingState = {    isLoading: false,    loadedChunks: new Set(),    totalChunks: 0,    loadedItems: new Set()  };  private intersectionObserver: IntersectionObserver | null = null;  private idleCallback: number | null = null;  constructor() {    this.initializeObserver();    console.log('%c⚡ LazyLoader initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Initialize intersection observer for viewport-based loading   */  private initializeObserver(): void {    if ('IntersectionObserver' in window) {      this.intersectionObserver = new IntersectionObserver(        (entries) => {          entries.forEach(entry => {            if (entry.isIntersecting) {              const element = entry.target as HTMLElement;              this.loadElement(element);            }          });        },        {          root: null,          rootMargin: '50px',           threshold: 0.01        }      );    }  }  /**   * Load templates in chunks   */  async loadTemplates(    templates: Template[],    container: HTMLElement,    renderCallback: (templates: Template[]) => void  ): Promise<void> {    console.log('%c⚡ Loading templates lazily', 'color: #1DA1F2', `${templates.length} total`);    this.loadingState.isLoading = true;    this.loadingState.totalChunks = Math.ceil(templates.length / this.config.chunkSize);    const sortedTemplates = this.sortByPriority(templates) as Template[];    const firstChunk = sortedTemplates.slice(0, this.config.chunkSize);    renderCallback(firstChunk);    this.markAsLoaded(firstChunk.map(t => t.id));    this.loadingState.loadedChunks.add(0);    for (let i = 1; i < this.loadingState.totalChunks; i++) {      await this.loadChunkWhenIdle(        sortedTemplates,        i,        renderCallback      );    }    this.loadingState.isLoading = false;    console.log('%c⚡ All templates loaded', 'color: #17BF63');  }  /**   * Load tones with lazy loading   */  async loadTones(    tones: Tone[],    container: HTMLElement,    renderCallback: (tones: Tone[]) => void  ): Promise<void> {    console.log('%c⚡ Loading tones lazily', 'color: #1DA1F2', `${tones.length} total`);    const midPoint = Math.ceil(tones.length / 2);    const firstHalf = tones.slice(0, midPoint);    renderCallback(firstHalf);    this.markAsLoaded(firstHalf.map(t => t.id));    if ('requestIdleCallback' in window) {      requestIdleCallback(() => {        const secondHalf = tones.slice(midPoint);        renderCallback(secondHalf);        this.markAsLoaded(secondHalf.map(t => t.id));      });    } else {      setTimeout(() => {        const secondHalf = tones.slice(midPoint);        renderCallback(secondHalf);        this.markAsLoaded(secondHalf.map(t => t.id));      }, 100);    }  }  /**   * Load chunk when browser is idle   */  private async loadChunkWhenIdle(    items: (Template | Tone)[],    chunkIndex: number,    renderCallback: (items: any[]) => void  ): Promise<void> {    return new Promise((resolve) => {      const loadChunk = () => {        const start = chunkIndex * this.config.chunkSize;        const end = Math.min(start + this.config.chunkSize, items.length);        const chunk = items.slice(start, end);        renderCallback(chunk);        this.markAsLoaded(chunk.map(item => item.id));        this.loadingState.loadedChunks.add(chunkIndex);        console.log(`%c⚡ Loaded chunk ${chunkIndex + 1}/${this.loadingState.totalChunks}`, 'color: #657786');        resolve();      };      if ('requestIdleCallback' in window) {        this.idleCallback = requestIdleCallback(loadChunk, { timeout: 500 });      } else {        setTimeout(loadChunk, this.config.preloadDelay);      }    });  }  /**   * Sort items by priority (favorites first, then by usage)   */  private sortByPriority(items: (Template | Tone)[]): (Template | Tone)[] {    return items.sort((a, b) => {      const aPriority = this.config.priorityItems.includes(a.id);      const bPriority = this.config.priorityItems.includes(b.id);      if (aPriority && !bPriority) return -1;      if (!aPriority && bPriority) return 1;      if ('category' in a && 'category' in b) {        const categoryOrder = ['engagement', 'value', 'conversation', 'humor', 'debate', 'viral'];        const aIndex = categoryOrder.indexOf(a.category);        const bIndex = categoryOrder.indexOf(b.category);        return aIndex - bIndex;      }      return 0;    });  }  /**   * Mark items as loaded   */  private markAsLoaded(ids: string[]): void {    ids.forEach(id => this.loadingState.loadedItems.add(id));  }  /**   * Check if item is loaded   */  isLoaded(id: string): boolean {    return this.loadingState.loadedItems.has(id);  }  /**   * Observe element for lazy loading   */  observeElement(element: HTMLElement): void {    if (this.intersectionObserver) {      this.intersectionObserver.observe(element);    }  }  /**   * Stop observing element   */  unobserveElement(element: HTMLElement): void {    if (this.intersectionObserver) {      this.intersectionObserver.unobserve(element);    }  }  /**   * Load element when it enters viewport   */  private async loadElement(element: HTMLElement): Promise<void> {    const itemId = element.dataset.lazyId;    if (!itemId || this.isLoaded(itemId)) return;    console.log('%c⚡ Loading element', 'color: #1DA1F2', itemId);    element.classList.add('loading');    const template = configManager.getTemplate(itemId);    const tone = configManager.getTone(itemId);    if (template || tone) {      element.classList.remove('loading');      element.classList.add('loaded');      this.markAsLoaded([itemId]);      this.unobserveElement(element);    }  }  /**   * Preload items based on user behavior   */  async preloadBasedOnBehavior(favoriteIds: string[]): Promise<void> {    console.log('%c⚡ Preloading favorites', 'color: #1DA1F2', favoriteIds.length);    this.config.priorityItems = favoriteIds;    for (const id of favoriteIds) {      if (!this.isLoaded(id)) {        await new Promise(resolve => setTimeout(resolve, 50));        this.markAsLoaded([id]);      }    }  }  /**   * Cancel pending operations   */  cancelPending(): void {    if (this.idleCallback !== null) {      cancelIdleCallback(this.idleCallback);      this.idleCallback = null;    }    this.loadingState.isLoading = false;    console.log('%c⚡ Cancelled pending loads', 'color: #FFA500');  }  /**   * Get loading progress   */  getProgress(): number {    if (this.loadingState.totalChunks === 0) return 100;    return (this.loadingState.loadedChunks.size / this.loadingState.totalChunks) * 100;  }  /**   * Clean up observer   */  destroy(): void {    if (this.intersectionObserver) {      this.intersectionObserver.disconnect();      this.intersectionObserver = null;    }    this.cancelPending();    this.loadingState.loadedItems.clear();    this.loadingState.loadedChunks.clear();    console.log('%c⚡ LazyLoader destroyed', 'color: #FFA500');  }}export const lazyLoader = new LazyLoader();
```

services\openRouter.ts
```ts
import {   OpenRouterRequest,   OpenRouterResponse,   ReplyGenerationRequest,   ReplyGenerationResponse,  TwitterContext } from '@/types';import { StorageService } from './storage';import { CacheService } from './cache';import { URLCleaner } from '@/utils/urlCleaner';import { requestOptimizer } from './requestOptimizer';import { cleanupReply } from '@/utils/textUtils';import { logger } from '@/utils/logger';import { API_CONFIG } from '@/config/apiConfig';import { API_CONFIG as CONSTANTS, TIMING } from '@/config/constants';import { PromptArchitecture, PromptConfiguration } from './promptArchitecture';export class OpenRouterService {  private static readonly BASE_URL = 'https://openrouter.ai/api/v1';  private static readonly HEADERS = {    'Content-Type': 'application/json',    'HTTP-Referer': 'https://tweetcraft.ai/extension',    'X-Title': 'TweetCraft - AI Reply Assistant v0.0.12'  };  private static lastRequestTime = 0;  private static readonly MIN_REQUEST_INTERVAL = TIMING.MIN_REQUEST_INTERVAL;  private static readonly MAX_RETRIES = CONSTANTS.RETRY_ATTEMPTS;  private static readonly RETRY_DELAYS = CONSTANTS.RETRY_DELAYS;  private static requestCache = new Map<string, Promise<ReplyGenerationResponse>>();  private static readonly REQUEST_CACHE_TTL = 30000;   private static readonly REQUEST_CACHE_MAX_SIZE = 100;   private static batchQueue: Array<{    request: ReplyGenerationRequest;    context: TwitterContext;    resolve: (value: ReplyGenerationResponse) => void;    reject: (reason: any) => void;    timestamp: number;    signal?: AbortSignal;  }> = [];  private static batchTimer: ReturnType<typeof setTimeout> | null = null;  private static readonly BATCH_WINDOW = TIMING.BATCH_WINDOW;  private static metrics = {    requestsDeduped: 0,    requestsBatched: 0,    cacheHits: 0,    totalRequests: 0  };  private static isOnline = navigator.onLine;  private static connectionType: string = 'unknown';  private static queuedRequests: Array<{    request: ReplyGenerationRequest;    context: TwitterContext;    signal?: AbortSignal;    resolve: (value: ReplyGenerationResponse) => void;    reject: (reason: any) => void;    timestamp: number;  }> = [];  private static readonly OFFLINE_QUEUE_MAX_AGE = 300000;   private static readonly OFFLINE_QUEUE_MAX_SIZE = 50;  private static connectionMetrics = {    rtt: 0,     downlink: 0,     effectiveType: '4g' as '4g' | '3g' | '2g' | 'slow-2g'  };  private static cleanupIntervalId: ReturnType<typeof setInterval> | null = null;  static {    this.initializeNetworkMonitoring();  }  static async generateReply(    request: ReplyGenerationRequest,     context: TwitterContext,    signal?: AbortSignal,    bypassCache: boolean = false  ): Promise<ReplyGenerationResponse> {    console.log('%c🚀 AI REPLY GENERATION STARTED', 'color: #1DA1F2; font-weight: bold; font-size: 16px');    console.log('%c  Connection Status:', 'color: #657786', this.isOnline ? '✅ Online' : '❌ Offline');    console.log('%c  Connection Type:', 'color: #657786', this.connectionMetrics.effectiveType);    console.log('%c📋 GENERATION PARAMETERS', 'color: #1DA1F2; font-weight: bold; font-size: 14px');    console.log('%c  Tone:', 'color: #657786', request.tone || 'None');    console.log('%c  Model:', 'color: #657786', request.model || 'Default');    console.log('%c  Reply length:', 'color: #657786', request.replyLength || 'Default');    console.log('%c  Personality:', 'color: #657786', request.personality || 'None');    console.log('%c  Vocabulary:', 'color: #657786', request.vocabulary || 'None');    console.log('%c  Rhetoric:', 'color: #657786', request.rhetoric || 'None');    console.log('%c  Length pacing:', 'color: #657786', request.lengthPacing || 'None');    console.log('%c  Custom prompt:', 'color: #657786', request.customPrompt ? '✅ YES' : '❌ NO');    console.log('%c  Rewrite mode:', 'color: #657786', request.isRewriteMode ? '✅ YES' : '❌ NO');    console.log('%c  Bypass cache:', 'color: #657786', bypassCache ? '✅ YES' : '❌ NO');    console.log('%c🌐 CONTEXT INFORMATION', 'color: #1DA1F2; font-weight: bold; font-size: 14px');    console.log('%c  Tweet text length:', 'color: #657786', context.tweetText?.length || 0, 'characters');    console.log('%c  Author handle:', 'color: #657786', context.authorHandle || 'Unknown');    console.log('%c  Thread context:', 'color: #657786', context.threadContext?.length || 0, 'tweets');    console.log('%c  Is reply:', 'color: #657786', context.isReply ? '✅ YES' : '❌ NO');    console.log('%c  Tweet ID:', 'color: #657786', context.tweetId || 'None');    this.metrics.totalRequests++;    if (!this.isOnline) {      console.log('%c📴 Offline mode: Queuing request', 'color: #FFA500; font-weight: bold');      return this.queueOfflineRequest(request, context, signal);    }    try {      if (!bypassCache && context.tweetId && request.tone) {        const cachedReply = CacheService.get(context.tweetId, request.tone);        if (cachedReply) {          this.metrics.cacheHits++;          console.log('%c💾 Cache Hit:', 'color: #17BF63; font-weight: bold',                      `Hit rate: ${Math.round(this.metrics.cacheHits / this.metrics.totalRequests * 100)}%`);          return {            success: true,            reply: cachedReply          };        }      }      if (bypassCache) {        console.log('%c🔄 Cache Bypassed:', 'color: #FFA500', 'Generating fresh response');      }      const requestKey = this.generateRequestKey(request, context);      if (!bypassCache) {        const existingRequest = this.requestCache.get(requestKey);        if (existingRequest) {          this.metrics.requestsDeduped++;          console.log('%c🔄 Request Deduplicated:', 'color: #9146FF; font-weight: bold',                      `Saved ${this.metrics.requestsDeduped} duplicate requests`);          return existingRequest;        }      }      const requestPromise = this.executeBatchedRequest(request, context, signal);      if (!bypassCache) {        if (this.requestCache.size >= this.REQUEST_CACHE_MAX_SIZE) {          this.cleanupOldCacheEntries();        }        this.requestCache.set(requestKey, requestPromise);        setTimeout(() => {          this.requestCache.delete(requestKey);        }, this.REQUEST_CACHE_TTL);      }      return requestPromise;    } catch (error: any) {      console.error('%c❌ API Request Optimization Error:', 'color: #DC3545; font-weight: bold', error);      return {        success: false,        error: 'API optimization failed. Please try again.'      };    }  }  /**   * Generate unique key for request deduplication   */  private static generateRequestKey(request: ReplyGenerationRequest, context: TwitterContext): string {    const keyData = {      originalTweet: request.originalTweet,      tone: request.tone,      tweetId: context.tweetId,      tweetText: context.tweetText?.substring(0, 100) || ''     };    return JSON.stringify(keyData);  }  /**   * Clean up old cache entries to prevent memory leak   */  private static cleanupOldCacheEntries(): void {    const entriesToRemove = Math.floor(this.REQUEST_CACHE_MAX_SIZE * 0.2);     const iterator = this.requestCache.entries();    for (let i = 0; i < entriesToRemove; i++) {      const { value, done } = iterator.next();      if (done || !value) break;      this.requestCache.delete(value[0]);    }    console.log(`%c🧹 Cleaned up ${entriesToRemove} old cache entries`, 'color: #FFA500');  }  /**   * Execute request with intelligent batching   */  private static async executeBatchedRequest(    request: ReplyGenerationRequest,     context: TwitterContext,    signal?: AbortSignal  ): Promise<ReplyGenerationResponse> {    return new Promise((resolve, reject) => {      this.batchQueue.push({        request,        context,        resolve,        reject,        timestamp: Date.now(),        signal      });      console.log('%c📦 Request queued for batching:', 'color: #9146FF; font-weight: bold',                  `Queue size: ${this.batchQueue.length}`);      if (!this.batchTimer) {        this.batchTimer = setTimeout(() => {          this.processBatch();        }, this.BATCH_WINDOW);      }    });  }  /**   * Process batched requests   */  private static async processBatch(): Promise<void> {    if (this.batchQueue.length === 0) {      this.batchTimer = null;      return;    }    const currentBatch = [...this.batchQueue];    this.batchQueue = [];    this.batchTimer = null;    console.log('%c🚀 Processing request batch:', 'color: #1DA1F2; font-weight: bold',                `Batch size: ${currentBatch.length}`);    if (currentBatch.length > 1) {      this.metrics.requestsBatched += currentBatch.length - 1;      console.log('%c⚡ Batched requests:', 'color: #FFA500; font-weight: bold',                  `Saved ${this.metrics.requestsBatched} API calls through batching`);    }    for (const batchItem of currentBatch) {      try {        if (batchItem.signal?.aborted) {          batchItem.reject(new Error('Request was cancelled'));          continue;        }        const result = await this.executeActualRequest(batchItem.request, batchItem.context, batchItem.signal);        batchItem.resolve(result);      } catch (error) {        batchItem.reject(error);      }    }  }  /**   * Execute the actual API request (original logic)   */  private static async executeActualRequest(    request: ReplyGenerationRequest,     context: TwitterContext,    signal?: AbortSignal  ): Promise<ReplyGenerationResponse> {    try {      if (signal?.aborted) {        throw new Error('Request was cancelled');      }      const now = Date.now();      const timeSinceLastRequest = now - this.lastRequestTime;      if (timeSinceLastRequest < this.MIN_REQUEST_INTERVAL) {        await new Promise(resolve => setTimeout(resolve, this.MIN_REQUEST_INTERVAL - timeSinceLastRequest));        if (signal?.aborted) {          throw new Error('Request was cancelled');        }      }      this.lastRequestTime = Date.now();      const config = await StorageService.getConfig();      const apiKey = API_CONFIG.OPENROUTER_API_KEY;      if (!apiKey || apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {        return {          success: false,          error: 'API key not configured. Please contact the developer.'        };      }      const messages = await this.buildMessages(request, context, config);      const promptConfig: PromptConfiguration = {        systemPrompt: config.systemPrompt || '',        temperature: config.temperature || 0.7,        contextMode: config.contextMode || 'thread',        tabType: request.tabType || 'all',        customConfig: request.customConfig      };      const temperature = PromptArchitecture.getTemperature(promptConfig);      const adaptiveTimeout = this.getAdaptiveTimeout();      console.log('%c⚙️ TweetCraft Settings & Connection Adaptation', 'color: #1DA1F2; font-weight: bold; font-size: 14px');      console.log(`%c  Temperature: ${temperature}`, 'color: #657786');      console.log(`%c  Model: ${request.model || config.model || 'openai/gpt-4o'}`, 'color: #657786');      console.log(`%c  Adaptive Timeout: ${adaptiveTimeout}ms (based on ${this.connectionMetrics.effectiveType})`, 'color: #657786');      const openRouterRequest: OpenRouterRequest = {        model: request.model || config.model || 'openai/gpt-4o',        messages,        temperature,        top_p: 0.9      };      const timeoutController = new AbortController();      const combinedController = new AbortController();      const timeoutId = setTimeout(() => {        timeoutController.abort();      }, adaptiveTimeout);      const abortHandler = () => combinedController.abort();      signal?.addEventListener('abort', abortHandler);      timeoutController.signal.addEventListener('abort', abortHandler);      try {        const response = await this.fetchWithRetry(          `${this.BASE_URL}/chat/completions`,          {            method: 'POST',            headers: {              ...this.HEADERS,              'Authorization': `Bearer ${apiKey}`            },            body: JSON.stringify(openRouterRequest),            signal: combinedController.signal          }        );        clearTimeout(timeoutId);        return await this.processSuccessfulResponse(response, request, context);      } catch (error: any) {        clearTimeout(timeoutId);        if (error.name === 'AbortError' && timeoutController.signal.aborted && !signal?.aborted) {          console.log('%c⏱️ Request timeout due to poor connection', 'color: #FFA500; font-weight: bold');          return {            success: false,            error: `Request timed out after ${adaptiveTimeout}ms due to poor connection quality. Please check your internet connection and try again.`          };        }        throw error;       }    } catch (error: any) {      console.error('OpenRouter service error:', error);      if (error?.message?.includes('Failed to fetch') || error?.message?.includes('NetworkError')) {        return {          success: false,          error: 'Connection failed. Check your internet connection'        };      }      if (error?.message?.includes('timeout')) {        return {          success: false,          error: 'Request timed out. Try again'        };      }      return {        success: false,        error: 'Something went wrong. Try again'      };    }  }  private static async buildMessages(    request: ReplyGenerationRequest,    context: TwitterContext,    config: any  ) {    const messages = [];    const promptConfig: PromptConfiguration = {      systemPrompt: config.systemPrompt || '',      temperature: config.temperature || 0.7,      contextMode: config.contextMode || 'thread',      replyLength: config.replyLengthDefault,      tabType: request.tabType || 'all',       context: {        tweetText: context.tweetText,        authorHandle: context.authorHandle,        threadContext: context.threadContext,        images: context.images      }    };    if (request.tabType === 'personas' && request.personaConfig) {      promptConfig.personaConfig = request.personaConfig;    } else if (request.tabType === 'all' && request.allTabConfig) {      promptConfig.allTabConfig = request.allTabConfig;    } else if (request.tabType === 'custom' && request.customConfig) {      promptConfig.customConfig = request.customConfig;    } else if (request.tabType === 'smart' && request.allTabConfig) {      promptConfig.allTabConfig = request.allTabConfig;    } else if (request.tabType === 'favorites' && request.allTabConfig) {      promptConfig.allTabConfig = request.allTabConfig;    }    const systemPrompt = PromptArchitecture.buildSystemPrompt(promptConfig);    PromptArchitecture.logPromptArchitecture(promptConfig, systemPrompt, '', config.temperature || 0.7);    if (request.tone && !request.tabType) {      console.log('%c⚠️ Legacy tone request detected, adding to prompt', 'color: #FFA500');      const legacySystemPrompt = systemPrompt + ' ' + request.tone;      messages.push({        role: 'system' as const,        content: legacySystemPrompt      });    } else {      messages.push({        role: 'system' as const,        content: systemPrompt      });    }    let userPrompt = PromptArchitecture.buildUserPrompt(promptConfig);    if (request.customPrompt) {      userPrompt = request.customPrompt;    }    PromptArchitecture.logPromptArchitecture(promptConfig, systemPrompt, userPrompt, config.temperature || 0.7);    messages.push({      role: 'user' as const,      content: userPrompt    });    return messages;  }  private static cleanupReply(reply: string): string {    return cleanupReply(reply);  }  static async validateApiKey(apiKey?: string): Promise<boolean> {    try {      const actualApiKey = API_CONFIG.OPENROUTER_API_KEY;      if (!actualApiKey || actualApiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {        return false;      }      const response = await fetch(`${this.BASE_URL}/models`, {        headers: {          ...this.HEADERS,          'Authorization': `Bearer ${actualApiKey}`        }      });      return response.ok;    } catch (error) {      console.error('API key validation error:', error);      return false;    }  }  static async fetchAvailableModels(apiKey?: string): Promise<any[]> {    try {      const actualApiKey = API_CONFIG.OPENROUTER_API_KEY;      if (!actualApiKey || actualApiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {        console.error('API key not configured');        return [];      }      const response = await this.fetchWithRetry(        `${this.BASE_URL}/models`,        {          headers: {            ...this.HEADERS,            'Authorization': `Bearer ${actualApiKey}`          }        }      );      if (!response.ok) {        console.error('Failed to fetch models:', response.status);        return [];      }      const data = await response.json();      const models = data.data || [];      const priorityModels = [        'openai/gpt-4o',        'openai/gpt-4o-mini',        'anthropic/claude-3.5-sonnet',        'anthropic/claude-3-haiku',        'google/gemini-pro-1.5',        'meta-llama/llama-3.1-70b-instruct',        'meta-llama/llama-3.1-8b-instruct'      ];      const sortedModels = models.sort((a: any, b: any) => {        const aIndex = priorityModels.indexOf(a.id);        const bIndex = priorityModels.indexOf(b.id);        if (aIndex !== -1 && bIndex !== -1) {          return aIndex - bIndex;        }        if (aIndex !== -1) return -1;        if (bIndex !== -1) return 1;        return a.id.localeCompare(b.id);      });      return sortedModels.map((model: any) => ({        id: model.id,        name: model.name || model.id,        contextWindow: model.context_length || 'Unknown',        pricing: {          input: model.pricing?.prompt || 0,          output: model.pricing?.completion || 0        }      }));    } catch (error) {      console.error('Error fetching models:', error);      return [];    }  }  private static async fetchWithRetry(    url: string,    options: RequestInit,    attempt: number = 0  ): Promise<Response> {    try {      const response = await fetch(url, options);      if (response.ok || (response.status >= 400 && response.status < 500)) {        return response;      }      if (response.status >= 500 && attempt < this.MAX_RETRIES - 1) {        const delay = this.RETRY_DELAYS[attempt];        console.log(`Smart Reply: Server error ${response.status}, retrying in ${delay}ms (attempt ${attempt + 1}/${this.MAX_RETRIES})`);        await new Promise(resolve => setTimeout(resolve, delay));        return this.fetchWithRetry(url, options, attempt + 1);      }      return response;    } catch (error: any) {      if (attempt < this.MAX_RETRIES - 1) {        const delay = this.RETRY_DELAYS[attempt];        console.log(`Smart Reply: Network error, retrying in ${delay}ms (attempt ${attempt + 1}/${this.MAX_RETRIES})`, error.message);        await new Promise(resolve => setTimeout(resolve, delay));        return this.fetchWithRetry(url, options, attempt + 1);      }      throw error;    }  }  /**   * Get API optimization performance metrics   */  static getPerformanceMetrics() {    const metrics = { ...this.metrics };    const efficiency = metrics.totalRequests > 0 ? {      cacheHitRate: Math.round((metrics.cacheHits / metrics.totalRequests) * 100),      deduplicationRate: Math.round((metrics.requestsDeduped / metrics.totalRequests) * 100),      batchEfficiency: Math.round((metrics.requestsBatched / metrics.totalRequests) * 100),      totalEfficiency: Math.round(((metrics.cacheHits + metrics.requestsDeduped + metrics.requestsBatched) / metrics.totalRequests) * 100)    } : {      cacheHitRate: 0,      deduplicationRate: 0,      batchEfficiency: 0,      totalEfficiency: 0    };    console.log('%c📊 API OPTIMIZATION METRICS', 'color: #17BF63; font-weight: bold; font-size: 14px');    console.log('%c  Cache Hit Rate:', 'color: #657786', `${efficiency.cacheHitRate}% (${metrics.cacheHits}/${metrics.totalRequests})`);    console.log('%c  Deduplication Rate:', 'color: #657786', `${efficiency.deduplicationRate}% (${metrics.requestsDeduped} saved)`);    console.log('%c  Batch Efficiency:', 'color: #657786', `${efficiency.batchEfficiency}% (${metrics.requestsBatched} batched)`);    console.log('%c  Total Efficiency:', 'color: #657786', `${efficiency.totalEfficiency}% overall optimization`);    return { ...metrics, efficiency };  }  /**   * Reset performance metrics (for testing or cleanup)   */  static resetMetrics(): void {    this.metrics = {      requestsDeduped: 0,      requestsBatched: 0,      cacheHits: 0,      totalRequests: 0    };    this.requestCache.clear();    this.batchQueue = [];    if (this.batchTimer) {      clearTimeout(this.batchTimer);      this.batchTimer = null;    }    console.log('%c🔄 API optimization metrics reset', 'color: #1DA1F2; font-weight: bold');  }  /**   * Initialize network monitoring   */  private static initializeNetworkMonitoring(): void {    console.log('%c🌐 NETWORK RESILIENCE: Initializing monitoring', 'color: #9146FF; font-weight: bold; font-size: 14px');    window.addEventListener('online', () => {      console.log('%c🟢 Connection restored - processing queued requests', 'color: #17BF63; font-weight: bold');      this.isOnline = true;      this.processQueuedRequests();    });    window.addEventListener('offline', () => {      console.log('%c🔴 Connection lost - entering offline mode', 'color: #DC3545; font-weight: bold');      this.isOnline = false;    });    if ('connection' in navigator) {      const connection = (navigator as any).connection;      if (connection) {        this.updateConnectionMetrics(connection);        connection.addEventListener('change', () => {          this.updateConnectionMetrics(connection);          console.log('%c📊 Connection quality updated:', 'color: #1DA1F2; font-weight: bold', {            effectiveType: this.connectionMetrics.effectiveType,            downlink: this.connectionMetrics.downlink,            rtt: this.connectionMetrics.rtt          });        });      }    }    this.cleanupIntervalId = setInterval(() => this.cleanupQueuedRequests(), 60000);     console.log('%c  ✅ Network monitoring initialized', 'color: #17BF63; font-weight: bold');    console.log('%c  Initial status:', 'color: #657786', {      online: this.isOnline,      effectiveType: this.connectionMetrics.effectiveType    });  }  /**   * Update connection quality metrics   */  private static updateConnectionMetrics(connection: any): void {    this.connectionMetrics = {      rtt: connection.rtt || 0,      downlink: connection.downlink || 0,      effectiveType: connection.effectiveType || '4g'    };  }  /**   * Get adaptive timeout based on connection quality   */  private static getAdaptiveTimeout(): number {    const baseTimeout = 30000;     switch (this.connectionMetrics.effectiveType) {      case 'slow-2g':        return baseTimeout * 3;       case '2g':        return baseTimeout * 2;       case '3g':        return baseTimeout * 1.5;       case '4g':      default:        return baseTimeout;     }  }  /**   * Queue request for when connection is restored   */  private static queueOfflineRequest(    request: ReplyGenerationRequest,     context: TwitterContext,     signal?: AbortSignal  ): Promise<ReplyGenerationResponse> {    return new Promise((resolve, reject) => {      this.cleanupQueuedRequests();      if (this.queuedRequests.length >= this.OFFLINE_QUEUE_MAX_SIZE) {        console.log('%c⚠️ Offline queue full - rejecting request', 'color: #FFA500; font-weight: bold');        reject(new Error('Too many requests queued. Please wait for connection to restore.'));        return;      }      this.queuedRequests.push({        request,        context,        signal,        resolve,        reject,        timestamp: Date.now()      });      console.log('%c📴 Request queued for offline processing', 'color: #FFA500; font-weight: bold',                  `Queue size: ${this.queuedRequests.length}`);      signal?.addEventListener('abort', () => {        const index = this.queuedRequests.findIndex(item =>           item.request === request && item.context === context        );        if (index >= 0) {          this.queuedRequests.splice(index, 1);          reject(new Error('Request was cancelled'));        }      });    });  }  /**   * Process queued requests when connection is restored   */  private static async processQueuedRequests(): Promise<void> {    if (this.queuedRequests.length === 0) return;    console.log('%c🔄 Processing queued requests:', 'color: #1DA1F2; font-weight: bold',                `${this.queuedRequests.length} requests`);    const requestsToProcess = [...this.queuedRequests];    this.queuedRequests = [];    for (const queuedItem of requestsToProcess) {      try {        if (queuedItem.signal?.aborted) {          queuedItem.reject(new Error('Request was cancelled'));          continue;        }        const age = Date.now() - queuedItem.timestamp;        if (age > this.OFFLINE_QUEUE_MAX_AGE) {          queuedItem.reject(new Error('Request expired while offline'));          continue;        }        const result = await this.executeActualRequest(          queuedItem.request,           queuedItem.context,           queuedItem.signal        );        queuedItem.resolve(result);      } catch (error) {        queuedItem.reject(error);      }    }    console.log('%c✅ All queued requests processed', 'color: #17BF63; font-weight: bold');  }  /**   * Clean up expired requests from queue   */  private static cleanupQueuedRequests(): void {    const now = Date.now();    const initialSize = this.queuedRequests.length;    this.queuedRequests = this.queuedRequests.filter(item => {      const age = now - item.timestamp;      const isExpired = age > this.OFFLINE_QUEUE_MAX_AGE;      const isCancelled = item.signal?.aborted;      if (isExpired || isCancelled) {        if (isExpired) {          item.reject(new Error('Request expired while offline'));        } else {          item.reject(new Error('Request was cancelled'));        }        return false;      }      return true;    });    const removed = initialSize - this.queuedRequests.length;    if (removed > 0) {      console.log('%c🧹 Cleaned up offline queue:', 'color: #657786',                  `Removed ${removed} expired/cancelled requests`);    }  }  /**   * Process successful API response (extracted for reuse)   */  private static async processSuccessfulResponse(    response: Response,     request: ReplyGenerationRequest,     context: TwitterContext  ): Promise<ReplyGenerationResponse> {    if (!response.ok) {      const errorText = await response.text();      console.error('OpenRouter API error:', response.status, errorText);      if (response.status === 401) {        return {          success: false,          error: 'Invalid API key. Get your key at openrouter.ai/keys'        };      }      if (response.status === 429) {        let retryAfter = '';        try {          const errorData = JSON.parse(errorText);          if (errorData.error?.metadata?.ratelimit_reset) {            const resetTime = new Date(errorData.error.metadata.ratelimit_reset * 1000);            const waitSeconds = Math.ceil((resetTime.getTime() - Date.now()) / 1000);            retryAfter = ` Try again in ${waitSeconds} seconds`;          }        } catch {}        return {          success: false,          error: `Rate limited.${retryAfter || ' Try again in a few seconds'}`        };      }      if (response.status === 402) {        return {          success: false,          error: 'Insufficient credits. Add credits at openrouter.ai/account'        };      }      if (response.status >= 500) {        return {          success: false,          error: 'OpenRouter service error. Try again in a moment'        };      }      return {        success: false,        error: `Request failed (${response.status}). Check your connection and try again`      };    }    const result: OpenRouterResponse = await response.json();    if (!result.choices || result.choices.length === 0) {      console.error('TweetCraft: No choices in API response:', result);      return {        success: false,        error: 'No response generated. Please try again.'      };    }    const reply = result.choices[0]?.message?.content?.trim();    if (!reply) {      if (result.choices[0]?.finish_reason === 'length' || (result.choices[0] as any)?.native_finish_reason === 'MAX_TOKENS') {        console.warn('%c⚠️ Response hit token limit', 'color: #FFAD1F; font-weight: bold; font-size: 14px');        console.warn('%c  Response may be incomplete', 'color: #657786');        const partialReply = result.choices[0]?.message?.content || '';        if (partialReply.length > 0) {          return {            success: true,            reply: partialReply.trim()          };        }      }      console.error('%c❌ Empty API Response', 'color: #E0245E; font-weight: bold; font-size: 14px');      console.error('%c  Details:', 'color: #657786', result.choices[0]);      return {        success: false,        error: 'Empty response generated. Please try again.'      };    }    console.log('%c✅ API Response Received', 'color: #17BF63; font-weight: bold; font-size: 14px');    console.log(`%c  Raw length: ${reply.length} chars`, 'color: #657786');    const cleanedReply = this.cleanupReply(reply);    console.log(`%c  Cleaned length: ${cleanedReply.length} chars`, 'color: #657786');    if (reply !== cleanedReply) {      console.log('%c  ⚠️ Meta-text removed during cleanup', 'color: #FFAD1F');    }    if (!cleanedReply) {      console.error('TweetCraft: Reply became empty after cleanup. Original:', reply);      return {        success: true,        reply: reply      };    }    const replyToUse = cleanedReply || reply;    if (context.tweetId && request.tone) {      CacheService.set(context.tweetId, request.tone, replyToUse);    }    const finalReply = URLCleaner.cleanTextURLs(replyToUse);    return {      success: true,      reply: finalReply    };  }  /**   * Get network resilience status and metrics   */  static getNetworkStatus() {    return {      isOnline: this.isOnline,      connectionMetrics: { ...this.connectionMetrics },      queuedRequestsCount: this.queuedRequests.length,      adaptiveTimeout: this.getAdaptiveTimeout()    };  }  /**   * Cleanup static resources (intervals, timers, caches)   */  static cleanup(): void {    if (this.cleanupIntervalId) {      clearInterval(this.cleanupIntervalId);      this.cleanupIntervalId = null;      console.log('%c🧹 OpenRouterService: Cleanup interval cleared', 'color: #FFA500');    }    if (this.batchTimer) {      clearTimeout(this.batchTimer);      this.batchTimer = null;    }    this.requestCache.clear();    this.queuedRequests = [];    console.log('%c✅ OpenRouterService: All resources cleaned up', 'color: #17BF63');  }}
```

services\promptArchitecture.ts
```ts
/** * Prompt Architecture System for TweetCraft * Defines the strategic structure for all LLM prompts across all input sources */export interface PromptConfiguration {  systemPrompt: string;  temperature: number;  contextMode: 'none' | 'single' | 'thread';  replyLength?: string;  tabType: 'personas' | 'all' | 'smart' | 'favorites' | 'image_gen' | 'custom';  personaConfig?: {    personality: string;    vocabulary: string;    rhetoricMove: string;    lengthPacing: string;    systemPrompt: string;   };  allTabConfig?: {    personality: string;    vocabulary: string;    rhetoric: string;    lengthPacing: string;  };  customConfig?: {    style: string;    tone: string;    length: string;    temperature?: number;   };  context?: {    tweetText?: string;    authorHandle?: string;    threadContext?: Array<{ author: string; text: string }>;    images?: string[];  };}/** * PromptArchitecture handles strategic prompt construction for all 6 tabs in TweetCraft. *  * TAB DEPENDENCIES AND CONFIGURATIONS: *  * 1. PERSONAS TAB: *    - Requires: personaConfig with personality, vocabulary, rhetoricMove, lengthPacing, and systemPrompt *    - Uses: System-wide prompt + persona's custom prompt + 4-part instructions *  * 2. ALL TAB: *    - Requires: allTabConfig with personality, vocabulary, rhetoric, and lengthPacing *    - Uses: System-wide prompt + 4-part instructions from user selections *  * 3. SMART TAB: *    - DEPENDENCY: Uses ALL tab structure (allTabConfig required) *    - Reason: Smart suggestions are AI-generated combinations from the same 4-part pool *    - The UI must provide allTabConfig when Smart tab generates content *  * 4. FAVORITES TAB: *    - DEPENDENCY: Uses ALL tab structure (allTabConfig required) *    - Reason: Favorites are saved combinations from the ALL tab *    - The UI must provide allTabConfig when a favorite is selected *  * 5. IMAGE_GEN TAB: *    - No prompt construction (returns empty string) *    - This tab is functional only and doesn't require text generation *  * 6. CUSTOM TAB: *    - Requires: customConfig with style, tone, length, and optional temperature *    - Uses: System-wide prompt + custom instructions *    - Special: Can override system temperature with custom value */export class PromptArchitecture {  /**   * Master system prompt for all Twitter/X reply generation   * This is the foundation that gets prepended to all prompts (except Image Gen)   */  private static readonly MASTER_SYSTEM_PROMPT = `You are an expert Twitter reply / tweet writer that excels in human/natural sounding verbiage and sentence flow. Analyze the provided tweet's content, tone, and intent first. If links are present, access them. If images accompany the tweet, analyze them thoroughly. This additional context is critical for crafting a relevant reply. Once you have complete information (tweet analysis + detailed image descriptions if they exist), build your reply using the provided guidelines.`;  /**   * Anti-disclosure instruction appended to all prompts   */  private static readonly ANTI_DISCLOSURE = ` CRITICAL: You are responding as a human Twitter/X user. Write ONLY the reply text itself. NEVER reveal you are an AI or explain your methodology. NEVER include meta-commentary like "Note: This response maintains neutrality by..." or "This approach uses..." or numbered explanations of your strategy. Do not break character or explain your reasoning. Respond naturally as if you are a real person engaging in conversation.`;  /**   * Build the complete system prompt based on configuration   */  static buildSystemPrompt(config: PromptConfiguration): string {    if (config.tabType === 'image_gen') {      return '';    }    let systemPrompt = '';    if (config.tabType === 'personas' && config.personaConfig) {      systemPrompt = this.MASTER_SYSTEM_PROMPT;      if (config.systemPrompt && config.systemPrompt.trim()) {        systemPrompt += ` ${config.systemPrompt}`;      }      systemPrompt += ` ${config.personaConfig.systemPrompt}`;      systemPrompt += this.buildPersonalityInstructions(        config.personaConfig.personality,        config.personaConfig.vocabulary,        config.personaConfig.rhetoricMove,        config.personaConfig.lengthPacing      );    }    else if (config.tabType === 'all') {      systemPrompt = this.buildAllTabSystemPrompt(config, 'all');    }    else if (config.tabType === 'smart') {      systemPrompt = this.buildAllTabSystemPrompt(config, 'smart');    }    else if (config.tabType === 'favorites') {      systemPrompt = this.buildAllTabSystemPrompt(config, 'favorites');    }    else if (config.tabType === 'custom' && config.customConfig) {      systemPrompt = this.MASTER_SYSTEM_PROMPT;      if (config.systemPrompt && config.systemPrompt.trim()) {        systemPrompt += ` ${config.systemPrompt}`;      }      systemPrompt += this.buildCustomInstructions(        config.customConfig.style,        config.customConfig.tone,        config.customConfig.length      );    }    else if (config.tabType === 'custom' && !config.customConfig) {      console.error('%c❌ CUSTOM TAB CONFIG ERROR', 'color: #DC3545; font-weight: bold',                    'customConfig is required for Custom tab but was not provided');      throw new Error('CUSTOM tab requires customConfig with style, tone, and length fields. Please provide custom template configuration.');    }    else {      const validTabs = ['personas', 'all', 'smart', 'favorites', 'custom', 'image_gen'];      console.error('%c❌ INVALID TAB TYPE', 'color: #DC3545; font-weight: bold',                    `Tab type "${config.tabType}" is not supported`);      console.error('%c  Valid tab types:', 'color: #657786', validTabs.join(', '));      throw new Error(`Invalid tab type "${config.tabType}". Valid types are: ${validTabs.join(', ')}. Please check your tab selection.`);    }    if (config.contextMode && config.contextMode !== 'none' && config.context?.tweetText) {      systemPrompt += ' Analyze the original tweet and write a contextually relevant reply.';    }    systemPrompt += ' Keep the reply natural and conversational. Do not use hashtags unless essential.';    systemPrompt += this.ANTI_DISCLOSURE;    return systemPrompt;  }  /**   * Build system prompt for tabs using ALL tab structure (ALL, SMART, FAVORITES)   * This helper reduces code duplication for the three tabs that share the same prompt structure   */  private static buildAllTabSystemPrompt(    config: PromptConfiguration,    tabName: string  ): string {    if (!config.allTabConfig) {      console.error(`%c❌ ${tabName.toUpperCase()} TAB CONFIG ERROR`, 'color: #DC3545; font-weight: bold',                    'allTabConfig is required but was not provided');      console.error('%c  Expected structure:', 'color: #657786',                    '{ personality, vocabulary, rhetoric, lengthPacing }');      const errorMessage = tabName === 'smart'         ? 'SMART tab requires allTabConfig with personality, vocabulary, rhetoric, and lengthPacing. Please select from the ALL tab or use a different tab.'        : tabName === 'favorites'        ? 'FAVORITES tab requires allTabConfig from a saved favorite selection. The favorite data may be corrupted. Please select a different favorite or use the ALL tab.'        : 'ALL tab requires allTabConfig with personality, vocabulary, rhetoric, and lengthPacing.';      throw new Error(errorMessage);    }    let systemPrompt = this.MASTER_SYSTEM_PROMPT;    if (config.systemPrompt && config.systemPrompt.trim()) {      systemPrompt += ` ${config.systemPrompt}`;    }    systemPrompt += this.buildPersonalityInstructions(      config.allTabConfig.personality,      config.allTabConfig.vocabulary,      config.allTabConfig.rhetoric,      config.allTabConfig.lengthPacing    );    return systemPrompt;  }  /**   * Build personality instructions from 4-part selection   */  private static buildPersonalityInstructions(    personality?: string,    vocabulary?: string,    rhetoric?: string,    lengthPacing?: string  ): string {    let instructions = '';    if (personality && personality.trim()) {      instructions += ` Personality: ${personality.trim()}.`;    }    if (vocabulary && vocabulary.trim()) {      instructions += ` Vocabulary style: ${vocabulary.trim()}.`;    }    if (rhetoric && rhetoric.trim()) {      instructions += ` Rhetorical approach: ${rhetoric.trim()}.`;    }    if (lengthPacing && lengthPacing.trim()) {      instructions += ` Length and pacing: ${lengthPacing.trim()}.`;    }    return instructions;  }  /**   * Build custom template instructions   */  private static buildCustomInstructions(    style: string,    tone: string,    length: string  ): string {    let instructions = '';    if (style && typeof style === 'string' && style.trim()) {      instructions += ` Writing style: ${style.trim()}.`;    }    if (tone && typeof tone === 'string' && tone.trim()) {      instructions += ` Tone of voice: ${tone.trim()}.`;    }    if (length && typeof length === 'string' && length.trim()) {      instructions += ` Length instructions: ${length.trim()}.`;    }    return instructions;  }  /**   * Get the appropriate temperature for the request   */  static getTemperature(config: PromptConfiguration): number {    let temperature: number;    if (config.tabType === 'custom' && config.customConfig?.temperature !== undefined) {      temperature = config.customConfig.temperature;    } else {      temperature = config.temperature || 0.7;    }    if (temperature < 0.1) {      console.warn(`Temperature ${temperature} is below minimum, clamping to 0.1`);      temperature = 0.1;    } else if (temperature > 1.0) {      console.warn(`Temperature ${temperature} is above maximum, clamping to 1.0`);      temperature = 1.0;    }    return temperature;  }  /**   * Build the user prompt with context   */  static buildUserPrompt(config: PromptConfiguration): string {    let userPrompt = '';    if (config.context && config.contextMode) {      if (config.contextMode === 'thread' && config.context.threadContext && config.context.threadContext.length > 0) {        userPrompt = 'Here is a Twitter conversation thread:\n\n';        config.context.threadContext.forEach(tweet => {          userPrompt += `${tweet.author}: ${tweet.text}\n`;        });        if (config.context.authorHandle && config.context.tweetText) {          userPrompt += `@${config.context.authorHandle}: ${config.context.tweetText}\n\n`;        } else if (config.context.tweetText) {          userPrompt += `Latest tweet: ${config.context.tweetText}\n\n`;        }        userPrompt += 'Write a contextually relevant reply that continues this conversation naturally.';      }      else if (config.contextMode === 'single' && config.context.tweetText) {        userPrompt = `Write a reply to this tweet: "${config.context.tweetText}"`;      }      else if (config.contextMode === 'none') {        userPrompt = 'Write an engaging tweet reply.';      }    } else {      userPrompt = 'Write an engaging tweet.';    }    if (config.context?.images && config.context.images.length > 0) {      userPrompt += '\n\n[Visual Context] The tweet contains the following images:';      config.context.images.forEach((imageUrl, index) => {        userPrompt += `\n- Image ${index + 1}: ${imageUrl}`;      });      userPrompt += '\n\nConsider the visual content when crafting your reply.';      console.log('%c🖼️ IMAGE CONTEXT INCLUDED', 'color: #17BF63; font-weight: bold',                   `${config.context.images.length} image(s) added to prompt`);    }    return userPrompt;  }  /**   * Log the complete prompt architecture for debugging   */  static logPromptArchitecture(config: PromptConfiguration, systemPrompt: string, userPrompt: string, temperature: number): void {    console.log('%c🏗️ PROMPT ARCHITECTURE', 'color: #1DA1F2; font-weight: bold; font-size: 16px');    console.log('%c════════════════════════════════════════', 'color: #2E3236');    console.log('%c📑 Tab Type:', 'color: #794BC4; font-weight: bold', config.tabType.toUpperCase());    console.log('%c⚙️ System-Wide Settings:', 'color: #17BF63; font-weight: bold');    console.log('%c  System Prompt:', 'color: #657786', config.systemPrompt || '(none)');    console.log('%c  Temperature:', 'color: #657786', temperature);    console.log('%c  Context Mode:', 'color: #657786', config.contextMode || 'none');    if (config.personaConfig) {      console.log('%c🎭 Persona Configuration:', 'color: #E1AD01; font-weight: bold');      console.log('%c  Personality:', 'color: #657786', config.personaConfig.personality);      console.log('%c  Vocabulary:', 'color: #657786', config.personaConfig.vocabulary);      console.log('%c  Rhetoric:', 'color: #657786', config.personaConfig.rhetoricMove);      console.log('%c  Length:', 'color: #657786', config.personaConfig.lengthPacing);    }    if (config.allTabConfig) {      console.log('%c🎨 All Tab Configuration:', 'color: #E1AD01; font-weight: bold');      console.log('%c  Personality:', 'color: #657786', config.allTabConfig.personality);      console.log('%c  Vocabulary:', 'color: #657786', config.allTabConfig.vocabulary);      console.log('%c  Rhetoric:', 'color: #657786', config.allTabConfig.rhetoric);      console.log('%c  Length:', 'color: #657786', config.allTabConfig.lengthPacing);    }    if (config.customConfig) {      console.log('%c✏️ Custom Configuration:', 'color: #E1AD01; font-weight: bold');      console.log('%c  Style:', 'color: #657786', config.customConfig.style);      console.log('%c  Tone:', 'color: #657786', config.customConfig.tone);      console.log('%c  Length:', 'color: #657786', config.customConfig.length);      if (config.customConfig.temperature !== undefined) {        console.log('%c  Custom Temperature:', 'color: #FF6B6B', config.customConfig.temperature);      }    }    console.log('%c📋 FINAL PROMPTS:', 'color: #1DA1F2; font-weight: bold');    console.log('%c  System Prompt Length:', 'color: #657786', `${systemPrompt.length} characters`);    console.log('%c  User Prompt Length:', 'color: #657786', `${userPrompt.length} characters`);    const truncatedSystem = systemPrompt.length > 200       ? systemPrompt.substring(0, 200) + '...'       : systemPrompt;    console.log('%c  System:', 'color: #8899A6', truncatedSystem);    const truncatedUser = userPrompt.length > 200       ? userPrompt.substring(0, 200) + '...'       : userPrompt;    console.log('%c  User:', 'color: #8899A6', truncatedUser);    console.log('%c════════════════════════════════════════', 'color: #2E3236');  }}
```

services\promptBuilder.ts
```ts
/** * Unified Prompt Builder for 4-Part Tweet Generation * Combines: Personality + Vocabulary + Rhetoric + Length & Pacing = Perfect Tweet */import { ReplyGenerationRequest } from '@/types';import { getPersonality } from '@/config/personalities';import { getVocabularyPrompt } from '@/config/vocabulary';import { getRhetoricalMove } from '@/config/rhetoric';import { getLengthPacingPrompt, getCharacterGuidance } from '@/config/lengthPacing';export interface PromptComponents {  personality: string;  vocabulary: string;  rhetoric: string;  lengthPacing: string;  combined: string;}/** * Build the complete 4-part prompt structure * Each part is clearly separated and logged for tracking */export function buildFourPartPrompt(request: ReplyGenerationRequest): PromptComponents {  console.log('%c🎯 BUILDING 4-PART PROMPT STRUCTURE', 'color: #FF6B6B; font-weight: bold; font-size: 16px');  console.log('%c════════════════════════════════════════', 'color: #2E3236');  const personalityId = request.personality || 'neutral';  const personality = getPersonality(personalityId);  const personalityPrompt = personality?.systemPrompt || 'Respond in a neutral, balanced tone.';  console.log('%c📍 PART 1: PERSONALITY (Who is talking)', 'color: #1DA1F2; font-weight: bold');  console.log('%c  Selected:', 'color: #657786', personalityId);  console.log('%c  Label:', 'color: #657786', personality?.label || 'Unknown');  console.log('%c  Prompt:', 'color: #17BF63', personalityPrompt.substring(0, 100) + '...');  const vocabularyId = request.vocabulary || 'plain_english';  const vocabularyPrompt = getVocabularyPrompt(vocabularyId);  console.log('%c📍 PART 2: VOCABULARY (How it\'s written)', 'color: #9146FF; font-weight: bold');  console.log('%c  Selected:', 'color: #657786', vocabularyId);  console.log('%c  Prompt:', 'color: #17BF63', vocabularyPrompt.substring(0, 100) + '...');  const rhetoricId = request.rhetoric || 'agree_build';  const rhetoric = getRhetoricalMove(rhetoricId);  const rhetoricPrompt = rhetoric?.systemPrompt || 'Generate a collaborative reply.';  console.log('%c📍 PART 3: RHETORIC (Approach to topic)', 'color: #FF9F1C; font-weight: bold');  console.log('%c  Selected:', 'color: #657786', rhetoricId);  console.log('%c  Label:', 'color: #657786', rhetoric?.name || 'Unknown');  console.log('%c  Prompt:', 'color: #17BF63', rhetoricPrompt.substring(0, 100) + '...');  const lengthPacingId = request.lengthPacing || 'conversational_clause';  const lengthPacingPrompt = getLengthPacingPrompt(lengthPacingId);  const characterGuidance = getCharacterGuidance(lengthPacingId);  console.log('%c📍 PART 4: LENGTH & PACING (How long/short)', 'color: #E91E63; font-weight: bold');  console.log('%c  Selected:', 'color: #657786', lengthPacingId);  console.log('%c  Prompt:', 'color: #17BF63', lengthPacingPrompt.substring(0, 100) + '...');  if (characterGuidance) {    console.log('%c  Character Guidance:', 'color: #657786', characterGuidance);  }  const combinedPrompt = buildCombinedPrompt({    personality: personalityPrompt,    vocabulary: vocabularyPrompt,    rhetoric: rhetoricPrompt,    lengthPacing: lengthPacingPrompt  });  console.log('%c✨ FINAL COMBINED PROMPT', 'color: #FFD700; font-weight: bold; font-size: 14px');  console.log('%c  Total Length:', 'color: #657786', combinedPrompt.length + ' characters');  console.log('%c  Structure:', 'color: #657786', 'Personality → Vocabulary → Rhetoric → Length & Pacing');  console.log('%c════════════════════════════════════════', 'color: #2E3236');  return {    personality: personalityPrompt,    vocabulary: vocabularyPrompt,    rhetoric: rhetoricPrompt,    lengthPacing: lengthPacingPrompt,    combined: combinedPrompt  };}/** * Combine the 4 parts into a single, coherent system prompt */function buildCombinedPrompt(components: {  personality: string;  vocabulary: string;  rhetoric: string;  lengthPacing: string;}): string {  const sections = [    '=== PERSONALITY (Who is talking) ===',    components.personality,    '',    '=== VOCABULARY (How it\'s written) ===',    components.vocabulary,    '',    '=== RHETORIC (Approach to topic) ===',    components.rhetoric,    '',    '=== LENGTH & PACING (How long/short) ===',    components.lengthPacing,    '',    '=== INSTRUCTION ===',    'Combine ALL FOUR elements above to create the perfect tweet response. Each element is equally important and must be reflected in your response.'  ];  return sections.join('\n');}/** * Log the prompt components for debugging */export function logPromptComponents(components: PromptComponents): void {  console.group('%c🔍 PROMPT COMPONENTS BREAKDOWN', 'color: #FF6B6B; font-weight: bold');  console.log('%c1️⃣ PERSONALITY', 'color: #1DA1F2; font-weight: bold');  console.log(components.personality);  console.log('%c2️⃣ VOCABULARY', 'color: #9146FF; font-weight: bold');  console.log(components.vocabulary);  console.log('%c3️⃣ RHETORIC', 'color: #FF9F1C; font-weight: bold');  console.log(components.rhetoric);  console.log('%c4️⃣ LENGTH & PACING', 'color: #E91E63; font-weight: bold');  console.log(components.lengthPacing);  console.log('%c🎯 COMBINED PROMPT', 'color: #FFD700; font-weight: bold');  console.log(components.combined);  console.groupEnd();}/** * Validate that all required components are present */export function validatePromptComponents(request: ReplyGenerationRequest): {  isValid: boolean;  missing: string[];} {  const missing: string[] = [];  if (!request.personality) missing.push('personality');  if (!request.vocabulary) missing.push('vocabulary');  if (!request.rhetoric) missing.push('rhetoric');  if (!request.lengthPacing) missing.push('lengthPacing');  if (missing.length > 0) {    console.warn('%c⚠️ Missing prompt components:', 'color: #FFA500; font-weight: bold', missing);  }  return {    isValid: missing.length === 0,    missing  };}
```

services\promptCache.ts
```ts
/** * Prompt Caching Service for TweetCraft * LRU cache for combined prompts and API responses */interface CacheEntry {  key: string;  value: any;  timestamp: number;  accessCount: number;  size: number;}interface CacheStats {  hits: number;  misses: number;  evictions: number;  currentSize: number;  maxSize: number;  entryCount: number;}export class PromptCache {  private cache = new Map<string, CacheEntry>();  private accessOrder: string[] = [];  private stats: CacheStats = {    hits: 0,    misses: 0,    evictions: 0,    currentSize: 0,    maxSize: 100,    entryCount: 0  };  private readonly MAX_ENTRIES = 100;  private readonly MAX_AGE_MS = 3600000;   private readonly MAX_SIZE_BYTES = 5 * 1024 * 1024;   constructor() {    this.loadFromSession();    console.log('%c💾 PromptCache initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Generate cache key from parameters   */  private generateKey(params: {    templateId?: string;    toneId?: string;    context?: string;    customPrompt?: string;  }): string {    const parts = [      params.templateId || '',      params.toneId || '',      params.context ? this.hashString(params.context) : '',      params.customPrompt ? this.hashString(params.customPrompt) : ''    ].filter(Boolean);    return parts.join(':');  }  /**   * Simple hash function for strings   */  private hashString(str: string): string {    let hash = 0;    for (let i = 0; i < str.length; i++) {      const char = str.charCodeAt(i);      hash = ((hash << 5) - hash) + char;      hash = hash & hash;     }    return hash.toString(36);  }  /**   * Calculate size of value in bytes (approximate)   */  private calculateSize(value: any): number {    const str = JSON.stringify(value);    return new Blob([str]).size;  }  /**   * Get cached prompt or response   */  get(params: {    templateId?: string;    toneId?: string;    context?: string;    customPrompt?: string;  }): any | null {    const key = this.generateKey(params);    const entry = this.cache.get(key);    if (!entry) {      this.stats.misses++;      console.log('%c💾 Cache miss', 'color: #FFA500', key);      return null;    }    if (Date.now() - entry.timestamp > this.MAX_AGE_MS) {      this.delete(key);      this.stats.misses++;      console.log('%c💾 Cache expired', 'color: #FFA500', key);      return null;    }    entry.accessCount++;    this.updateAccessOrder(key);    this.stats.hits++;    console.log('%c💾 Cache hit', 'color: #17BF63', key, `(${entry.accessCount} accesses)`);    return entry.value;  }  /**   * Set cached value   */  set(params: {    templateId?: string;    toneId?: string;    context?: string;    customPrompt?: string;  }, value: any): void {    const key = this.generateKey(params);    const size = this.calculateSize(value);    if (size > this.MAX_SIZE_BYTES / 2) {      console.warn('%c💾 Entry too large to cache', 'color: #DC3545', key, size);      return;    }    while (this.cache.size >= this.MAX_ENTRIES ||            this.stats.currentSize + size > this.MAX_SIZE_BYTES) {      this.evictLRU();    }    const entry: CacheEntry = {      key,      value,      timestamp: Date.now(),      accessCount: 1,      size    };    this.cache.set(key, entry);    this.accessOrder.push(key);    this.stats.currentSize += size;    this.stats.entryCount = this.cache.size;    console.log('%c💾 Cached', 'color: #1DA1F2', key, `(${size} bytes)`);    this.saveToSession();  }  /**   * Get combined prompt from cache   */  getCombinedPrompt(templateId: string, toneId: string): string | null {    return this.get({ templateId, toneId });  }  /**   * Set combined prompt in cache   */  setCombinedPrompt(templateId: string, toneId: string, prompt: string): void {    this.set({ templateId, toneId }, prompt);  }  /**   * Get API response from cache   */  getApiResponse(params: {    templateId?: string;    toneId?: string;    context?: string;  }): string | null {    const key = `api:${this.generateKey(params)}`;    const entry = this.cache.get(key);    if (entry) {      this.stats.hits++;      console.log('%c💾 API response cache hit', 'color: #17BF63');      return entry.value;    }    this.stats.misses++;    return null;  }  /**   * Set API response in cache   */  setApiResponse(params: {    templateId?: string;    toneId?: string;    context?: string;  }, response: string): void {    const key = `api:${this.generateKey(params)}`;    this.set({ customPrompt: key }, response);  }  /**   * Update access order for LRU   */  private updateAccessOrder(key: string): void {    const index = this.accessOrder.indexOf(key);    if (index > -1) {      this.accessOrder.splice(index, 1);    }    this.accessOrder.push(key);  }  /**   * Evict least recently used entry   */  private evictLRU(): void {    if (this.accessOrder.length === 0) return;    const keyToEvict = this.accessOrder.shift()!;    const entry = this.cache.get(keyToEvict);    if (entry) {      this.stats.currentSize -= entry.size;      this.cache.delete(keyToEvict);      this.stats.evictions++;      this.stats.entryCount = this.cache.size;      console.log('%c💾 Evicted LRU', 'color: #FFA500', keyToEvict);    }  }  /**   * Delete specific entry   */  delete(key: string): boolean {    const entry = this.cache.get(key);    if (entry) {      this.stats.currentSize -= entry.size;      this.cache.delete(key);      const index = this.accessOrder.indexOf(key);      if (index > -1) {        this.accessOrder.splice(index, 1);      }      this.stats.entryCount = this.cache.size;      return true;    }    return false;  }  /**   * Clear entire cache   */  clear(): void {    this.cache.clear();    this.accessOrder = [];    this.stats.currentSize = 0;    this.stats.entryCount = 0;    console.log('%c💾 Cache cleared', 'color: #FFA500');    this.clearSession();  }  /**   * Get cache statistics   */  getStats(): CacheStats {    return { ...this.stats };  }  /**   * Get cache hit rate   */  getHitRate(): number {    const total = this.stats.hits + this.stats.misses;    return total > 0 ? (this.stats.hits / total) * 100 : 0;  }  /**   * Save cache to session storage   */  private saveToSession(): void {    try {      const entriesToSave = Array.from(this.cache.entries())        .sort((a, b) => b[1].timestamp - a[1].timestamp)        .slice(0, 20)        .reduce((acc, [key, entry]) => {          acc[key] = {            value: entry.value,            timestamp: entry.timestamp          };          return acc;        }, {} as any);      sessionStorage.setItem('tweetcraft_prompt_cache', JSON.stringify(entriesToSave));    } catch (error) {      console.warn('Failed to save cache to session:', error);    }  }  /**   * Load cache from session storage   */  private loadFromSession(): void {    try {      const saved = sessionStorage.getItem('tweetcraft_prompt_cache');      if (saved) {        const entries = JSON.parse(saved);        let loadedCount = 0;        for (const [key, data] of Object.entries(entries as any)) {          const entry = data as any;          if (Date.now() - entry.timestamp < this.MAX_AGE_MS) {            const size = this.calculateSize(entry.value);            this.cache.set(key, {              key,              value: entry.value,              timestamp: entry.timestamp,              accessCount: 0,              size            });            this.accessOrder.push(key);            this.stats.currentSize += size;            loadedCount++;          }        }        this.stats.entryCount = this.cache.size;        console.log(`%c💾 Loaded ${loadedCount} entries from session`, 'color: #1DA1F2');      }    } catch (error) {      console.warn('Failed to load cache from session:', error);    }  }  /**   * Clear session storage   */  private clearSession(): void {    try {      sessionStorage.removeItem('tweetcraft_prompt_cache');    } catch (error) {      console.warn('Failed to clear session cache:', error);    }  }  /**   * Preload commonly used combinations   */  async preloadCommon(templateIds: string[], toneIds: string[]): Promise<void> {    console.log('%c💾 Preloading common combinations', 'color: #1DA1F2');    for (const templateId of templateIds) {      for (const toneId of toneIds) {        if (!this.getCombinedPrompt(templateId, toneId)) {          console.log(`%c  Marked for preload: ${templateId}:${toneId}`, 'color: #657786');        }      }    }  }  /**   * Debug: Print cache contents   */  debug(): void {    console.group('%c💾 PromptCache Debug', 'color: #1DA1F2; font-weight: bold');    console.log('Stats:', this.getStats());    console.log('Hit Rate:', `${this.getHitRate().toFixed(2)}%`);    console.log('Entries:', this.cache.size);    console.log('Size:', `${(this.stats.currentSize / 1024).toFixed(2)} KB`);    console.group('Contents:');    this.cache.forEach((entry, key) => {      console.log(`${key}: ${entry.accessCount} accesses, ${entry.size} bytes, age: ${Math.floor((Date.now() - entry.timestamp) / 1000)}s`);    });    console.groupEnd();    console.groupEnd();  }}export const promptCache = new PromptCache();
```

services\requestOptimizer.ts
```ts
/** * API Request Optimizer for TweetCraft * Implements request deduplication, intelligent batching, and connection-aware timeouts */import { debug, logAPI, logPerf } from '@/utils/debugConfig';interface PendingRequest {  key: string;  promise: Promise<any>;  timestamp: number;  abortController?: AbortController;}interface BatchedRequest {  requests: Array<{    id: string;    params: any;    resolve: (value: any) => void;    reject: (error: any) => void;  }>;  timer?: ReturnType<typeof setTimeout>;  timestamp: number;}interface RequestMetrics {  totalRequests: number;  deduplicatedRequests: number;  batchedRequests: number;  averageResponseTime: number;  cacheHits: number;  cacheMisses: number;}export class RequestOptimizer {  private pendingRequests = new Map<string, PendingRequest>();  private responseCache = new Map<string, { data: any; timestamp: number }>();  private batchQueue = new Map<string, BatchedRequest>();  private readonly DEDUP_WINDOW_MS = 30000;   private readonly BATCH_WINDOW_MS = 200;   private readonly CACHE_TTL_MS = 60000;   private readonly MAX_BATCH_SIZE = 10;  private metrics: RequestMetrics = {    totalRequests: 0,    deduplicatedRequests: 0,    batchedRequests: 0,    averageResponseTime: 0,    cacheHits: 0,    cacheMisses: 0  };  private responseTimes: number[] = [];  private readonly MAX_RESPONSE_TIME_SAMPLES = 100;  private cleanupTimer?: ReturnType<typeof setInterval>;  constructor() {    this.startCacheCleanup();    logAPI('%c🚀 Request Optimizer initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Cleanup resources when service is destroyed   */  destroy(): void {    if (this.cleanupTimer) {      clearInterval(this.cleanupTimer);      this.cleanupTimer = undefined;    }    this.batchQueue.forEach(batch => {      if (batch.timer) {        clearTimeout(batch.timer);      }    });    this.pendingRequests.forEach(request => {      if (request.abortController) {        request.abortController.abort();      }    });    this.pendingRequests.clear();    this.responseCache.clear();    this.batchQueue.clear();    console.log('%c🧹 Request Optimizer destroyed', 'color: #FFA500');  }  /**   * Generate cache key from request parameters   */  private generateKey(endpoint: string, params: any): string {    const sortedParams = this.sortObjectKeys(params);    return `${endpoint}:${JSON.stringify(sortedParams)}`;  }  /**   * Sort object keys for consistent cache key generation   */  private sortObjectKeys(obj: any): any {    if (typeof obj !== 'object' || obj === null) return obj;    if (Array.isArray(obj)) return obj.map(item => this.sortObjectKeys(item));    return Object.keys(obj)      .sort()      .reduce((sorted: any, key) => {        sorted[key] = this.sortObjectKeys(obj[key]);        return sorted;      }, {});  }  /**   * Check if request is already pending (deduplication)   */  private checkPendingRequest(key: string): PendingRequest | null {    const pending = this.pendingRequests.get(key);    if (pending) {      const age = Date.now() - pending.timestamp;      if (age < this.DEDUP_WINDOW_MS) {        this.metrics.deduplicatedRequests++;        logAPI('%c🔄 Request deduplicated', 'color: #FFA500', key);        return pending;      }      this.pendingRequests.delete(key);    }    return null;  }  /**   * Check response cache   */  private checkCache(key: string): any | null {    const cached = this.responseCache.get(key);    if (cached) {      const age = Date.now() - cached.timestamp;      if (age < this.CACHE_TTL_MS) {        this.metrics.cacheHits++;        logAPI('%c💾 Cache hit', 'color: #17BF63', key);        return cached.data;      }      this.responseCache.delete(key);    }    this.metrics.cacheMisses++;    return null;  }  /**   * Execute request with deduplication   */  async executeWithDedup<T>(    endpoint: string,    params: any,    requestFn: () => Promise<T>  ): Promise<T> {    const key = this.generateKey(endpoint, params);    this.metrics.totalRequests++;    const cached = this.checkCache(key);    if (cached !== null) {      return cached;    }    const pending = this.checkPendingRequest(key);    if (pending) {      return pending.promise;    }    const abortController = new AbortController();    const startTime = Date.now();    const promise = requestFn()      .then(result => {        const responseTime = Date.now() - startTime;        this.trackResponseTime(responseTime);        this.responseCache.set(key, {          data: result,          timestamp: Date.now()        });        this.pendingRequests.delete(key);        logAPI('%c✅ Request completed', 'color: #17BF63', key, `${responseTime}ms`);        return result;      })      .catch(error => {        this.pendingRequests.delete(key);        logAPI('%c❌ Request failed', 'color: #DC3545', key, error);        throw error;      });    this.pendingRequests.set(key, {      key,      promise,      timestamp: Date.now(),      abortController    });    return promise;  }  /**   * Batch multiple requests   */  async batchRequest<T>(    batchKey: string,    requestId: string,    params: any,    batchProcessor: (requests: any[]) => Promise<Map<string, T>>  ): Promise<T> {    return new Promise((resolve, reject) => {      let batch = this.batchQueue.get(batchKey);      if (!batch) {        batch = {          requests: [],          timestamp: Date.now()        };        this.batchQueue.set(batchKey, batch);        batch.timer = setTimeout(() => {          this.processBatch(batchKey, batchProcessor);        }, this.BATCH_WINDOW_MS);      }      batch.requests.push({        id: requestId,        params,        resolve,        reject      });      if (batch.requests.length >= this.MAX_BATCH_SIZE) {        if (batch.timer) {          clearTimeout(batch.timer);        }        this.processBatch(batchKey, batchProcessor);      }      logAPI('%c📦 Request batched', 'color: #9146FF', batchKey, requestId);    });  }  /**   * Process a batch of requests   */  private async processBatch<T>(    batchKey: string,    batchProcessor: (requests: any[]) => Promise<Map<string, T>>  ): Promise<void> {    const batch = this.batchQueue.get(batchKey);    if (!batch || batch.requests.length === 0) return;    this.batchQueue.delete(batchKey);    const startTime = Date.now();    const requestCount = batch.requests.length;    try {      logAPI('%c🚀 Processing batch', 'color: #1DA1F2', batchKey, `${requestCount} requests`);      const results = await batchProcessor(batch.requests.map(r => ({        id: r.id,        params: r.params      })));      batch.requests.forEach(request => {        const result = results.get(request.id);        if (result !== undefined) {          request.resolve(result);        } else {          request.reject(new Error(`No result for request ${request.id}`));        }      });      this.metrics.batchedRequests += requestCount;      const responseTime = Date.now() - startTime;      this.trackResponseTime(responseTime);      logAPI('%c✅ Batch processed', 'color: #17BF63', batchKey, `${responseTime}ms`);    } catch (error) {      batch.requests.forEach(request => {        request.reject(error);      });      logAPI('%c❌ Batch failed', 'color: #DC3545', batchKey, error);    }  }  /**   * Get adaptive timeout based on connection quality   */  getAdaptiveTimeout(): number {    const connection = (navigator as any).connection ||                       (navigator as any).mozConnection ||                       (navigator as any).webkitConnection;    if (connection) {      const effectiveType = connection.effectiveType;      switch (effectiveType) {        case 'slow-2g':          return 90000;         case '2g':          return 60000;         case '3g':          return 45000;         case '4g':        default:          return 30000;       }    }    return 30000;  }  /**   * Track response time for metrics   */  private trackResponseTime(responseTime: number): void {    this.responseTimes.push(responseTime);    if (this.responseTimes.length > this.MAX_RESPONSE_TIME_SAMPLES) {      this.responseTimes.shift();    }    const sum = this.responseTimes.reduce((a, b) => a + b, 0);    this.metrics.averageResponseTime = Math.round(sum / this.responseTimes.length);  }  /**   * Clean up expired cache entries periodically   */  private startCacheCleanup(): void {    this.cleanupTimer = setInterval(() => {      const now = Date.now();      let cleaned = 0;      this.responseCache.forEach((entry, key) => {        if (now - entry.timestamp > this.CACHE_TTL_MS) {          this.responseCache.delete(key);          cleaned++;        }      });      this.pendingRequests.forEach((request, key) => {        if (now - request.timestamp > this.DEDUP_WINDOW_MS) {          this.pendingRequests.delete(key);          cleaned++;        }      });      if (cleaned > 0) {        logPerf('%c🧹 Cache cleanup', 'color: #657786', `${cleaned} entries removed`);      }    }, 60000);   }  /**   * Cancel pending request   */  cancelRequest(endpoint: string, params: any): void {    const key = this.generateKey(endpoint, params);    const pending = this.pendingRequests.get(key);    if (pending && pending.abortController) {      pending.abortController.abort();      this.pendingRequests.delete(key);      logAPI('%c🚫 Request cancelled', 'color: #FFA500', key);    }  }  /**   * Clear all caches   */  clearCache(): void {    this.responseCache.clear();    this.pendingRequests.clear();    this.batchQueue.clear();    logAPI('%c🧹 All caches cleared', 'color: #FFA500');  }  /**   * Get current metrics   */  getMetrics(): RequestMetrics {    return { ...this.metrics };  }  /**   * Reset metrics   */  resetMetrics(): void {    this.metrics = {      totalRequests: 0,      deduplicatedRequests: 0,      batchedRequests: 0,      averageResponseTime: 0,      cacheHits: 0,      cacheMisses: 0    };    this.responseTimes = [];  }  /**   * Get cache size info   */  getCacheInfo(): {    responseCacheSize: number;    pendingRequestsSize: number;    batchQueueSize: number;  } {    return {      responseCacheSize: this.responseCache.size,      pendingRequestsSize: this.pendingRequests.size,      batchQueueSize: this.batchQueue.size    };  }}export const requestOptimizer = new RequestOptimizer();
```

services\smartDefaults.ts
```ts
/** * Smart Defaults Service for TweetCraft * Manages intelligent selection defaults based on usage patterns */import { usageTracker } from './usageTracker';import { PERSONALITIES, getPersonality } from '@/config/personalities';import { getAllVocabularyStyles } from '@/config/vocabulary';import { getAllRhetoricalMoves } from '@/config/rhetoric';import { getAllLengthPacingStyles } from '@/config/lengthPacing';export interface SmartDefaults {  personality?: string;  vocabulary?: string;  rhetoric?: string;  lengthPacing?: string;  confidence: 'high' | 'medium' | 'low';  reason: string;}export interface LastUsedSelections {  personality?: string;  vocabulary?: string;  rhetoric?: string;  lengthPacing?: string;  timestamp: number;}export class SmartDefaultsService {  private readonly STORAGE_KEY = 'tweetcraft_smart_defaults';  private readonly LAST_USED_KEY = 'tweetcraft_last_selections';  private readonly MIN_USAGE_FOR_HIGH_CONFIDENCE = 5;  private readonly MIN_USAGE_FOR_MEDIUM_CONFIDENCE = 3;  /**   * Get smart defaults based on usage patterns   */  async getSmartDefaults(): Promise<SmartDefaults | null> {    const stats = usageTracker.getStats();    const topPersonalities = this.getTopUsed(stats.toneUsage);    const topTemplates = this.getTopUsed(stats.templateUsage);    if (topPersonalities.length > 0 || topTemplates.length > 0) {      const personality = topPersonalities[0];      const rhetoric = topTemplates[0];      const personalityCount = stats.toneUsage.get(personality) || 0;      const rhetoricCount = stats.templateUsage.get(rhetoric) || 0;      let confidence: 'high' | 'medium' | 'low' = 'low';      let reason = '';      if (personalityCount >= this.MIN_USAGE_FOR_HIGH_CONFIDENCE &&           rhetoricCount >= this.MIN_USAGE_FOR_HIGH_CONFIDENCE) {        confidence = 'high';        reason = `Your most used combination (${personalityCount + rhetoricCount} times)`;      } else if (personalityCount >= this.MIN_USAGE_FOR_MEDIUM_CONFIDENCE ||                  rhetoricCount >= this.MIN_USAGE_FOR_MEDIUM_CONFIDENCE) {        confidence = 'medium';        reason = `Based on your usage patterns`;      } else {        confidence = 'low';        reason = `Suggested based on limited data`;      }      return {        personality,        rhetoric,        vocabulary: 'plain_english',         lengthPacing: 'drive_by',         confidence,        reason      };    }    return {      personality: 'friendly',      vocabulary: 'plain_english',      rhetoric: 'agree_build',      lengthPacing: 'drive_by',      confidence: 'low',      reason: 'Default suggestions for new users'    };  }  /**   * Save last used selections for quick access   */  async saveLastUsed(selections: Omit<LastUsedSelections, 'timestamp'>): Promise<void> {    const lastUsed: LastUsedSelections = {      ...selections,      timestamp: Date.now()    };    try {      await chrome.storage.local.set({        [this.LAST_USED_KEY]: lastUsed      });      console.log('%c🎯 Last used selections saved', 'color: #1DA1F2', lastUsed);    } catch (error) {      console.error('Failed to save last used selections:', error);    }  }  /**   * Get last used selections   */  async getLastUsed(): Promise<LastUsedSelections | null> {    try {      const result = await chrome.storage.local.get([this.LAST_USED_KEY]);      const lastUsed = result[this.LAST_USED_KEY];      if (lastUsed) {        const isRecent = (Date.now() - lastUsed.timestamp) < (24 * 60 * 60 * 1000);        if (isRecent) {          console.log('%c🎯 Last used selections loaded', 'color: #17BF63', lastUsed);          return lastUsed;        }      }      return null;    } catch (error) {      console.error('Failed to load last used selections:', error);      return null;    }  }  /**   * Get quick generate options based on usage patterns   */  async getQuickOptions(): Promise<{    lastUsed?: LastUsedSelections;    smartDefaults?: SmartDefaults;    topCombinations: Array<{      personality: string;      rhetoric: string;      vocabulary?: string;      lengthPacing?: string;      count: number;      label: string;    }>;  }> {    const [lastUsed, smartDefaults] = await Promise.all([      this.getLastUsed(),      this.getSmartDefaults()    ]);    const stats = usageTracker.getStats();    const topCombinations = Array.from(stats.combinationUsage.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, 3)      .map(([combo, count]) => {        const [personality, rhetoric] = combo.split(':');        return {          personality,          rhetoric,          vocabulary: 'plain_english',           lengthPacing: 'drive_by',           count,          label: this.createCombinationLabel(personality, rhetoric)        };      });    return {      lastUsed: lastUsed || undefined,      smartDefaults: smartDefaults || undefined,      topCombinations    };  }  /**   * Check if certain sections can be hidden based on usage patterns   */  async getSectionVisibility(): Promise<{    vocabularyOptional: boolean;    lengthPacingOptional: boolean;  }> {    const stats = usageTracker.getStats();    const totalGenerations = stats.eventsByType['reply_generated'] || 0;    const plainEnglishUsage = this.countPatternUsage(stats, 'plain_english');    const driveByUsage = this.countPatternUsage(stats, 'drive_by');    return {      vocabularyOptional: totalGenerations > 10 && (plainEnglishUsage / totalGenerations) > 0.7,      lengthPacingOptional: totalGenerations > 10 && (driveByUsage / totalGenerations) > 0.7    };  }  /**   * Apply smart defaults to the UI   */  applySmartDefaults = async (    selector: any,     options: {       skipVocabulary?: boolean;       skipLengthPacing?: boolean;      useLastUsed?: boolean;    } = {}  ): Promise<void> => {    const { useLastUsed = false } = options;    let selections: Partial<LastUsedSelections> | null = null;    if (useLastUsed) {      selections = await this.getLastUsed();    }    if (!selections) {      const smartDefaults = await this.getSmartDefaults();      if (smartDefaults) {        selections = {          personality: smartDefaults.personality,          vocabulary: smartDefaults.vocabulary,          rhetoric: smartDefaults.rhetoric,          lengthPacing: smartDefaults.lengthPacing        };      }    }    if (selections) {      if (selections.personality && selector.setPersonality) {        selector.setPersonality(selections.personality);      }      if (selections.rhetoric && selector.setRhetoric) {        selector.setRhetoric(selections.rhetoric);      }      if (!options.skipVocabulary && selections.vocabulary && selector.setVocabulary) {        selector.setVocabulary(selections.vocabulary);      }      if (!options.skipLengthPacing && selections.lengthPacing && selector.setLengthPacing) {        selector.setLengthPacing(selections.lengthPacing);      }      console.log('%c🎯 Smart defaults applied', 'color: #1DA1F2; font-weight: bold', selections);    }  }  /**   * Helper to get top used items from usage map   */  private getTopUsed<T>(usageMap: Map<T, number>): T[] {    return Array.from(usageMap.entries())      .sort((a, b) => b[1] - a[1])      .map(([item]) => item);  }  /**   * Helper to create readable combination labels   */  private createCombinationLabel(personality: string, rhetoric: string): string {    const personalities = PERSONALITIES;    const rhetorics = getAllRhetoricalMoves();    const personalityObj = personalities.find((p: any) => p.id === personality);    const rhetoricObj = rhetorics.find((r: any) => r.id === rhetoric);    const personalityLabel = personalityObj ? personalityObj.label : personality;    const rhetoricLabel = rhetoricObj ? rhetoricObj.name : rhetoric;    return `${personalityLabel} • ${rhetoricLabel}`;  }  /**   * Helper to count pattern usage in stats   */  private countPatternUsage(stats: any, pattern: string): number {    return 0;  }}export const smartDefaults = new SmartDefaultsService();
```

services\storage.ts
```ts
import { AppConfig, DEFAULT_CONFIG } from '@/types';import { EncryptionService } from '@/utils/encryption';const STORAGE_KEYS = {  CONFIG: 'smartReply_config',  API_KEY: 'smartReply_apiKey',  LAST_TONE: 'smartReply_lastTone'} as const;export class StorageService {  static async getConfig(): Promise<Partial<AppConfig>> {    try {      const result = await chrome.storage.sync.get(STORAGE_KEYS.CONFIG);      return { ...DEFAULT_CONFIG, ...result[STORAGE_KEYS.CONFIG] };    } catch (error) {      console.error('Failed to get config from storage:', error);      return DEFAULT_CONFIG;    }  }  static async setConfig(config: Partial<AppConfig>): Promise<void> {    try {      await chrome.storage.sync.set({        [STORAGE_KEYS.CONFIG]: config      });    } catch (error) {      console.error('Failed to save config to storage:', error);      throw error;    }  }  static async getApiKey(): Promise<string | undefined> {    try {      const result = await chrome.storage.local.get(STORAGE_KEYS.API_KEY);      const storedValue = result[STORAGE_KEYS.API_KEY];      if (!storedValue) {        return undefined;      }      if (storedValue.startsWith('enc_')) {        const decrypted = await EncryptionService.decryptApiKey(storedValue);        console.log('%c🔓 API Key Decrypted', 'color: #17BF63', {           stored: storedValue.substring(0, 20) + '...',           decrypted: decrypted ? 'success' : 'failed'         });        return decrypted;      } else {        console.log('%c🔐 Encrypting legacy API key', 'color: #FFA500');        const encrypted = await EncryptionService.encryptApiKey(storedValue);        await chrome.storage.local.set({          [STORAGE_KEYS.API_KEY]: encrypted        });        return storedValue;      }    } catch (error) {      console.error('Failed to get API key from storage:', error);      return undefined;    }  }  static async setApiKey(apiKey: string): Promise<void> {    try {      const encrypted = await EncryptionService.encryptApiKey(apiKey);      await chrome.storage.local.set({        [STORAGE_KEYS.API_KEY]: encrypted      });    } catch (error) {      console.error('Failed to save API key to storage:', error);      throw error;    }  }  static async clearApiKey(): Promise<void> {    try {      await chrome.storage.local.remove(STORAGE_KEYS.API_KEY);    } catch (error) {      console.error('Failed to clear API key from storage:', error);      throw error;    }  }  static async clearAllData(): Promise<void> {    try {      await chrome.storage.local.clear();      await chrome.storage.sync.clear();      await chrome.storage.session.clear();    } catch (error) {      console.error('Failed to clear all data:', error);      throw error;    }  }  static async getLastTone(): Promise<string | undefined> {    try {      const result = await chrome.storage.session.get(STORAGE_KEYS.LAST_TONE);      return result[STORAGE_KEYS.LAST_TONE];    } catch (error) {      console.error('Failed to get last tone from session storage:', error);      return undefined;    }  }  static async setLastTone(tone: string): Promise<void> {    try {      await chrome.storage.session.set({        [STORAGE_KEYS.LAST_TONE]: tone      });      console.log('Smart Reply: Saved last used tone:', tone);    } catch (error) {      console.error('Failed to save last tone to session storage:', error);    }  }}
```

services\templateSuggester.ts
```ts
/** * Smart Template Suggestion Service for TweetCraft * ML-like pattern matching for context-aware suggestions */import { TEMPLATES } from '@/content/presetTemplates';import { TONES } from '@/content/toneSelector';import type { PresetTemplate } from '@/content/presetTemplates';import type { ToneOption } from '@/content/toneSelector';import type { LLMAnalysisResult } from '@/types/llm';import { TEMPLATE_SUGGESTER } from '@/config/models';import { JSONExtractor } from '@/utils/jsonExtractor';interface SuggestionContext {  tweetText: string;  isReply: boolean;  threadContext?: string[];  userHistory?: string[];  timeOfDay?: number;  dayOfWeek?: number;  authorHandle?: string;  threadLength?: number;  participantCount?: number;  recentEngagement?: {    likes: number;    retweets: number;     replies: number;  };}interface SuggestionScore {  templateId: string;  toneId: string;  score: number;  reasons: string[];}interface PatternRule {  pattern: RegExp;  templates: string[];  tones: string[];  weight: number;  description: string;}export class TemplateSuggester {  private patternRules: PatternRule[] = [    {      pattern: /\?|how do|what if|can you|should i|why does|where can|when will|who knows|which one/i,      templates: ['ask_question', 'add_insight', 'provide_data'],      tones: ['professional', 'academic', 'casual'],      weight: 1.8,      description: 'Question detected'    },    {      pattern: /i think|my opinion|i believe|personally|in my view|seems like|appears that|i feel/i,      templates: ['agree_expand', 'challenge', 'devils_advocate', 'personal_story'],      tones: ['witty', 'contrarian', 'philosophical', 'casual'],      weight: 1.5,      description: 'Personal opinion expressed'    },    {      pattern: /wrong|terrible|awful|disagree|nonsense|ridiculous|stupid|bad take|worst/i,      templates: ['challenge', 'devils_advocate', 'steel_man', 'hot_take'],      tones: ['contrarian', 'sarcastic', 'savage', 'philosophical'],      weight: 2.0,      description: 'Strong disagreement detected'    },    {      pattern: /just launched|shipped|achieved|built|created|finished|completed|proud of|excited to announce|success/i,      templates: ['congratulate', 'show_support', 'relate', 'celebrate'],      tones: ['enthusiastic', 'motivational', 'casual', 'wholesome'],      weight: 1.6,      description: 'Achievement or success story'    },    {      pattern: /having trouble|can't figure out|struggling with|problem|issue|broken|failed|error|help needed|stuck on/i,      templates: ['add_insight', 'share_experience', 'show_support', 'suggest_solution'],      tones: ['professional', 'casual', 'motivational', 'wholesome'],      weight: 1.6,      description: 'Help or support needed'    },    {      pattern: /amazing|incredible|love this|so good|excited|hyped|can't wait|obsessed|blown away/i,      templates: ['agree_build', 'celebrate', 'relate', 'add_energy'],      tones: ['enthusiastic', 'gen_z', 'casual', 'motivational'],      weight: 1.4,      description: 'High excitement or enthusiasm'    },    {      pattern: /statistics|data|research|study|survey|report|analysis/i,      templates: ['provide_data', 'fact_check', 'add_insight'],      tones: ['academic', 'professional', 'minimalist'],      weight: 1.3,      description: 'Data discussion'    },    {      pattern: /controversial|debate|argue|disagree|wrong|actually/i,      templates: ['challenge', 'devils_advocate', 'steel_man', 'hot_take'],      tones: ['contrarian', 'sarcastic', 'savage'],      weight: 1.5,      description: 'Debate context'    },    {      pattern: /lol|haha|funny|joke|meme|lmao|hilarious/i,      templates: ['meme_response', 'relate', 'agree_expand'],      tones: ['witty', 'gen_z', 'sarcastic'],      weight: 1.4,      description: 'Humor detected'    },    {      pattern: /breaking|announced|news|update|released|available/i,      templates: ['ask_question', 'add_insight', 'hot_take'],      tones: ['professional', 'enthusiastic', 'contrarian'],      weight: 1.2,      description: 'News/announcement'    }  ];  private usageHistory: Map<string, number> = new Map();  private successHistory: Map<string, number> = new Map();  constructor() {    this.loadHistory();    console.log('%c🤖 TemplateSuggester initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Get smart suggestions based on context   */  async getSuggestions(context: SuggestionContext): Promise<SuggestionScore[]> {    console.log('%c🤖 SMART TAB ANALYSIS STARTED', 'color: #794BC4; font-weight: bold; font-size: 16px');    console.log('%c  LLM-First Algorithm:', 'color: #657786', '✅ ENABLED');    console.log('%c  Tweet text:', 'color: #657786', context.tweetText ? '✅ YES' : '❌ NO');    console.log('%c  Tweet length:', 'color: #657786', context.tweetText?.length || 0, 'characters');    console.log('%c  Thread context:', 'color: #657786', context.threadContext?.length || 0, 'tweets');    console.log('%c  User history available:', 'color: #657786', context.userHistory ? '✅ YES' : '❌ NO');    console.log('%c  Available data points:', 'color: #657786', Object.keys(context).length);    const scores: Map<string, SuggestionScore> = new Map();    const patternScores = this.analyzePatterns(context.tweetText);    const preferences = await this.getUserPreferences();    let llmAnalysis: LLMAnalysisResult | null = null;    try {      const apiKey = await this.getApiKey();      if (apiKey && context.tweetText.length > 20) {        llmAnalysis = await this.getLLMAnalysis(context.tweetText, context, apiKey);      }    } catch (error) {      console.log('%c🤖 Proceeding without LLM analysis', 'color: #657786');    }    const templates = TEMPLATES;    const tones = TONES;    templates.forEach((template: PresetTemplate) => {      tones.forEach((tone: ToneOption) => {        const key = `${template.id}:${tone.id}`;        const score = this.calculateScore(          template,          tone,          context,          patternScores,          preferences,          llmAnalysis        );        scores.set(key, score);      });    });    const sorted = Array.from(scores.values())      .sort((a, b) => b.score - a.score)      .slice(0, 12);     console.log('%c🤖 Top suggestions:', 'color: #17BF63');    sorted.slice(0, 3).forEach((s, i) => {      console.log(`  ${i + 1}. ${s.templateId}:${s.toneId} (${s.score.toFixed(2)})`, s.reasons);    });    return sorted;  }  /**   * Analyze text patterns   */  private analyzePatterns(text: string): Map<string, number> {    const scores = new Map<string, number>();    this.patternRules.forEach(rule => {      if (rule.pattern.test(text)) {        rule.templates.forEach(templateId => {          const current = scores.get(templateId) || 0;          scores.set(templateId, current + rule.weight);        });        rule.tones.forEach(toneId => {          const current = scores.get(`tone:${toneId}`) || 0;          scores.set(`tone:${toneId}`, current + rule.weight);        });      }    });    return scores;  }  /**   * Calculate score for a template-tone combination   */  private calculateScore(    template: PresetTemplate,    tone: ToneOption,    context: SuggestionContext,    patternScores: Map<string, number>,    preferences: any,    llmAnalysis?: LLMAnalysisResult | null  ): SuggestionScore {    let score = 0.5;     const reasons: string[] = [];    if (llmAnalysis) {      if (llmAnalysis.suggestedCategories?.includes(template.category)) {        score += 8.0;         reasons.push('🤖 AI strongly recommends this approach');      }      if (llmAnalysis.suggestedTones?.includes(tone.id)) {        score += 6.0;         reasons.push('🤖 AI suggests this tone');      }      if (llmAnalysis.confidence) {        const confidenceBoost = llmAnalysis.confidence * 4.0;        score += confidenceBoost;        reasons.push(`🤖 AI confidence: ${(llmAnalysis.confidence * 100).toFixed(0)}%`);      }      if (llmAnalysis.sentiment) {        if (llmAnalysis.sentiment === 'positive' && tone.id === 'enthusiastic') {          score += 3.0;          reasons.push('🎯 Perfect tone for positive sentiment');        } else if (llmAnalysis.sentiment === 'negative' && tone.id === 'motivational') {          score += 3.0;            reasons.push('🎯 Motivational tone for negativity');        } else if (llmAnalysis.sentiment === 'controversial' && template.category === 'debate') {          score += 4.0;          reasons.push('🔥 Debate approach for controversy');        }      }      if (llmAnalysis.intent) {        const intentMatches = this.getIntentMatches(template, tone, llmAnalysis.intent);        score += intentMatches.score;        if (intentMatches.reason) {          reasons.push(`🎯 ${intentMatches.reason}`);        }      }      if (llmAnalysis.reasoning && llmAnalysis.reasoning.length > 0) {        const keyReasoning = llmAnalysis.reasoning[0];         reasons.push(`🧠 AI reasoning: ${keyReasoning}`);        if (keyReasoning.includes('perfect') || keyReasoning.includes('ideal')) {          score += 2.0;        } else if (keyReasoning.includes('good') || keyReasoning.includes('suitable')) {          score += 1.0;        }      }      if (llmAnalysis.threadAnalysis) {        const threadBonus = this.calculateThreadAnalysisBonus(template, tone, llmAnalysis.threadAnalysis);        score += threadBonus.score;        if (threadBonus.reason) {          reasons.push(`🧵 ${threadBonus.reason}`);        }      }      if (llmAnalysis.userContext) {        const userBonus = this.calculateUserContextBonus(template, tone, llmAnalysis.userContext);        score += userBonus.score;        if (userBonus.reason) {          reasons.push(`👤 ${userBonus.reason}`);        }      }    } else {      const templatePatternScore = (patternScores.get(template.id) || 0) * 0.3;      const tonePatternScore = (patternScores.get(`tone:${tone.id}`) || 0) * 0.3;      score += templatePatternScore + tonePatternScore;      if (templatePatternScore > 0) {        reasons.push(`Pattern match (${templatePatternScore.toFixed(1)})`);      }      if (tonePatternScore > 0) {        reasons.push(`Tone pattern (${tonePatternScore.toFixed(1)})`);      }      reasons.push('⚠️ Using fallback pattern matching (AI unavailable)');    }    if (preferences.favoriteTemplates?.includes(template.id)) {      score += 2.0;      reasons.push('Favorite template');    }    if (preferences.favoriteTones?.includes(tone.id)) {      score += 2.0;      reasons.push('Favorite tone');    }    const usageKey = `${template.id}:${tone.id}`;    const usageCount = this.usageHistory.get(usageKey) || 0;    if (usageCount > 0) {      score += Math.min(usageCount * 0.1, 1.0);      reasons.push(`Used ${usageCount} times`);    }    const successRate = this.successHistory.get(usageKey) || 0;    if (successRate > 0) {      score += successRate * 2.0;      reasons.push(`Success rate: ${(successRate * 100).toFixed(0)}%`);    }    if (context.isReply) {      if (template.category === 'engagement') {        score += 0.5;        reasons.push('Good for replies');      }    }    if (context.timeOfDay !== undefined) {      const hour = context.timeOfDay;      if (hour >= 9 && hour <= 17 && tone.id === 'professional') {        score += 0.3;        reasons.push('Work hours');      }      if (hour >= 18 && hour <= 23 && tone.id === 'casual') {        score += 0.3;        reasons.push('Evening hours');      }    }    if (context.threadContext && context.threadContext.length > 2) {      if (template.category === 'debate') {        score += 0.5;        reasons.push('Long thread');      }    }    if (llmAnalysis) {      if (llmAnalysis.suggestedCategories?.includes(template.category)) {        score += 2.0;        reasons.push('AI-detected intent match');      }      if (llmAnalysis.suggestedTones?.includes(tone.id)) {        score += 1.5;        reasons.push('AI-detected tone match');      }      if (llmAnalysis.sentiment) {        if (llmAnalysis.sentiment === 'positive' && tone.id === 'enthusiastic') {          score += 0.5;        } else if (llmAnalysis.sentiment === 'negative' && tone.id === 'motivational') {          score += 0.5;        } else if (llmAnalysis.sentiment === 'controversial' && template.category === 'debate') {          score += 1.0;        }      }    }    return {      templateId: template.id,      toneId: tone.id,      score,      reasons    };  }  /**   * Get intent-based scoring matches   */  private getIntentMatches(template: PresetTemplate, tone: ToneOption, intent: string): { score: number; reason?: string } {    const intentMappings: Record<string, { templates: string[], tones: string[], score: number, reason: string }> = {      'question': {        templates: ['ask_question', 'add_insight', 'provide_data'],        tones: ['professional', 'academic', 'casual'],        score: 5.0,        reason: 'Perfect for answering questions'      },      'opinion': {        templates: ['agree_expand', 'challenge', 'devils_advocate'],          tones: ['witty', 'contrarian', 'philosophical'],        score: 4.5,        reason: 'Great for opinion discussions'      },      'problem': {        templates: ['add_insight', 'share_experience', 'suggest_solution'],        tones: ['professional', 'motivational', 'wholesome'],        score: 5.5,        reason: 'Ideal for problem-solving'      },      'achievement': {        templates: ['congratulate', 'show_support', 'celebrate'],        tones: ['enthusiastic', 'motivational', 'wholesome'],        score: 4.0,        reason: 'Perfect for celebrating success'      },      'debate': {        templates: ['challenge', 'devils_advocate', 'steel_man', 'hot_take'],        tones: ['contrarian', 'sarcastic', 'savage', 'philosophical'],        score: 6.0,        reason: 'Excellent for debates'      },      'humor': {        templates: ['add_humor', 'roast', 'meme_reference'],        tones: ['witty', 'sarcastic', 'gen_z'],        score: 3.5,        reason: 'Great for humor'      }    };    const mapping = intentMappings[intent];    if (!mapping) return { score: 0 };    let matchScore = 0;    if (mapping.templates.includes(template.id)) matchScore += mapping.score;    if (mapping.tones.includes(tone.id)) matchScore += mapping.score * 0.6;    return matchScore > 0 ? { score: matchScore, reason: mapping.reason } : { score: 0 };  }  /**   * Build context string for LLM analysis   */  private buildContextString(context: SuggestionContext): string {    const contextParts: string[] = [];    if (context.threadContext && context.threadContext.length > 0) {      contextParts.push(`THREAD CONTEXT (${context.threadContext.length} previous tweets):`);      context.threadContext.forEach((tweet, i) => {        contextParts.push(`${i + 1}. ${tweet}`);      });    }    if (context.authorHandle) {      contextParts.push(`AUTHOR: ${context.authorHandle}`);    }    if (context.threadLength) {      contextParts.push(`THREAD LENGTH: ${context.threadLength} tweets`);    }    if (context.participantCount && context.participantCount > 1) {      contextParts.push(`PARTICIPANTS: ${context.participantCount} people in conversation`);    }    if (context.recentEngagement) {      const eng = context.recentEngagement;      contextParts.push(`ENGAGEMENT: ${eng.likes} likes, ${eng.retweets} retweets, ${eng.replies} replies`);    }    if (context.timeOfDay !== undefined) {      const hour = context.timeOfDay;      let timeContext = '';      if (hour >= 5 && hour < 12) timeContext = 'morning';      else if (hour >= 12 && hour < 17) timeContext = 'afternoon';        else if (hour >= 17 && hour < 22) timeContext = 'evening';      else timeContext = 'late night/early morning';      contextParts.push(`TIME CONTEXT: ${timeContext} (${hour}:00)`);    }    if (context.isReply) {      contextParts.push(`REPLY CONTEXT: This is a reply to another tweet`);    }    return contextParts.length > 0 ? contextParts.join('\n') : 'LIMITED CONTEXT AVAILABLE';  }  /**   * Calculate thread analysis bonus scoring   */  private calculateThreadAnalysisBonus(template: PresetTemplate, tone: ToneOption, threadAnalysis: any): { score: number; reason?: string } {    let score = 0;    let reason = '';    if (threadAnalysis.conversationStage === 'heated' && template.category === 'debate') {      score += 2.5;      reason = 'Perfect for heated debates';    } else if (threadAnalysis.conversationStage === 'resolution' && template.category === 'collaborative') {      score += 2.0;       reason = 'Great for resolution phase';    } else if (threadAnalysis.conversationStage === 'opening' && template.category === 'engagement') {      score += 1.5;      reason = 'Good conversation starter';    }    if (threadAnalysis.threadSentiment === 'escalating' && tone.id === 'professional') {      score += 1.5;      reason += (reason ? ' + ' : '') + 'Professional tone de-escalates';    } else if (threadAnalysis.threadSentiment === 'de-escalating' && tone.id === 'wholesome') {      score += 1.0;      reason += (reason ? ' + ' : '') + 'Wholesome tone maintains calm';    }    return { score, reason: reason || undefined };  }  /**   * Calculate user context bonus scoring     */  private calculateUserContextBonus(template: PresetTemplate, tone: ToneOption, userContext: any): { score: number; reason?: string } {    let score = 0;    let reason = '';    if (userContext.userType === 'expert' && tone.id === 'academic') {      score += 2.0;      reason = 'Academic tone for experts';    } else if (userContext.userType === 'beginner' && tone.id === 'casual') {      score += 1.5;      reason = 'Casual tone for beginners';    } else if (userContext.userType === 'influencer' && template.category === 'viral') {      score += 2.5;      reason = 'Viral content for influencers';    }    if (userContext.communicationStyle === 'formal' && tone.id === 'professional') {      score += 1.5;      reason += (reason ? ' + ' : '') + 'Matches formal style';    } else if (userContext.communicationStyle === 'humorous' && tone.id === 'witty') {      score += 2.0;      reason += (reason ? ' + ' : '') + 'Matches humorous style';    } else if (userContext.communicationStyle === 'technical' && template.category === 'value') {      score += 1.5;      reason += (reason ? ' + ' : '') + 'Technical value-add';    }    return { score, reason: reason || undefined };  }  /**   * Record usage of a template-tone combination   */  recordUsage(templateId: string, toneId: string): void {    const key = `${templateId}:${toneId}`;    const current = this.usageHistory.get(key) || 0;    this.usageHistory.set(key, current + 1);    this.saveHistory();    console.log('%c🤖 Recorded usage:', 'color: #657786', key);  }  /**   * Record success (user sent the generated reply)   */  recordSuccess(templateId: string, toneId: string, sent: boolean): void {    const key = `${templateId}:${toneId}`;    const current = this.successHistory.get(key) || 0;    const alpha = 0.1;     const newRate = alpha * (sent ? 1 : 0) + (1 - alpha) * current;    this.successHistory.set(key, newRate);    this.saveHistory();    console.log('%c🤖 Recorded success:', 'color: #657786', key, sent);  }  /**   * Get quick suggestions (no context analysis)   */  async getQuickSuggestions(): Promise<{ templates: PresetTemplate[], tones: ToneOption[] }> {    const favoriteTemplates = await this.getFavoriteTemplates();    const favoriteTones = await this.getFavoriteTones();    const mostUsedTemplates = this.getMostUsedTemplates(3);    const mostUsedTones = this.getMostUsedTones(3);    const templateIds = new Set([      ...favoriteTemplates.map(t => t.id),      ...mostUsedTemplates    ]);    const toneIds = new Set([      ...favoriteTones.map(t => t.id),      ...mostUsedTones    ]);    const templates = Array.from(templateIds)      .map(id => TEMPLATES.find((t: PresetTemplate) => t.id === id))      .filter(Boolean) as PresetTemplate[];    const tones = Array.from(toneIds)      .map(id => TONES.find((t: ToneOption) => t.id === id))      .filter(Boolean) as ToneOption[];    return { templates, tones };  }  /**   * Get most used templates   */  private getMostUsedTemplates(limit: number): string[] {    const templateUsage = new Map<string, number>();    this.usageHistory.forEach((count, key) => {      const [templateId] = key.split(':');      const current = templateUsage.get(templateId) || 0;      templateUsage.set(templateId, current + count);    });    return Array.from(templateUsage.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, limit)      .map(([id]) => id);  }  /**   * Get most used tones   */  private getMostUsedTones(limit: number): string[] {    const toneUsage = new Map<string, number>();    this.usageHistory.forEach((count, key) => {      const [, toneId] = key.split(':');      const current = toneUsage.get(toneId) || 0;      toneUsage.set(toneId, current + count);    });    return Array.from(toneUsage.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, limit)      .map(([id]) => id);  }  /**   * Load history from storage   */  private async loadHistory(): Promise<void> {    try {      const stored = await chrome.storage.local.get(['suggestionHistory']);      if (stored.suggestionHistory) {        this.usageHistory = new Map(stored.suggestionHistory.usage);        this.successHistory = new Map(stored.suggestionHistory.success);      }    } catch (error) {      console.warn('Failed to load suggestion history:', error);    }  }  /**   * Save history to storage   */  private async saveHistory(): Promise<void> {    try {      await chrome.storage.local.set({        suggestionHistory: {          usage: Array.from(this.usageHistory.entries()),          success: Array.from(this.successHistory.entries())        }      });    } catch (error) {      console.warn('Failed to save suggestion history:', error);    }  }  /**   * Clear history   */  clearHistory(): void {    this.usageHistory.clear();    this.successHistory.clear();    this.saveHistory();    console.log('%c🤖 History cleared', 'color: #FFA500');  }  /**   * Get statistics   */  getStats(): {    totalUsage: number;    uniqueCombinations: number;    averageSuccessRate: number;  } {    const totalUsage = Array.from(this.usageHistory.values()).reduce((a, b) => a + b, 0);    const uniqueCombinations = this.usageHistory.size;    const successRates = Array.from(this.successHistory.values());    const averageSuccessRate = successRates.length > 0      ? successRates.reduce((a, b) => a + b, 0) / successRates.length      : 0;    return {      totalUsage,      uniqueCombinations,      averageSuccessRate    };  }  /**   * Get user preferences from localStorage   */  private async getUserPreferences(): Promise<any> {    try {      const stored = await chrome.storage.local.get(['userPreferences']);      return stored.userPreferences || {        favoriteTemplates: [],        favoriteTones: []      };    } catch {      return {        favoriteTemplates: [],        favoriteTones: []      };    }  }  /**   * Get favorite templates   */  private async getFavoriteTemplates(): Promise<PresetTemplate[]> {    const preferences = await this.getUserPreferences();    return preferences.favoriteTemplates      ?.map((id: string) => TEMPLATES.find((t: PresetTemplate) => t.id === id))      .filter(Boolean) || [];  }  /**   * Get favorite tones   */  private async getFavoriteTones(): Promise<ToneOption[]> {    const preferences = await this.getUserPreferences();    return preferences.favoriteTones      ?.map((id: string) => TONES.find((t: ToneOption) => t.id === id))      .filter(Boolean) || [];  }  /**   * Get API key from storage (with encryption support and timeout)   */  private async getApiKey(): Promise<string | null> {    try {      return new Promise((resolve) => {        const timeout = setTimeout(() => {          console.error('API key request timed out after 5 seconds');          resolve(null);        }, 5000);         chrome.runtime.sendMessage({ type: 'GET_API_KEY' }, (response) => {          clearTimeout(timeout);          if (chrome.runtime.lastError) {            console.error('Failed to get API key:', chrome.runtime.lastError);            resolve(null);          } else if (response && response.success) {            resolve(response.apiKey);          } else {            resolve(null);          }        });      });    } catch (error) {      console.error('Failed to retrieve API key:', error);      return null;    }  }  /**   * Get LLM analysis of tweet for better suggestions   */  private async getLLMAnalysis(tweetText: string, context: SuggestionContext, apiKey: string): Promise<LLMAnalysisResult | null> {    try {      console.log('%c🧠 LLM ANALYSIS STARTED', 'color: #794BC4; font-weight: bold; font-size: 14px');      console.log('%c  Tweet text length:', 'color: #657786', tweetText?.length || 0, 'characters');      console.log('%c  Building context for AI analysis...', 'color: #657786');      const contextInfo = this.buildContextString(context);      console.log('%c  Context built:', 'color: #657786', contextInfo.length, 'characters');      const prompt = `You are an expert social media strategist analyzing tweets for optimal reply suggestions. TWEET TO ANALYZE: "${tweetText}"${contextInfo}ANALYSIS FRAMEWORK:1. Read the tweet carefully and understand the author's intent2. Consider the conversation context and thread dynamics  3. Identify the optimal reply approach and tone4. Provide confidence scores and reasoningEXAMPLES:Tweet: "Just shipped our new AI feature after 6 months of work! 🚀"Analysis: {  "sentiment": "positive",  "intent": "achievement",   "confidence": 0.95,  "reasoning": ["Clear achievement announcement", "Positive sentiment with emoji", "Invites congratulations"],  "suggestedCategories": ["celebration", "engagement", "support"],  "suggestedTones": ["enthusiastic", "motivational", "wholesome"],  "threadAnalysis": {"conversationStage": "opening"},  "userContext": {"engagementLevel": "high"}}Tweet: "Why do people still think AI will replace developers? This is such a bad take..."Analysis: {  "sentiment": "controversial",   "intent": "debate",  "confidence": 0.88,  "reasoning": ["Controversial opinion stated", "Dismissive language used", "Invites debate/discussion"],  "suggestedCategories": ["debate", "challenge", "perspective"],  "suggestedTones": ["contrarian", "professional", "philosophical"],   "threadAnalysis": {"conversationStage": "heated"},  "userContext": {"communicationStyle": "technical"}}Tweet: "Having trouble with React state management. Anyone know good patterns?"Analysis: {  "sentiment": "neutral",  "intent": "problem",   "confidence": 0.92,  "reasoning": ["Clear problem statement", "Direct request for help", "Technical domain"],  "suggestedCategories": ["help", "solution", "insight"],  "suggestedTones": ["professional", "casual", "academic"],  "threadAnalysis": {"conversationStage": "opening"},  "userContext": {"userType": "beginner", "communicationStyle": "technical"}}NOW ANALYZE THE TARGET TWEET. Return ONLY valid JSON with all fields:`;      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {        method: 'POST',        headers: {          'Authorization': `Bearer ${apiKey}`,          'Content-Type': 'application/json',          'HTTP-Referer': 'chrome-extension://tweetcraft',          'X-Title': 'TweetCraft Smart Suggestions'        },        body: JSON.stringify({          model: TEMPLATE_SUGGESTER,          messages: [            {              role: 'system',              content: 'You are an expert social media strategist and tweet analysis assistant. Provide detailed, confident analysis in valid JSON format only. Always include confidence scores and reasoning chains.'            },            {              role: 'user',              content: prompt            }          ],          temperature: 0.2,           max_tokens: 800        })      });      if (!response.ok) {        throw new Error(`API error: ${response.status}`);      }      const data = await response.json();      const content = data.choices[0]?.message?.content;      if (content) {        const analysis = JSONExtractor.parseJSON<LLMAnalysisResult>(content);        if (analysis) {          console.log('%c✅ LLM ANALYSIS COMPLETE', 'color: #17BF63; font-weight: bold; font-size: 14px');          console.log('%c  Sentiment:', 'color: #657786', analysis.sentiment || 'not detected');          console.log('%c  Intent:', 'color: #657786', analysis.intent || 'not detected');          console.log('%c  Suggested categories:', 'color: #657786', analysis.suggestedCategories?.length || 0);          console.log('%c  Confidence score:', 'color: #657786', analysis.confidence || 'not provided');          console.log('%c  Reasoning steps:', 'color: #657786', analysis.reasoning?.length || 0);          console.log('%c  Thread analysis:', 'color: #657786', analysis.threadAnalysis ? '✅ YES' : '❌ NO');          console.log('%c  User context:', 'color: #657786', analysis.userContext ? '✅ YES' : '❌ NO');          console.log('%c  Topics identified:', 'color: #657786', analysis.topics?.length || 0);          return analysis;        } else {          console.warn('Failed to extract valid JSON from LLM response');        }      }    } catch (error) {      console.log('%c🤖 LLM analysis failed:', 'color: #657786', error);    }    return null;  }}export const templateSuggester = new TemplateSuggester();
```

services\usageTracker.ts
```ts
/** * Usage Tracking Service for TweetCraft * Analytics and usage patterns tracking */import { TemplateId, ToneId, Timestamp, createTimestamp } from '@/types/branded';interface UsageEvent {  id: string;  type: UsageEventType;  timestamp: Timestamp;  data: Record<string, any>;  sessionId: string;}type UsageEventType =   | 'template_selected'  | 'tone_selected'  | 'reply_generated'  | 'reply_sent'  | 'reply_edited'  | 'reply_discarded'  | 'arsenal_used'  | 'suggestion_accepted'  | 'suggestion_rejected'  | 'favorite_added'  | 'favorite_removed'  | 'intensity_changed'  | 'cache_hit'  | 'cache_miss'  | 'api_call'  | 'error';interface UsageStats {  totalEvents: number;  eventsByType: Record<UsageEventType, number>;  templateUsage: Map<TemplateId, number>;  toneUsage: Map<ToneId, number>;  personalityUsage: Map<string, number>;  vocabularyUsage: Map<string, number>;  lengthPacingUsage: Map<string, number>;  combinationUsage: Map<string, number>;  successRate: number;  averageResponseTime: number;  cacheHitRate: number;  errorRate: number;  peakUsageHours: number[];  dailyUsage: Map<string, number>;}interface PerformanceMetrics {  apiCallDuration: number[];  cacheRetrievalTime: number[];  renderingTime: number[];  totalMemoryUsed: number;}export class UsageTracker {  private events: UsageEvent[] = [];  private sessionId: string;  private performanceMetrics: PerformanceMetrics = {    apiCallDuration: [],    cacheRetrievalTime: [],    renderingTime: [],    totalMemoryUsed: 0  };  private readonly MAX_EVENTS = 1000;  private readonly STORAGE_KEY = 'tweetcraft_usage';  private saveTimeout: number | null = null;  constructor() {    this.sessionId = this.generateSessionId();    this.loadFromStorage();    this.startMemoryMonitoring();    console.log('%c📊 UsageTracker initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Track a usage event   */  track(type: UsageEventType, data: Record<string, any> = {}): void {    const event: UsageEvent = {      id: this.generateEventId(),      type,      timestamp: createTimestamp(),      data,      sessionId: this.sessionId    };    this.events.push(event);    if (this.events.length > this.MAX_EVENTS) {      this.events = this.events.slice(-this.MAX_EVENTS);    }    console.log(`%c📊 Event tracked: ${type}`, 'color: #657786', data);    this.scheduleSave();  }  /**   * Track template selection   */  trackTemplateSelection(templateId: TemplateId, source: 'manual' | 'suggestion' | 'favorite'): void {    this.track('template_selected', { templateId, source });  }  /**   * Track tone selection   */  trackToneSelection(toneId: ToneId, intensity: number, source: 'manual' | 'suggestion' | 'favorite'): void {    this.track('tone_selected', { toneId, intensity, source });  }  /**   * Track persona selection   */  trackPersonaSelection(personaId: string, source: 'manual' | 'suggestion' | 'favorite'): void {    this.track('template_selected', { templateId: personaId as TemplateId, source });  }  /**   * Track reply generation   */  trackReplyGeneration(    templateId: TemplateId,    toneId: ToneId,    duration: number,    cached: boolean  ): void {    this.track('reply_generated', {      templateId,      toneId,      duration,      cached,      combination: `${templateId}:${toneId}`    });    if (!cached) {      this.performanceMetrics.apiCallDuration.push(duration);    } else {      this.performanceMetrics.cacheRetrievalTime.push(duration);    }  }  /**   * Track reply outcome   */  trackReplyOutcome(outcome: 'sent' | 'edited' | 'discarded', replyLength?: number): void {    this.track(`reply_${outcome}` as UsageEventType, { replyLength });  }  /**   * Track suggestion interaction   */  trackSuggestion(accepted: boolean, suggestionType: string, score: number): void {    this.track(      accepted ? 'suggestion_accepted' : 'suggestion_rejected',      { suggestionType, score }    );  }  /**   * Track cache performance   */  trackCachePerformance(hit: boolean, retrievalTime: number): void {    this.track(hit ? 'cache_hit' : 'cache_miss', { retrievalTime });    if (hit) {      this.performanceMetrics.cacheRetrievalTime.push(retrievalTime);    }  }  /**   * Track error   */  trackError(error: string, context: Record<string, any>): void {    this.track('error', { error, context });  }  /**   * Track performance timing   */  trackTiming(operation: string, duration: number): void {    if (operation === 'render') {      this.performanceMetrics.renderingTime.push(duration);    }    this.track('api_call', { operation, duration });  }  /**   * Get usage statistics   */  getStats(): UsageStats {    const stats: UsageStats = {      totalEvents: this.events.length,      eventsByType: {} as Record<UsageEventType, number>,      templateUsage: new Map(),      toneUsage: new Map(),      personalityUsage: new Map(),      vocabularyUsage: new Map(),      lengthPacingUsage: new Map(),      combinationUsage: new Map(),      successRate: 0,      averageResponseTime: 0,      cacheHitRate: 0,      errorRate: 0,      peakUsageHours: [],      dailyUsage: new Map()    };    this.events.forEach(event => {      stats.eventsByType[event.type] = (stats.eventsByType[event.type] || 0) + 1;      if (event.data.templateId) {        const templateId = event.data.templateId as TemplateId;        stats.templateUsage.set(templateId, (stats.templateUsage.get(templateId) || 0) + 1);      }      if (event.data.toneId) {        const toneId = event.data.toneId as ToneId;        stats.toneUsage.set(toneId, (stats.toneUsage.get(toneId) || 0) + 1);      }      if (event.data.personalityId) {        const personalityId = event.data.personalityId as string;        stats.personalityUsage.set(personalityId, (stats.personalityUsage.get(personalityId) || 0) + 1);      }      if (event.data.vocabularyId) {        const vocabularyId = event.data.vocabularyId as string;        stats.vocabularyUsage.set(vocabularyId, (stats.vocabularyUsage.get(vocabularyId) || 0) + 1);      }      if (event.data.lengthPacingId) {        const lengthPacingId = event.data.lengthPacingId as string;        stats.lengthPacingUsage.set(lengthPacingId, (stats.lengthPacingUsage.get(lengthPacingId) || 0) + 1);      }      if (event.data.combination) {        const combo = event.data.combination;        stats.combinationUsage.set(combo, (stats.combinationUsage.get(combo) || 0) + 1);      }      const date = new Date(event.timestamp).toDateString();      stats.dailyUsage.set(date, (stats.dailyUsage.get(date) || 0) + 1);    });    const generated = stats.eventsByType['reply_generated'] || 0;    const sent = stats.eventsByType['reply_sent'] || 0;    stats.successRate = generated > 0 ? (sent / generated) * 100 : 0;    if (this.performanceMetrics.apiCallDuration.length > 0) {      const sum = this.performanceMetrics.apiCallDuration.reduce((a, b) => a + b, 0);      stats.averageResponseTime = sum / this.performanceMetrics.apiCallDuration.length;    }    const cacheHits = stats.eventsByType['cache_hit'] || 0;    const cacheMisses = stats.eventsByType['cache_miss'] || 0;    const totalCacheAccess = cacheHits + cacheMisses;    stats.cacheHitRate = totalCacheAccess > 0 ? (cacheHits / totalCacheAccess) * 100 : 0;    const errors = stats.eventsByType['error'] || 0;    stats.errorRate = stats.totalEvents > 0 ? (errors / stats.totalEvents) * 100 : 0;    const hourCounts = new Map<number, number>();    this.events.forEach(event => {      const hour = new Date(event.timestamp).getHours();      hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);    });    const sortedHours = Array.from(hourCounts.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, 3)      .map(([hour]) => hour);    stats.peakUsageHours = sortedHours;    return stats;  }  /**   * Get performance metrics   */  getPerformanceMetrics = (): {    averageApiCall: number;    averageCacheRetrieval: number;    averageRenderTime: number;    memoryUsage: number;    p95ApiCall: number;    p95CacheRetrieval: number;  } => {    const calculateAverage = (arr: number[]) =>       arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;    const calculateP95 = (arr: number[]) => {      if (arr.length === 0) return 0;      const sorted = [...arr].sort((a, b) => a - b);      const index = Math.floor(sorted.length * 0.95);      return sorted[index];    };    return {      averageApiCall: calculateAverage(this.performanceMetrics.apiCallDuration),      averageCacheRetrieval: calculateAverage(this.performanceMetrics.cacheRetrievalTime),      averageRenderTime: calculateAverage(this.performanceMetrics.renderingTime),      memoryUsage: this.performanceMetrics.totalMemoryUsed,      p95ApiCall: calculateP95(this.performanceMetrics.apiCallDuration),      p95CacheRetrieval: calculateP95(this.performanceMetrics.cacheRetrievalTime)    };  }  /**   * Get insights and recommendations   */  getInsights(): string[] {    const insights: string[] = [];    const stats = this.getStats();    const perf = this.getPerformanceMetrics();    if (stats.successRate < 50) {      insights.push('Low success rate - consider adjusting tone or template selections');    } else if (stats.successRate > 80) {      insights.push('High success rate - your selections are working well!');    }    if (stats.cacheHitRate < 30) {      insights.push('Low cache hit rate - consider pre-loading common combinations');    } else if (stats.cacheHitRate > 70) {      insights.push('Excellent cache performance - responses are fast');    }    if (perf.averageApiCall > 3000) {      insights.push('Slow API responses - consider using a faster model');    }    const topCombo = Array.from(stats.combinationUsage.entries())      .sort((a, b) => b[1] - a[1])[0];    if (topCombo) {      insights.push(`Most used: ${topCombo[0]} (${topCombo[1]} times)`);    }    if (stats.peakUsageHours.length > 0) {      insights.push(`Peak usage hours: ${stats.peakUsageHours.join(', ')}:00`);    }    if (stats.errorRate > 5) {      insights.push('High error rate detected - check your configuration');    }    return insights;  }  /**   * Export data for analysis   */  exportData = (): {    events: UsageEvent[];    stats: UsageStats;    performance: {      averageApiCall: number;      averageCacheRetrieval: number;      averageRenderTime: number;      memoryUsage: number;      p95ApiCall: number;      p95CacheRetrieval: number;    };    insights: string[];    exportedAt: string;  } => {    return {      events: this.events,      stats: this.getStats(),      performance: this.getPerformanceMetrics(),      insights: this.getInsights(),      exportedAt: new Date().toISOString()    };  }  /**   * Get top N most used combinations   */  getTopCombinations(limit: number = 3): Array<{combination: string, count: number}> {    const stats = this.getStats();    return Array.from(stats.combinationUsage.entries())      .sort((a, b) => b[1] - a[1])      .slice(0, limit)      .map(([combination, count]) => ({ combination, count }));  }  /**   * Clear old events   */  clearOldEvents(daysToKeep: number = 30): void {    const cutoff = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);    const oldCount = this.events.length;    this.events = this.events.filter(event => event.timestamp > cutoff);    const removed = oldCount - this.events.length;    if (removed > 0) {      console.log(`%c📊 Cleared ${removed} old events`, 'color: #FFA500');      this.saveToStorage();    }  }  /**   * Generate session ID   */  private generateSessionId(): string {    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;  }  /**   * Generate event ID   */  private generateEventId(): string {    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;  }  /**   * Start memory monitoring   */  private startMemoryMonitoring(): void {    if ('memory' in performance) {      setInterval(() => {        const memory = (performance as any).memory;        this.performanceMetrics.totalMemoryUsed = memory.usedJSHeapSize;      }, 30000);     }  }  /**   * Schedule save to storage   */  private scheduleSave(): void {    if (this.saveTimeout !== null) {      clearTimeout(this.saveTimeout);    }    this.saveTimeout = window.setTimeout(() => {      this.saveToStorage();    }, 5000);   }  /**   * Save to Chrome storage   */  private async saveToStorage(): Promise<void> {    try {      const recentEvents = this.events.slice(-500);      await chrome.storage.local.set({        [this.STORAGE_KEY]: {          events: recentEvents,          metrics: this.performanceMetrics,          savedAt: Date.now()        }      });      console.log('%c📊 Usage data saved', 'color: #17BF63');    } catch (error) {      console.error('Failed to save usage data:', error);    }  }  /**   * Load from Chrome storage   */  private async loadFromStorage(): Promise<void> {    try {      const result = await chrome.storage.local.get([this.STORAGE_KEY]);      if (result[this.STORAGE_KEY]) {        const data = result[this.STORAGE_KEY];        this.events = data.events || [];        this.performanceMetrics = data.metrics || this.performanceMetrics;        console.log(`%c📊 Loaded ${this.events.length} events from storage`, 'color: #17BF63');      }    } catch (error) {      console.error('Failed to load usage data:', error);    }  }  /**   * Reset all data   */  async reset(): Promise<void> {    this.events = [];    this.performanceMetrics = {      apiCallDuration: [],      cacheRetrievalTime: [],      renderingTime: [],      totalMemoryUsed: 0    };    await chrome.storage.local.remove([this.STORAGE_KEY]);    console.log('%c📊 Usage data reset', 'color: #FFA500');  }}export const usageTracker = new UsageTracker();
```

services\visionService.ts
```ts
/** * Vision Service - Image Understanding with OpenRouter Vision Models * Analyzes images in tweets to provide richer context for AI replies */import { StorageService } from './storage';import { ConfigurationManager } from '@/config/configurationManager';import { API_CONFIG } from '@/config/apiConfig';import { MessageType } from '@/types/messages';export interface VisionAnalysisResult {  success: boolean;  description?: string;  objects?: string[];  text?: string;  sentiment?: 'positive' | 'neutral' | 'negative';  context?: string;  error?: string;}export interface VisionModelConfig {  model: string;  enabled: boolean;  maxImagesPerRequest: number;  costPerImage: number; }export class VisionService {  private static instance: VisionService;  private apiKey: string | null = null;  private baseUrl = 'https://openrouter.ai/api/v1';  private readonly visionModels: Record<string, { id: string; name: string; maxTokens: number; costPer1k: number }> = {    'gpt-4o': {      id: 'openai/gpt-4o',      name: 'GPT-4o (Vision)',      maxTokens: 4096,      costPer1k: 0.005    },    'gpt-4o-mini': {      id: 'openai/gpt-4o-mini',      name: 'GPT-4o Mini (Vision)',      maxTokens: 4096,      costPer1k: 0.00015    },    'claude-3-5-sonnet': {      id: 'anthropic/claude-3.5-sonnet',      name: 'Claude 3.5 Sonnet',      maxTokens: 4096,      costPer1k: 0.003    },    'claude-3-haiku': {      id: 'anthropic/claude-3-haiku',      name: 'Claude 3 Haiku',      maxTokens: 4096,      costPer1k: 0.00025    },    'gemini-2-flash': {      id: 'google/gemini-2.0-flash-exp:free',      name: 'Gemini 2.0 Flash',      maxTokens: 8192,      costPer1k: 0.0    }  };  private defaultModel = 'gemini-2-flash';   private constructor() {}  static getInstance(): VisionService {    if (!VisionService.instance) {      VisionService.instance = new VisionService();    }    return VisionService.instance;  }  /**   * Initialize the service with API key   */  async initialize(): Promise<void> {    this.apiKey = API_CONFIG.OPENROUTER_API_KEY;    if (!this.apiKey || this.apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {      console.log('%c⚠️ Vision Service: API key not configured in apiConfig.ts', 'color: #FFA500');      this.apiKey = null;    } else {      console.log('%c✅ Vision Service: API key loaded', 'color: #17BF63');    }  }  /**   * Check if vision analysis is enabled   */  async isEnabled(): Promise<boolean> {    const config = await ConfigurationManager.getInstance().getConfig();    return config.features?.imageUnderstanding?.enabled ?? false;  }  /**   * Analyze images and return contextual description   */  async analyzeImages(imageUrls: string[], tweetText?: string): Promise<VisionAnalysisResult> {    const isEnabled = await this.isEnabled();    console.log('%c👁️ IMAGE UNDERSTANDING CHECK', 'color: #794BC4; font-weight: bold; font-size: 14px');    console.log('%c  Status:', 'color: #657786', isEnabled ? '✅ ENABLED' : '❌ DISABLED');    console.log('%c  Images to analyze:', 'color: #657786', imageUrls.length);    console.log('%c  Image URLs:', 'color: #657786', imageUrls);    console.log('%c  Tweet text present:', 'color: #657786', tweetText ? '✅ YES' : '❌ NO');    if (!isEnabled) {      console.log('%c❌ VISION ANALYSIS SKIPPED', 'color: #DC3545; font-weight: bold');      return {        success: false,        error: 'Image understanding is disabled in settings'      };    }    if (!this.apiKey) {      await this.initialize();      if (!this.apiKey) {        return {          success: false,          error: 'No API key configured'        };      }    }    const maxImages = await this.getMaxImagesPerRequest();    const imagesToAnalyze = imageUrls.slice(0, maxImages);    console.log('%c🚀 VISION ANALYSIS STARTING', 'color: #794BC4; font-weight: bold; font-size: 14px');    console.log('%c  Max images allowed:', 'color: #657786', maxImages);    console.log('%c  Images to analyze:', 'color: #657786', imagesToAnalyze.length);    console.log('%c  Images filtered out:', 'color: #657786', imageUrls.length - imagesToAnalyze.length);    try {      const modelConfig = await this.getModelConfig();      const model = this.visionModels[modelConfig.model] || this.visionModels[this.defaultModel];      console.log('%c  Vision model:', 'color: #657786', modelConfig.model);      console.log('%c  Model ID:', 'color: #657786', model.id);      console.log('%c  Estimated cost per image:', 'color: #657786', '$' + model.costPer1k + '/1K tokens');      const prompt = this.buildVisionPrompt(tweetText);      const messages = [        {          role: 'user',          content: [            {              type: 'text',              text: prompt            },            ...imagesToAnalyze.map(url => ({              type: 'image_url',              image_url: {                url: url              }            }))          ]        }      ];      const response = await this.callVisionAPI(model.id, messages);      if (response.success && response.content) {        const analysis = this.parseVisionResponse(response.content);        console.log('%c✅ VISION ANALYSIS COMPLETE', 'color: #17BF63; font-weight: bold; font-size: 14px');        console.log('%c  Success:', 'color: #657786', analysis.success ? '✅ YES' : '❌ NO');        console.log('%c  Description length:', 'color: #657786', analysis.description?.length || 0, 'characters');        console.log('%c  Objects found:', 'color: #657786', analysis.objects?.length || 0);        console.log('%c  Text in image:', 'color: #657786', analysis.text ? '✅ YES' : '❌ NO');        console.log('%c  Sentiment:', 'color: #657786', analysis.sentiment || 'neutral');        console.log('%c  Context provided:', 'color: #657786', analysis.context ? '✅ YES' : '❌ NO');        console.log('%c  Full description:', 'color: #657786', analysis.description?.substring(0, 200) + (analysis.description && analysis.description.length > 200 ? '...' : ''));        return analysis;      } else {        console.error('Vision API error:', response.error);        return {          success: false,          error: response.error || 'Failed to analyze images'        };      }    } catch (error) {      console.error('Vision service error:', error);      return {        success: false,        error: error instanceof Error ? error.message : 'Unknown error'      };    }  }  /**   * Build the vision analysis prompt   */  private buildVisionPrompt(tweetText?: string): string {    let prompt = `Analyze these images and provide a concise description for understanding the context of a Twitter conversation.Focus on:1. What's shown in the image(s)2. Any text visible in the images3. The overall sentiment or mood4. Key objects, people, or scenes5. Any memes, jokes, or cultural referencesKeep the description under 150 words and focus on details relevant for crafting a contextual reply.`;    if (tweetText) {      prompt += `\n\nThe tweet text accompanying these images is: "${tweetText}"`;      prompt += `\nConsider how the images relate to or enhance the tweet text.`;    }    prompt += `\n\nProvide the analysis in this JSON format:{  "description": "overall description of what's shown",  "objects": ["list", "of", "key", "objects"],  "text": "any text visible in the images",  "sentiment": "positive/neutral/negative",  "context": "relevant context for replying to this tweet"}`;    return prompt;  }  /**   * Call the vision API   */  private async callVisionAPI(modelId: string, messages: any[]): Promise<{    success: boolean;    content?: string;    error?: string;  }> {    try {      const response = await chrome.runtime.sendMessage({        type: MessageType.ANALYZE_IMAGES,        modelId,        messages      });      if (response.success && response.content) {        return { success: true, content: response.content };      } else {        return {           success: false,           error: response.error || 'Failed to analyze images'         };      }    } catch (error) {      console.error('Vision API call failed:', error);      return {        success: false,        error: error instanceof Error ? error.message : 'Network error'      };    }  }  /**   * Parse the vision API response   */  private parseVisionResponse(content: string): VisionAnalysisResult {    try {      const jsonMatch = content.match(/\{[\s\S]*\}/);      if (jsonMatch) {        const parsed = JSON.parse(jsonMatch[0]);        return {          success: true,          description: parsed.description || content,          objects: parsed.objects || [],          text: parsed.text || undefined,          sentiment: parsed.sentiment || 'neutral',          context: parsed.context || parsed.description        };      }      return {        success: true,        description: content,        context: content,        sentiment: 'neutral'      };    } catch (error) {      return {        success: true,        description: content,        context: content,        sentiment: 'neutral'      };    }  }  /**   * Get configured vision model   */  private async getModelConfig(): Promise<{ model: string }> {    const config = await ConfigurationManager.getInstance().getConfig();    const visionModel = config.features?.imageUnderstanding?.model || this.defaultModel;    if (!this.visionModels[visionModel]) {      console.warn(`Invalid vision model ${visionModel}, using default`);      return { model: this.defaultModel };    }    return { model: visionModel };  }  /**   * Get max images per request (cost control)   */  private async getMaxImagesPerRequest(): Promise<number> {    const config = await ConfigurationManager.getInstance().getConfig();    return config.features?.imageUnderstanding?.maxImagesPerRequest || 2;   }  /**   * Format vision context for inclusion in reply prompt   */  static formatVisionContext(analysis: VisionAnalysisResult): string {    if (!analysis.success || !analysis.description) {      return '';    }    let context = `\n\n[Visual Context: ${analysis.description}`;    if (analysis.objects && analysis.objects.length > 0) {      context += ` Key elements: ${analysis.objects.slice(0, 5).join(', ')}.`;    }    if (analysis.text) {      context += ` Text in image: "${analysis.text}".`;    }    if (analysis.sentiment && analysis.sentiment !== 'neutral') {      context += ` Mood: ${analysis.sentiment}.`;    }    context += ']';    return context;  }  /**   * Check if URL is an image that should be analyzed   */  static shouldAnalyzeImage(url: string): boolean {    if (url.includes('profile_images') ||         url.includes('emoji') ||         url.includes('icon') ||        url.includes('avatar')) {      return false;    }    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];    const urlLower = url.toLowerCase();    return imageExtensions.some(ext => urlLower.includes(ext)) ||           url.includes('pbs.twimg.com') ||           url.includes('ton.twitter.com');  }  /**   * Estimate cost for analyzing images   */  estimateCost(imageCount: number, modelName?: string): number {    const model = this.visionModels[modelName || this.defaultModel];    if (!model) return 0;    const estimatedTokens = imageCount * 200;    const cost = (estimatedTokens / 1000) * model.costPer1k;    return Math.round(cost * 1000) / 1000;   }}export const visionService = VisionService.getInstance();
```

ui\toneIntensity.ts
```ts
/** * Tone Intensity Slider Component for TweetCraft * Adjustable intensity for tone application */import { Tone } from '@/config/templatesAndTones';import { visualFeedback } from './visualFeedback';interface IntensityLevel {  value: number;  label: string;  temperature: number;  description: string;}interface IntensityChangeEvent {  toneId: string;  intensity: number;  temperature: number;  label: string;}export class ToneIntensitySlider {  private container: HTMLElement | null = null;  private currentTone: Tone | null = null;  private currentIntensity: number = 0.5;  private onChangeCallback: ((event: IntensityChangeEvent) => void) | null = null;  private readonly intensityLevels: IntensityLevel[] = [    {      value: 0,      label: 'Subtle',      temperature: 0.3,      description: 'Barely noticeable, very mild'    },    {      value: 0.25,      label: 'Light',      temperature: 0.5,      description: 'Gentle touch of the tone'    },    {      value: 0.5,      label: 'Balanced',      temperature: 0.7,      description: 'Natural, well-balanced'    },    {      value: 0.75,      label: 'Strong',      temperature: 0.85,      description: 'Pronounced and clear'    },    {      value: 1,      label: 'Maximum',      temperature: 1.0,      description: 'Full intensity, unrestrained'    }  ];  constructor() {    console.log('%c🎚️ ToneIntensitySlider initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Create the intensity slider component   */  create(tone: Tone, onChange: (event: IntensityChangeEvent) => void): HTMLElement {    this.currentTone = tone;    this.onChangeCallback = onChange;    this.container = document.createElement('div');    this.container.className = 'tweetcraft-tone-intensity';    this.render();    this.applyStyles();    return this.container;  }  /**   * Render the slider UI   */  private render(): void {    if (!this.container || !this.currentTone) return;    const currentLevel = this.getCurrentLevel();    this.container.innerHTML = `      <div class="intensity-header">        <span class="intensity-tone">          ${this.currentTone.emoji} ${this.currentTone.label}        </span>        <span class="intensity-level">${currentLevel.label}</span>      </div>      <div class="intensity-slider-container">        <div class="intensity-track">          <div class="intensity-fill" style="width: ${this.currentIntensity * 100}%"></div>          <div class="intensity-markers">            ${this.intensityLevels.map(level => `              <div class="intensity-marker ${this.currentIntensity === level.value ? 'active' : ''}"                   data-value="${level.value}"                   style="left: ${level.value * 100}%">                <div class="marker-dot"></div>                <div class="marker-label">${level.label}</div>              </div>            `).join('')}          </div>          <input type="range"                  class="intensity-slider"                 min="0"                  max="1"                  step="0.01"                 value="${this.currentIntensity}">        </div>      </div>      <div class="intensity-description">        ${currentLevel.description}      </div>      <div class="intensity-preview">        <div class="preview-label">Preview</div>        <div class="preview-text">${this.generatePreview()}</div>      </div>      <div class="intensity-presets">        ${this.renderPresets()}      </div>    `;    this.attachEventListeners();  }  /**   * Render preset buttons   */  private renderPresets(): string {    const presets = [      { value: 0, emoji: '🌱', label: 'Subtle' },      { value: 0.5, emoji: '⚖️', label: 'Balanced' },      { value: 1, emoji: '🔥', label: 'Maximum' }    ];    return presets.map(preset => `      <button class="intensity-preset ${this.currentIntensity === preset.value ? 'active' : ''}"              data-value="${preset.value}">        <span class="preset-emoji">${preset.emoji}</span>        <span class="preset-label">${preset.label}</span>      </button>    `).join('');  }  /**   * Attach event listeners   */  private attachEventListeners(): void {    if (!this.container) return;    const slider = this.container.querySelector('.intensity-slider') as HTMLInputElement;    if (slider) {      slider.addEventListener('input', (e) => {        this.updateIntensity(parseFloat((e.target as HTMLInputElement).value));      });      slider.addEventListener('change', () => {        this.notifyChange();      });    }    this.container.querySelectorAll('.intensity-marker').forEach(marker => {      marker.addEventListener('click', (e) => {        const value = parseFloat((e.currentTarget as HTMLElement).dataset.value || '0.5');        this.updateIntensity(value);        this.notifyChange();      });    });    this.container.querySelectorAll('.intensity-preset').forEach(btn => {      btn.addEventListener('click', (e) => {        const value = parseFloat((e.currentTarget as HTMLElement).dataset.value || '0.5');        this.animateToValue(value);      });    });  }  /**   * Update intensity value   */  private updateIntensity(value: number): void {    this.currentIntensity = Math.max(0, Math.min(1, value));    if (!this.container) return;    const fill = this.container.querySelector('.intensity-fill') as HTMLElement;    if (fill) {      fill.style.width = `${this.currentIntensity * 100}%`;    }    const currentLevel = this.getCurrentLevel();    const levelText = this.container.querySelector('.intensity-level');    if (levelText) {      levelText.textContent = currentLevel.label;    }    const description = this.container.querySelector('.intensity-description');    if (description) {      description.textContent = currentLevel.description;    }    const preview = this.container.querySelector('.preview-text');    if (preview) {      preview.textContent = this.generatePreview();    }    this.container.querySelectorAll('.intensity-marker').forEach(marker => {      const markerValue = parseFloat((marker as HTMLElement).dataset.value || '0');      marker.classList.toggle('active', Math.abs(markerValue - this.currentIntensity) < 0.05);    });    this.container.querySelectorAll('.intensity-preset').forEach(btn => {      const presetValue = parseFloat((btn as HTMLElement).dataset.value || '0');      btn.classList.toggle('active', Math.abs(presetValue - this.currentIntensity) < 0.05);    });    visualFeedback.pulse(fill, this.getIntensityColor());  }  /**   * Animate slider to value   */  private animateToValue(targetValue: number): void {    const startValue = this.currentIntensity;    const duration = 300;    const startTime = performance.now();    const animate = (currentTime: number) => {      const elapsed = currentTime - startTime;      const progress = Math.min(elapsed / duration, 1);      const easeProgress = progress < 0.5        ? 2 * progress * progress        : 1 - Math.pow(-2 * progress + 2, 2) / 2;      const currentValue = startValue + (targetValue - startValue) * easeProgress;      this.updateIntensity(currentValue);      if (progress < 1) {        requestAnimationFrame(animate);      } else {        this.notifyChange();        visualFeedback.showSuccess(this.container!, `Intensity set to ${this.getCurrentLevel().label}`);      }    };    requestAnimationFrame(animate);  }  /**   * Get current intensity level   */  private getCurrentLevel(): IntensityLevel {    let closest = this.intensityLevels[0];    let minDiff = Math.abs(this.currentIntensity - closest.value);    for (const level of this.intensityLevels) {      const diff = Math.abs(this.currentIntensity - level.value);      if (diff < minDiff) {        minDiff = diff;        closest = level;      }    }    const temperature = this.interpolateTemperature();    return {      ...closest,      temperature    };  }  /**   * Interpolate temperature based on intensity   */  private interpolateTemperature(): number {    return 0.3 + (this.currentIntensity * 0.7);  }  /**   * Get color based on intensity   */  private getIntensityColor(): string {    const hue = 200 - (this.currentIntensity * 60);     const saturation = 50 + (this.currentIntensity * 30);    const lightness = 50;    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;  }  /**   * Generate preview text   */  private generatePreview(): string {    if (!this.currentTone) return '';    const previews: Record<string, string[]> = {      professional: [        'I appreciate your perspective on this matter.',        'Thank you for sharing your insights.',        'I believe this warrants further consideration.',        'Your point is well-taken and deserves discussion.',        'This is indeed a significant development.'      ],      witty: [        'Well, this is interesting!',        'Plot twist: you\'re absolutely right!',        'Clever observation there!',        'Now that\'s what I call thinking outside the box!',        'Brilliantly put, I must say!'      ],      sarcastic: [        'Oh, how delightful.',        'Well, isn\'t that just perfect?',        'Shocking. Truly shocking.',        'Never saw that coming. Not at all.',        'What a surprise. I\'m stunned.'      ]    };    const tonePreview = previews[this.currentTone.id] || previews.professional;    const index = Math.floor(this.currentIntensity * (tonePreview.length - 1));    return tonePreview[index];  }  /**   * Notify change callback   */  private notifyChange(): void {    if (!this.currentTone || !this.onChangeCallback) return;    const level = this.getCurrentLevel();    this.onChangeCallback({      toneId: this.currentTone.id,      intensity: this.currentIntensity,      temperature: level.temperature,      label: level.label    });    console.log('%c🎚️ Intensity changed:', 'color: #1DA1F2', {      tone: this.currentTone.label,      intensity: this.currentIntensity,      temperature: level.temperature,      label: level.label    });  }  /**   * Set intensity programmatically   */  setIntensity(value: number): void {    this.updateIntensity(value);    this.notifyChange();  }  /**   * Get current intensity   */  getIntensity(): number {    return this.currentIntensity;  }  /**   * Get temperature for current intensity   */  getTemperature(): number {    return this.interpolateTemperature();  }  /**   * Apply styles   */  private applyStyles(): void {    if (!document.querySelector('#tweetcraft-intensity-styles')) {      const style = document.createElement('style');      style.id = 'tweetcraft-intensity-styles';      style.textContent = `        .tweetcraft-tone-intensity {          background: #15202b;          border: 1px solid rgba(139, 152, 165, 0.3);          border-radius: 12px;          padding: 16px;          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;        }        .intensity-header {          display: flex;          justify-content: space-between;          align-items: center;          margin-bottom: 16px;        }        .intensity-tone {          font-size: 16px;          font-weight: 600;          color: #e7e9ea;        }        .intensity-level {          padding: 4px 12px;          background: rgba(29, 155, 240, 0.2);          border-radius: 12px;          font-size: 12px;          color: #1d9bf0;          font-weight: 500;        }        .intensity-slider-container {          position: relative;          margin: 24px 0;        }        .intensity-track {          position: relative;          height: 40px;        }        .intensity-fill {          position: absolute;          top: 50%;          transform: translateY(-50%);          height: 6px;          background: linear-gradient(90deg, #657786, #1d9bf0);          border-radius: 3px;          transition: width 0.1s ease;        }        .intensity-markers {          position: absolute;          top: 50%;          transform: translateY(-50%);          width: 100%;          height: 6px;        }        .intensity-marker {          position: absolute;          transform: translateX(-50%);          cursor: pointer;          transition: all 0.2s;        }        .marker-dot {          width: 16px;          height: 16px;          background: #15202b;          border: 2px solid #657786;          border-radius: 50%;          margin: 0 auto;          transition: all 0.2s;        }        .intensity-marker.active .marker-dot,        .intensity-marker:hover .marker-dot {          width: 20px;          height: 20px;          border-color: #1d9bf0;          background: #1d9bf0;        }        .marker-label {          position: absolute;          top: 24px;          left: 50%;          transform: translateX(-50%);          font-size: 10px;          color: #657786;          white-space: nowrap;        }        .intensity-slider {          position: absolute;          top: 50%;          transform: translateY(-50%);          width: 100%;          height: 20px;          background: transparent;          cursor: pointer;          -webkit-appearance: none;          appearance: none;          opacity: 0;        }        .intensity-description {          text-align: center;          color: #8b98a5;          font-size: 13px;          margin: 16px 0;          font-style: italic;        }        .intensity-preview {          background: rgba(255, 255, 255, 0.03);          border: 1px solid rgba(139, 152, 165, 0.2);          border-radius: 8px;          padding: 12px;          margin: 16px 0;        }        .preview-label {          font-size: 11px;          color: #657786;          text-transform: uppercase;          margin-bottom: 8px;        }        .preview-text {          color: #e7e9ea;          font-size: 14px;          line-height: 1.4;        }        .intensity-presets {          display: flex;          gap: 8px;          justify-content: center;        }        .intensity-preset {          display: flex;          align-items: center;          gap: 6px;          padding: 8px 16px;          background: rgba(255, 255, 255, 0.03);          border: 1px solid rgba(139, 152, 165, 0.3);          border-radius: 20px;          color: #e7e9ea;          cursor: pointer;          transition: all 0.2s;        }        .intensity-preset:hover {          background: rgba(29, 155, 240, 0.1);          border-color: rgba(29, 155, 240, 0.5);        }        .intensity-preset.active {          background: rgba(29, 155, 240, 0.2);          border-color: #1d9bf0;        }        .preset-emoji {          font-size: 16px;        }        .preset-label {          font-size: 12px;          font-weight: 500;        }      `;      document.head.appendChild(style);    }  }  /**   * Destroy the component   */  destroy(): void {    this.container?.remove();    this.container = null;    this.currentTone = null;    this.onChangeCallback = null;    console.log('%c🎚️ ToneIntensitySlider destroyed', 'color: #FFA500');  }}export const toneIntensitySlider = new ToneIntensitySlider();
```

ui\visualFeedback.ts
```ts
/** * Visual Feedback System for TweetCraft * Provides visual indicators for user actions */interface FeedbackOptions {  duration?: number;  position?: 'top' | 'bottom' | 'center';  type?: 'success' | 'error' | 'info' | 'warning';  persistent?: boolean;}interface Toast {  id: string;  message: string;  type: string;  timestamp: number;  element?: HTMLElement;}export class VisualFeedback {  private toasts: Map<string, Toast> = new Map();  private container: HTMLElement | null = null;  private loadingOverlay: HTMLElement | null = null;  private pulseElements: WeakSet<HTMLElement> = new WeakSet();  private initialized = false;  constructor() {    this.initialize();  }  /**   * Initialize feedback system   */  private initialize(): void {    if (this.initialized) return;    this.createContainer();    this.applyStyles();    this.initialized = true;    console.log('%c✨ VisualFeedback initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Create container for toasts   */  private createContainer(): void {    this.container = document.createElement('div');    this.container.className = 'tweetcraft-feedback-container';    this.container.setAttribute('aria-live', 'polite');    this.container.setAttribute('aria-atomic', 'true');    document.body.appendChild(this.container);  }  /**   * Show toast notification   */  showToast(message: string, options: FeedbackOptions = {}): string {    const id = `toast_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;    const type = options.type || 'info';    const duration = options.duration || 3000;    const position = options.position || 'bottom';    const toastElement = this.createToastElement(message, type);    const toast: Toast = {      id,      message,      type,      timestamp: Date.now(),      element: toastElement    };    this.toasts.set(id, toast);    this.positionToast(toastElement, position);    this.container?.appendChild(toastElement);    requestAnimationFrame(() => {      toastElement.classList.add('show');    });    if (!options.persistent) {      setTimeout(() => this.removeToast(id), duration);    }    console.log(`%c✨ Toast shown: ${message}`, 'color: #17BF63');    return id;  }  /**   * Create toast element   */  private createToastElement(message: string, type: string): HTMLElement {    const toast = document.createElement('div');    toast.className = `tweetcraft-toast tweetcraft-toast-${type}`;    const icon = this.getIcon(type);    const closeBtn = this.createCloseButton();    toast.innerHTML = `      <span class="toast-icon">${icon}</span>      <span class="toast-message">${message}</span>    `;    toast.appendChild(closeBtn);    return toast;  }  /**   * Position toast   */  private positionToast(element: HTMLElement, position: string): void {    element.setAttribute('data-position', position);  }  /**   * Remove toast   */  removeToast(id: string): void {    const toast = this.toasts.get(id);    if (toast && toast.element) {      toast.element.classList.add('hide');      setTimeout(() => {        toast.element?.remove();        this.toasts.delete(id);      }, 300);    }  }  /**   * Show loading overlay (deprecated - now just logs)   */  showLoading(message: string = 'Loading...'): void {    console.log('%c⏳ Loading:', 'color: #FFA500', message);  }  /**   * Hide loading overlay (deprecated - now just logs)   */  hideLoading(): void {    console.log('%c✅ Loading complete', 'color: #17BF63');  }  /**   * Pulse animation for element   */  pulse(element: HTMLElement, color?: string): void {    if (this.pulseElements.has(element)) return;    this.pulseElements.add(element);    element.classList.add('tweetcraft-pulse');    if (color) {      element.style.setProperty('--pulse-color', color);    }    setTimeout(() => {      element.classList.remove('tweetcraft-pulse');      this.pulseElements.delete(element);    }, 600);  }  /**   * Shake animation for errors   */  shake(element: HTMLElement): void {    element.classList.add('tweetcraft-shake');    setTimeout(() => {      element.classList.remove('tweetcraft-shake');    }, 500);  }  /**   * Slide in animation   */  slideIn(element: HTMLElement, direction: 'left' | 'right' | 'top' | 'bottom' = 'bottom'): void {    element.classList.add('tweetcraft-slide-in', `from-${direction}`);    setTimeout(() => {      element.classList.remove('tweetcraft-slide-in', `from-${direction}`);    }, 500);  }  /**   * Fade in/out   */  fade(element: HTMLElement, fadeIn: boolean = true): Promise<void> {    return new Promise(resolve => {      if (fadeIn) {        element.classList.add('tweetcraft-fade-in');        element.classList.remove('tweetcraft-fade-out');      } else {        element.classList.add('tweetcraft-fade-out');        element.classList.remove('tweetcraft-fade-in');      }      setTimeout(resolve, 300);    });  }  /**   * Show success animation   */  showSuccess(element: HTMLElement, message?: string): void {    const successIcon = document.createElement('div');    successIcon.className = 'tweetcraft-success-icon';    successIcon.innerHTML = '✓';    const rect = element.getBoundingClientRect();    successIcon.style.left = `${rect.left + rect.width / 2}px`;    successIcon.style.top = `${rect.top + rect.height / 2}px`;    document.body.appendChild(successIcon);    requestAnimationFrame(() => {      successIcon.classList.add('show');    });    setTimeout(() => {      successIcon.remove();    }, 1500);    if (message) {      this.showToast(message, { type: 'success' });    }  }  /**   * Show error animation   */  showError(element: HTMLElement, message?: string): void {    this.shake(element);    element.classList.add('tweetcraft-error-highlight');    setTimeout(() => {      element.classList.remove('tweetcraft-error-highlight');    }, 2000);    if (message) {      this.showToast(message, { type: 'error' });    }  }  /**   * Highlight element   */  highlight(element: HTMLElement, duration: number = 2000): void {    element.classList.add('tweetcraft-highlight');    setTimeout(() => {      element.classList.remove('tweetcraft-highlight');    }, duration);  }  /**   * Show progress bar   */  showProgress(progress: number, message?: string): void {    let progressBar = document.querySelector('.tweetcraft-progress-bar') as HTMLElement;    if (!progressBar) {      progressBar = document.createElement('div');      progressBar.className = 'tweetcraft-progress-bar';      progressBar.innerHTML = `        <div class="progress-fill"></div>        <div class="progress-message"></div>      `;      document.body.appendChild(progressBar);    }    const fill = progressBar.querySelector('.progress-fill') as HTMLElement;    const messageEl = progressBar.querySelector('.progress-message') as HTMLElement;    fill.style.width = `${Math.min(100, Math.max(0, progress))}%`;    if (message) {      messageEl.textContent = message;    }    progressBar.classList.add('show');    if (progress >= 100) {      setTimeout(() => {        progressBar.classList.remove('show');        setTimeout(() => progressBar.remove(), 300);      }, 500);    }  }  /**   * Create close button   */  private createCloseButton(): HTMLElement {    const btn = document.createElement('button');    btn.className = 'toast-close';    btn.innerHTML = '×';    btn.onclick = (e) => {      const toast = (e.target as HTMLElement).closest('.tweetcraft-toast');      const id = Array.from(this.toasts.entries())        .find(([_, t]) => t.element === toast)?.[0];      if (id) {        this.removeToast(id);      }    };    return btn;  }  /**   * Get icon for type   */  private getIcon(type: string): string {    const icons: Record<string, string> = {      success: '✓',      error: '✕',      warning: '⚠',      info: 'ℹ'    };    return icons[type] || icons.info;  }  /**   * Apply styles   */  private applyStyles(): void {    if (!document.querySelector('#tweetcraft-feedback-styles')) {      const style = document.createElement('style');      style.id = 'tweetcraft-feedback-styles';      style.textContent = `        .tweetcraft-feedback-container {          position: fixed;          bottom: 20px;          right: 20px;          z-index: 10000;          display: flex;          flex-direction: column;          gap: 10px;          pointer-events: none;        }        .tweetcraft-toast {          display: flex;          align-items: center;          gap: 10px;          padding: 12px 16px;          background: #15202b;          border: 1px solid rgba(139, 152, 165, 0.3);          border-radius: 8px;          color: #e7e9ea;          font-size: 14px;          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);          transform: translateX(400px);          transition: transform 0.3s ease, opacity 0.3s ease;          pointer-events: auto;        }        .tweetcraft-toast.show {          transform: translateX(0);        }        .tweetcraft-toast.hide {          opacity: 0;          transform: translateX(400px);        }        .tweetcraft-toast-success {          border-color: #17BF63;          background: linear-gradient(135deg, #15202b, rgba(23, 191, 99, 0.1));        }        .tweetcraft-toast-error {          border-color: #DC3545;          background: linear-gradient(135deg, #15202b, rgba(220, 53, 69, 0.1));        }        .tweetcraft-toast-warning {          border-color: #FFA500;          background: linear-gradient(135deg, #15202b, rgba(255, 165, 0, 0.1));        }        .toast-icon {          font-size: 18px;        }        .toast-close {          margin-left: auto;          background: none;          border: none;          color: #8b98a5;          font-size: 20px;          cursor: pointer;          padding: 0 4px;          transition: color 0.2s;        }        .toast-close:hover {          color: #e7e9ea;        }        /* Loading overlay removed - now using button-only loading animation */        .tweetcraft-pulse {          animation: pulse 0.6s ease;        }        @keyframes pulse {          0%, 100% { transform: scale(1); }          50% { transform: scale(1.05); box-shadow: 0 0 20px var(--pulse-color, #1d9bf0); }        }        .tweetcraft-shake {          animation: shake 0.5s ease;        }        @keyframes shake {          0%, 100% { transform: translateX(0); }          25% { transform: translateX(-10px); }          75% { transform: translateX(10px); }        }        .tweetcraft-highlight {          animation: highlight 2s ease;        }        @keyframes highlight {          0%, 100% { background-color: transparent; }          50% { background-color: rgba(29, 155, 240, 0.2); }        }        .tweetcraft-error-highlight {          animation: error-highlight 2s ease;        }        @keyframes error-highlight {          0%, 100% { background-color: transparent; }          50% { background-color: rgba(220, 53, 69, 0.2); }        }        .tweetcraft-success-icon {          position: fixed;          width: 60px;          height: 60px;          background: #17BF63;          border-radius: 50%;          display: flex;          align-items: center;          justify-content: center;          color: white;          font-size: 30px;          font-weight: bold;          transform: translate(-50%, -50%) scale(0);          opacity: 0;          z-index: 10002;          transition: all 0.3s ease;        }        .tweetcraft-success-icon.show {          transform: translate(-50%, -50%) scale(1);          opacity: 1;        }        .tweetcraft-progress-bar {          position: fixed;          top: 0;          left: 0;          right: 0;          height: 4px;          background: rgba(139, 152, 165, 0.2);          z-index: 10000;          opacity: 0;          transition: opacity 0.3s;        }        .tweetcraft-progress-bar.show {          opacity: 1;        }        .progress-fill {          height: 100%;          background: linear-gradient(90deg, #1d9bf0, #17BF63);          transition: width 0.3s ease;        }        .progress-message {          position: absolute;          top: 8px;          left: 50%;          transform: translateX(-50%);          font-size: 12px;          color: #e7e9ea;          background: #15202b;          padding: 2px 8px;          border-radius: 4px;        }        .tweetcraft-slide-in {          animation: slideIn 0.5s ease;        }        @keyframes slideIn {          from { opacity: 0; transform: translateY(20px); }          to { opacity: 1; transform: translateY(0); }        }        .tweetcraft-fade-in {          animation: fadeIn 0.3s ease;        }        @keyframes fadeIn {          from { opacity: 0; }          to { opacity: 1; }        }        .tweetcraft-fade-out {          animation: fadeOut 0.3s ease;        }        @keyframes fadeOut {          from { opacity: 1; }          to { opacity: 0; }        }      `;      document.head.appendChild(style);    }  }  /**   * Clean up   */  destroy(): void {    this.toasts.forEach(toast => {      toast.element?.remove();    });    this.toasts.clear();    this.container?.remove();    this.loadingOverlay?.remove();    const style = document.querySelector('#tweetcraft-feedback-styles');    style?.remove();    console.log('%c✨ VisualFeedback destroyed', 'color: #FFA500');  }}export const visualFeedback = new VisualFeedback();
```

utils\__tests__\textUtils.test.ts
```ts
/** * Tests for text processing utilities */import {   cleanupReply,   truncateText,   escapeHtml,   extractHashtags,  extractMentions,  countTwitterCharacters,  isWithinTwitterLimit,  removeEmoji,  normalizeLineBreaks} from '../textUtils';describe('textUtils', () => {  describe('cleanupReply', () => {    it('should remove surrounding quotes', () => {      expect(cleanupReply('"This is a reply"')).toBe('This is a reply');      expect(cleanupReply("'This is a reply'")).toBe('This is a reply');    });    it('should remove AI meta-text prefixes', () => {      expect(cleanupReply('Reply: This is the actual reply')).toBe('This is the actual reply');      expect(cleanupReply('Response: This is the actual reply')).toBe('This is the actual reply');      expect(cleanupReply('Answer: This is the actual reply')).toBe('This is the actual reply');    });    it('should clean up excessive whitespace', () => {      expect(cleanupReply('This  has   too    much     space')).toBe('This has too much space');      expect(cleanupReply('\n\nMultiple\n\nlines\n\n')).toBe('Multiple lines');    });    it('should remove trailing hashtags', () => {      expect(cleanupReply('Great point! #AI #Tech #Innovation')).toBe('Great point!');      expect(cleanupReply('Check this out #amazing')).toBe('Check this out');    });    it('should prefix @ mentions to prevent blocking', () => {      expect(cleanupReply('@user This is a reply')).toBe('.@user This is a reply');    });    it('should handle complex cases', () => {      const input = '"Reply: Great point! #AI #Tech"';      const expected = '.Great point!';      expect(cleanupReply('@' + cleanupReply(input))).toBe(expected);    });  });  describe('truncateText', () => {    it('should not truncate text within limit', () => {      expect(truncateText('Short text', 20)).toBe('Short text');    });    it('should truncate at word boundary', () => {      expect(truncateText('This is a very long text that needs truncation', 20))        .toBe('This is a very long...');    });    it('should handle text without spaces', () => {      expect(truncateText('Verylongtextwithoutspaces', 10))        .toBe('Verylongte...');    });  });  describe('escapeHtml', () => {    it('should escape HTML special characters', () => {      expect(escapeHtml('<script>alert("XSS")</script>'))        .toBe('&lt;script&gt;alert(&quot;XSS&quot;)&lt;&#x2F;script&gt;');    });    it('should escape single quotes', () => {      expect(escapeHtml("It's a test")).toBe('It&#x27;s a test');    });    it('should handle multiple special characters', () => {      expect(escapeHtml('& < > " \' /')).toBe('&amp; &lt; &gt; &quot; &#x27; &#x2F;');    });  });  describe('extractHashtags', () => {    it('should extract hashtags from text', () => {      const text = 'Check out #TweetCraft for #AI powered replies!';      expect(extractHashtags(text)).toEqual(['#tweetcraft', '#ai']);    });    it('should return empty array when no hashtags', () => {      expect(extractHashtags('No hashtags here')).toEqual([]);    });    it('should handle multiple hashtags together', () => {      expect(extractHashtags('#web3 #crypto #blockchain'))        .toEqual(['#web3', '#crypto', '#blockchain']);    });  });  describe('extractMentions', () => {    it('should extract mentions from text', () => {      const text = '@user1 Thanks! CC @user2 @user3';      expect(extractMentions(text)).toEqual(['@user1', '@user2', '@user3']);    });    it('should return empty array when no mentions', () => {      expect(extractMentions('No mentions here')).toEqual([]);    });  });  describe('countTwitterCharacters', () => {    it('should count regular text normally', () => {      expect(countTwitterCharacters('Hello world')).toBe(11);    });    it('should count URLs as 23 characters', () => {      const text = 'Check this out: https://www.example.com/very/long/url/path';      expect(countTwitterCharacters(text)).toBe(39);     });    it('should handle multiple URLs', () => {      const text = 'https://example.com and https://another.com';      expect(countTwitterCharacters(text)).toBe(50);     });  });  describe('isWithinTwitterLimit', () => {    it('should return true for text within limit', () => {      expect(isWithinTwitterLimit('Short tweet')).toBe(true);    });    it('should return false for text exceeding limit', () => {      const longText = 'a'.repeat(281);      expect(isWithinTwitterLimit(longText)).toBe(false);    });    it('should handle custom limits', () => {      expect(isWithinTwitterLimit('12345', 5)).toBe(true);      expect(isWithinTwitterLimit('123456', 5)).toBe(false);    });  });  describe('removeEmoji', () => {    it('should remove emoji from text', () => {      expect(removeEmoji('Hello 😊 World 🌍!')).toBe('Hello  World !');    });    it('should handle text without emoji', () => {      expect(removeEmoji('No emoji here')).toBe('No emoji here');    });    it('should remove multiple emoji types', () => {      expect(removeEmoji('🚀 Launch 💼 Work ✨ Magic')).toBe(' Launch  Work  Magic');    });  });  describe('normalizeLineBreaks', () => {    it('should normalize Windows line breaks', () => {      expect(normalizeLineBreaks('Line1\r\nLine2\r\nLine3'))        .toBe('Line1\nLine2\nLine3');    });    it('should normalize Mac line breaks', () => {      expect(normalizeLineBreaks('Line1\rLine2\rLine3'))        .toBe('Line1\nLine2\nLine3');    });    it('should handle mixed line breaks', () => {      expect(normalizeLineBreaks('Line1\r\nLine2\rLine3\nLine4'))        .toBe('Line1\nLine2\nLine3\nLine4');    });  });});
```

utils\asyncOperationManager.ts
```ts
/** * Async Operation Manager * Prevents race conditions by coordinating async operations with AbortController */export class AsyncOperationManager {  private operations = new Map<string, AbortController>();  /**   * Execute an async operation with automatic cancellation of conflicting operations   */  async execute<T>(key: string, operation: (signal: AbortSignal) => Promise<T>): Promise<T> {    console.log('%c🔄 ASYNC OPERATION MANAGER', 'color: #9146FF; font-weight: bold; font-size: 14px');    console.log('%c  Starting operation:', 'color: #657786', key);    if (this.operations.has(key)) {      const existingController = this.operations.get(key)!;      console.log('%c  ⚠️ Cancelling conflicting operation:', 'color: #FFA500; font-weight: bold', key);      existingController.abort();      this.operations.delete(key);    }    const controller = new AbortController();    this.operations.set(key, controller);    console.log('%c  ✅ Operation registered:', 'color: #17BF63; font-weight: bold',                `Active operations: ${this.operations.size}`);    try {      const startTime = performance.now();      const result = await operation(controller.signal);      const duration = performance.now() - startTime;      console.log('%c  🎯 Operation completed:', 'color: #17BF63; font-weight: bold',                  `${key} (${Math.round(duration)}ms)`);      return result;    } catch (error) {      if (error instanceof Error && error.name === 'AbortError') {        console.log('%c  ⏹️ Operation cancelled:', 'color: #657786', key);        throw new Error(`Operation ${key} was cancelled`);      } else {        console.log('%c  ❌ Operation failed:', 'color: #DC3545; font-weight: bold', key, error);        throw error;      }    } finally {      this.operations.delete(key);      console.log('%c  🧹 Operation cleaned up:', 'color: #657786',                  `${key} - Active operations: ${this.operations.size}`);    }  }  /**   * Cancel a specific operation by key   */  cancel(key: string): boolean {    const controller = this.operations.get(key);    if (controller) {      console.log('%c🛑 Manual cancellation:', 'color: #FFA500; font-weight: bold', key);      controller.abort();      this.operations.delete(key);      return true;    }    return false;  }  /**   * Cancel all active operations   */  cancelAll(): void {    console.log('%c🛑 Cancelling all operations:', 'color: #DC3545; font-weight: bold',                `${this.operations.size} operations`);    for (const [key, controller] of this.operations.entries()) {      controller.abort();      console.log('%c  Cancelled:', 'color: #657786', key);    }    this.operations.clear();    console.log('%c✅ All operations cancelled', 'color: #17BF63; font-weight: bold');  }  /**   * Check if an operation is currently active   */  isActive(key: string): boolean {    return this.operations.has(key);  }  /**   * Get count of active operations   */  getActiveCount(): number {    return this.operations.size;  }  /**   * Get list of active operation keys   */  getActiveOperations(): string[] {    return Array.from(this.operations.keys());  }  /**   * Get operation statistics   */  getStats() {    const activeOperations = this.getActiveOperations();    return {      activeCount: this.operations.size,      activeOperations,      totalMemoryUsage: activeOperations.length * 64     };  }}export const globalAsyncManager = new AsyncOperationManager();
```

utils\contextExtractor.ts
```ts
/** * Context Extractor - Enhanced with Image Understanding * Extracts tweet content including text, author, thread context, and images */import { DOMUtils } from '@/content/domUtils';export interface ImageContext {  url: string;  alt?: string;  type: 'image' | 'gif' | 'video-thumbnail';  width?: number;  height?: number;}export interface TweetContext {  tweetId?: string;  tweetText: string;  authorHandle?: string;  authorName?: string;  threadContext?: Array<{author: string; text: string}>;  images?: ImageContext[];  hasVideo?: boolean;  videoThumbnail?: string;}export class ContextExtractor {  /**   * Extract complete context from a tweet including images   */  static extractFullContext(tweetElement?: Element): TweetContext {    const context: TweetContext = {      tweetText: '',      images: []    };    const tweet = tweetElement || this.findTweetContainer();    if (!tweet) {      console.log('%c❌ No tweet found for context extraction', 'color: #DC3545');      return context;    }    context.tweetId = this.extractTweetId(tweet);    const textContent = this.extractTextContent(tweet);    context.tweetText = textContent.text;    context.authorHandle = textContent.authorHandle;    context.authorName = textContent.authorName;    context.images = this.extractImages(tweet);    const videoInfo = this.extractVideoInfo(tweet);    context.hasVideo = videoInfo.hasVideo;    context.videoThumbnail = videoInfo.thumbnail;    const threadContext = DOMUtils.extractThreadContext();    if (threadContext && threadContext.length > 0) {      context.threadContext = threadContext;    }    if (typeof window !== 'undefined' && (window as any).__TWEETCRAFT_DEBUG__) {      console.log('%c📸 Image Context Extraction', 'color: #17BF63; font-weight: bold');      console.log('%c  Images found:', 'color: #657786', context.images?.length || 0);      if (context.hasVideo) {        console.log('%c  Video detected with thumbnail', 'color: #794BC4');      }    }    return context;  }  /**   * Find the tweet container element   */  private static findTweetContainer(): Element | null {    const selectors = [      'article[data-testid="tweet"][tabindex="-1"]',       'article[data-testid="tweet"]:first-of-type',         'div[data-testid="cellInnerDiv"] article'           ];    for (const selector of selectors) {      try {        const element = document.querySelector(selector);        if (element) return element;      } catch (e) {      }    }    try {      if (CSS.supports && CSS.supports('selector(:has(div))')) {        const element = document.querySelector('article[role="article"]:has([data-testid="tweetText"])');        if (element) return element;      } else {        const articles = document.querySelectorAll('article[role="article"]');        for (const article of articles) {          if (article.querySelector('[data-testid="tweetText"]')) {            return article;          }        }      }    } catch (e) {    }    return null;  }  /**   * Extract tweet ID from various sources   */  private static extractTweetId(tweet: Element): string | undefined {    const statusLink = tweet.querySelector('a[href*="/status/"]');    if (statusLink) {      const match = statusLink.getAttribute('href')?.match(/\/status\/(\d+)/);      if (match) return match[1];    }    const timeLink = tweet.querySelector('time')?.parentElement;    if (timeLink?.tagName === 'A') {      const match = timeLink.getAttribute('href')?.match(/\/status\/(\d+)/);      if (match) return match[1];    }    return undefined;  }  /**   * Extract text content and author information   */  private static extractTextContent(tweet: Element): {    text: string;    authorHandle?: string;    authorName?: string;  } {    const textElement = tweet.querySelector('[data-testid="tweetText"]') ||                       tweet.querySelector('[lang][dir="auto"]:not([contenteditable])') ||                       tweet.querySelector('div[lang] span');    const text = textElement?.textContent?.trim() || '';    const authorLink = tweet.querySelector('[data-testid="User-Name"] a[href^="/"]') ||                      tweet.querySelector('a[href^="/"][dir="ltr"]');    const authorHandle = authorLink?.getAttribute('href')?.replace('/', '') || undefined;    const authorNameElement = tweet.querySelector('[data-testid="User-Name"] span') ||                             tweet.querySelector('a[href^="/"] span[dir="auto"]');    const authorName = authorNameElement?.textContent?.trim() || undefined;    return { text, authorHandle, authorName };  }  /**   * Extract images from tweet   */  private static extractImages(tweet: Element): ImageContext[] {    const images: ImageContext[] = [];    const processedUrls = new Set<string>();    const imageContainers = tweet.querySelectorAll('[data-testid="tweetPhoto"], [data-testid="tweet_image"]');    imageContainers.forEach(container => {      const img = container.querySelector('img');      if (img && img.src) {        const cleanUrl = this.cleanImageUrl(img.src);        if (!processedUrls.has(cleanUrl)) {          processedUrls.add(cleanUrl);          images.push({            url: cleanUrl,            alt: img.alt || undefined,            type: 'image',            width: img.naturalWidth || undefined,            height: img.naturalHeight || undefined          });        }      }    });    const allImages = tweet.querySelectorAll('img[src*="pbs.twimg.com"], img[src*="ton.twitter.com"]');    allImages.forEach(img => {      const src = (img as HTMLImageElement).src;      if (src && !src.includes('profile_images') && !src.includes('emoji')) {        const cleanUrl = this.cleanImageUrl(src);        if (!processedUrls.has(cleanUrl)) {          processedUrls.add(cleanUrl);          images.push({            url: cleanUrl,            alt: (img as HTMLImageElement).alt || undefined,            type: src.includes('.gif') ? 'gif' : 'image',            width: (img as HTMLImageElement).naturalWidth || undefined,            height: (img as HTMLImageElement).naturalHeight || undefined          });        }      }    });    const cardImages = tweet.querySelectorAll('[data-testid="card.layoutLarge.media"] img, [data-testid="card.layoutSmall.media"] img');    cardImages.forEach(img => {      const src = (img as HTMLImageElement).src;      if (src) {        const cleanUrl = this.cleanImageUrl(src);        if (!processedUrls.has(cleanUrl)) {          processedUrls.add(cleanUrl);          images.push({            url: cleanUrl,            alt: (img as HTMLImageElement).alt || 'Link preview image',            type: 'image'          });        }      }    });    return images;  }  /**   * Extract video information   */  private static extractVideoInfo(tweet: Element): {    hasVideo: boolean;    thumbnail?: string;  } {    const videoPlayer = tweet.querySelector('[data-testid="videoPlayer"], [data-testid="gifPlayer"], video');    if (!videoPlayer) {      return { hasVideo: false };    }    let thumbnail: string | undefined;    const video = tweet.querySelector('video');    if (video?.poster) {      thumbnail = this.cleanImageUrl(video.poster);    }    if (!thumbnail) {      const videoContainer = videoPlayer.closest('[data-testid="videoComponent"]');      const thumbImg = videoContainer?.querySelector('img');      if (thumbImg?.src) {        thumbnail = this.cleanImageUrl(thumbImg.src);      }    }    if (!thumbnail) {      const previewImg = videoPlayer.parentElement?.querySelector('img[src*="pbs.twimg.com"]');      if (previewImg && (previewImg as HTMLImageElement).src) {        thumbnail = this.cleanImageUrl((previewImg as HTMLImageElement).src);      }    }    return {      hasVideo: true,      thumbnail    };  }  /**   * Clean and optimize image URLs   */  private static cleanImageUrl(url: string): string {    try {      const urlObj = new URL(url);      if (url.includes('pbs.twimg.com')) {        const pathParts = urlObj.pathname.split('.');        if (pathParts.length > 1) {          const extension = pathParts[pathParts.length - 1].split('?')[0];          const basePath = pathParts.slice(0, -1).join('.');          return `${urlObj.origin}${basePath}?format=${extension}&name=large`;        }      }      return urlObj.origin + urlObj.pathname;    } catch {      return url;    }  }  /**   * Extract context for HypeFury platform   */  static extractHypeFuryContext(container: Element): TweetContext {    const context: TweetContext = {      tweetText: '',      images: []    };    const hypeFuryContext = (window as any).HypeFuryPlatform?.extractContext(container);    if (hypeFuryContext) {      context.tweetText = hypeFuryContext.text || '';      context.authorHandle = hypeFuryContext.author || undefined;    }    const images = container.querySelectorAll('img:not([class*="avatar"]):not([class*="profile"])');    images.forEach(img => {      const src = (img as HTMLImageElement).src;      if (src && !src.includes('emoji') && !src.includes('icon')) {        context.images?.push({          url: src,          alt: (img as HTMLImageElement).alt || undefined,          type: 'image'        });      }    });    return context;  }  /**   * Check if context has visual content that needs analysis   */  static hasVisualContent(context: TweetContext): boolean {    return !!(context.images && context.images.length > 0) || !!context.hasVideo;  }  /**   * Prepare context for vision model analysis   */  static prepareForVisionAnalysis(context: TweetContext): {    text: string;    imageUrls: string[];    needsVision: boolean;  } {    const imageUrls: string[] = [];    if (context.images) {      imageUrls.push(...context.images.map(img => img.url));    }    if (context.videoThumbnail) {      imageUrls.push(context.videoThumbnail);    }    return {      text: context.tweetText,      imageUrls,      needsVision: imageUrls.length > 0    };  }}
```

utils\contextRecovery.ts
```ts
/** * Extension Context Recovery System * Handles context invalidation and automatic recovery with state restoration */import { debug, logError, logWarn } from '@/utils/debugConfig';interface SavedState {  timestamp: number;  apiKey?: string;  lastTone?: string;  lastTemplate?: string;  customTemplates?: any[];  activeTab?: string;  pendingReply?: {    text: string;    tweetId: string;    context: string;  };  userPreferences?: {    model?: string;    temperature?: number;    maxTokens?: number;  };}interface RecoveryConfig {  autoRecover: boolean;  stateExpiration: number;   checkInterval: number;   maxRecoveryAttempts: number;}export class ContextRecovery {  private static readonly STATE_KEY = '__tweetcraft_state__';  private static readonly RECOVERY_FLAG = '__tweetcraft_recovering__';  private static isRecovering = false;  private static checkTimer: ReturnType<typeof setInterval> | null = null;  private static autoSaveTimer: ReturnType<typeof setInterval> | null = null;  private static recoveryAttempts = 0;  private static lastSaveTime = 0;  private static stateChangeListeners = new Set<(state: SavedState) => void>();  private static config: RecoveryConfig = {    autoRecover: true,    stateExpiration: 3600000,     checkInterval: 5000,     maxRecoveryAttempts: 3  };  /**   * Initialize context recovery system   */  static init(config?: Partial<RecoveryConfig>): void {    if (config) {      this.config = { ...this.config, ...config };    }    console.log('%c🔄 Context Recovery', 'color: #FFA500; font-weight: bold', 'Initializing...');    this.checkRecoveryState();    this.startContextMonitoring();    this.setupAutoSave();    this.setupInvalidationListener();  }  /**   * Save current state   */  static saveState(partialState?: Partial<SavedState>): void {    try {      const currentState = this.getState() || {};      const newState: SavedState = {        ...currentState,        ...partialState,        timestamp: Date.now()      };      localStorage.setItem(this.STATE_KEY, JSON.stringify(newState));      sessionStorage.setItem(this.STATE_KEY, JSON.stringify(newState));      if (typeof chrome !== 'undefined' && chrome.storage?.local) {        chrome.storage.local.set({ [this.STATE_KEY]: newState })          .then(() => {          })          .catch(() => {          });      }      this.lastSaveTime = Date.now();      console.log('State saved', newState);      this.stateChangeListeners.forEach(listener => listener(newState));    } catch (error) {      logError('Failed to save state', error);    }  }  /**   * Get saved state   */  static getState(): SavedState | null {    try {      let stateStr = localStorage.getItem(this.STATE_KEY);      if (!stateStr) {        stateStr = sessionStorage.getItem(this.STATE_KEY);      }      if (!stateStr) return null;      const state = JSON.parse(stateStr) as SavedState;      if (Date.now() - state.timestamp > this.config.stateExpiration) {        logWarn('Saved state expired');        this.clearState();        return null;      }      return state;    } catch (error) {      logError('Failed to get state', error);      return null;    }  }  /**   * Clear saved state   */  static clearState(): void {    try {      localStorage.removeItem(this.STATE_KEY);      sessionStorage.removeItem(this.STATE_KEY);      if (typeof chrome !== 'undefined' && chrome.storage?.local) {        chrome.storage.local.remove(this.STATE_KEY)          .then(() => {          })          .catch(() => {          });      }      console.log('State cleared');    } catch (error) {      logError('Failed to clear state', error);    }  }  /**   * Check if recovering from context invalidation   */  private static checkRecoveryState(): void {    const isRecovering = sessionStorage.getItem(this.RECOVERY_FLAG) === 'true';    if (isRecovering) {      console.log('%c🔄 Recovery Mode', 'color: #FFA500; font-weight: bold', 'Recovering from context invalidation');      this.performRecovery();    }  }  /**   * Perform recovery   */  private static async performRecovery(): Promise<void> {    if (this.isRecovering || this.recoveryAttempts >= this.config.maxRecoveryAttempts) {      return;    }    this.isRecovering = true;    this.recoveryAttempts++;    try {      const state = this.getState();      if (!state) {        console.log('No state to recover');        return;      }      console.log('%c🔄 Restoring State', 'color: #17BF63', state);      if (state.apiKey && typeof chrome !== 'undefined' && chrome.runtime?.sendMessage) {        try {          await chrome.runtime.sendMessage({            type: 'SET_API_KEY',            data: { apiKey: state.apiKey }          });        } catch (error) {        }      }      if (state.userPreferences) {        await this.restorePreferences(state.userPreferences);      }      if (state.lastTone || state.lastTemplate || state.activeTab) {        await this.restoreUIState({          lastTone: state.lastTone,          lastTemplate: state.lastTemplate,          activeTab: state.activeTab        });      }      if (state.pendingReply) {        await this.restorePendingReply(state.pendingReply);      }      sessionStorage.removeItem(this.RECOVERY_FLAG);      console.log('%c✅ Recovery Complete', 'color: #17BF63; font-weight: bold');      window.dispatchEvent(new CustomEvent('tweetcraft-recovery-complete', {        detail: { state, attempts: this.recoveryAttempts }      }));    } catch (error) {      logError('Recovery failed', error);      if (this.recoveryAttempts < this.config.maxRecoveryAttempts) {        setTimeout(() => this.performRecovery(), 2000);      }    } finally {      this.isRecovering = false;    }  }  /**   * Restore user preferences   */  private static async restorePreferences(preferences: any): Promise<void> {    if (typeof chrome !== 'undefined' && chrome.runtime?.sendMessage) {      try {        await chrome.runtime.sendMessage({          type: 'SET_CONFIG',          data: preferences        });      } catch (error) {      }    }  }  /**   * Restore UI state   */  private static async restoreUIState(uiState: any): Promise<void> {    window.dispatchEvent(new CustomEvent('tweetcraft-restore-ui', {      detail: uiState    }));  }  /**   * Restore pending reply   */  private static async restorePendingReply(pendingReply: any): Promise<void> {    const tweetElement = document.querySelector(`[data-tweet-id="${pendingReply.tweetId}"]`);    if (tweetElement) {      window.dispatchEvent(new CustomEvent('tweetcraft-restore-reply', {        detail: pendingReply      }));    }  }  /**   * Start monitoring for context invalidation   */  private static startContextMonitoring(): void {    if (this.checkTimer) {      clearInterval(this.checkTimer);    }    this.checkTimer = setInterval(() => {      this.checkContextHealth();    }, this.config.checkInterval);  }  /**   * Check if extension context is healthy   */  private static async checkContextHealth(): Promise<void> {    if (typeof chrome === 'undefined' || !chrome.runtime) {      return;    }    try {      await chrome.runtime.sendMessage({ type: 'PING' });    } catch (error: any) {      if (error?.message?.includes('Extension context invalidated')) {        this.handleContextInvalidation();      }    }  }  /**   * Handle context invalidation   */  private static handleContextInvalidation(): void {    logWarn('Extension context invalidated, preparing for recovery');    this.saveState();    sessionStorage.setItem(this.RECOVERY_FLAG, 'true');    this.notifyUserOfRecovery();    setTimeout(() => {      location.reload();    }, 1000);  }  /**   * Setup invalidation listener   */  private static setupInvalidationListener(): void {    window.addEventListener('unhandledrejection', (event) => {      if (event.reason?.message?.includes('Extension context invalidated')) {        this.handleContextInvalidation();      }    });    if (typeof chrome !== 'undefined' && chrome.runtime?.onMessage) {      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {        if (message.type === 'PING') {          sendResponse({ status: 'PONG' });        }      });    }  }  /**   * Setup auto-save   */  private static setupAutoSave(): void {    const events = [      'tweetcraft-reply-generated',      'tweetcraft-template-selected',      'tweetcraft-tone-selected',      'tweetcraft-custom-template-saved'    ];    events.forEach(eventName => {      window.addEventListener(eventName, (event: any) => {        this.saveState(event.detail);      });    });    if (this.autoSaveTimer) {      clearInterval(this.autoSaveTimer);    }    this.autoSaveTimer = setInterval(() => {      if (Date.now() - this.lastSaveTime > 30000) {         this.saveState();      }    }, 30000);  }  /**   * Notify user of recovery   */  private static notifyUserOfRecovery(): void {    const notification = document.createElement('div');    notification.innerHTML = `      <div style="        position: fixed;        top: 20px;        right: 20px;        background: #FFA500;        color: white;        padding: 12px 20px;        border-radius: 8px;        font-family: system-ui, -apple-system, sans-serif;        font-size: 14px;        z-index: 999999;        box-shadow: 0 2px 10px rgba(0,0,0,0.2);      ">        🔄 TweetCraft is recovering your session...      </div>    `;    document.body.appendChild(notification);    setTimeout(() => {      notification.remove();    }, 3000);  }  /**   * Add state change listener   */  static onStateChange(listener: (state: SavedState) => void): () => void {    this.stateChangeListeners.add(listener);    return () => {      this.stateChangeListeners.delete(listener);    };  }  /**   * Destroy and cleanup   */  static destroy(): void {    if (this.checkTimer) {      clearInterval(this.checkTimer);      this.checkTimer = null;    }    if (this.autoSaveTimer) {      clearInterval(this.autoSaveTimer);      this.autoSaveTimer = null;    }    this.stateChangeListeners.clear();    this.isRecovering = false;    this.recoveryAttempts = 0;  }  /**   * Force recovery (for testing)   */  static forceRecovery(): void {    this.handleContextInvalidation();  }  /**   * Get recovery status   */  static getStatus(): {    isRecovering: boolean;    recoveryAttempts: number;    hasState: boolean;    stateAge: number | null;  } {    const state = this.getState();    return {      isRecovering: this.isRecovering,      recoveryAttempts: this.recoveryAttempts,      hasState: state !== null,      stateAge: state ? Date.now() - state.timestamp : null    };  }}if (typeof window !== 'undefined') {  if (document.readyState === 'loading') {    document.addEventListener('DOMContentLoaded', () => {      ContextRecovery.init();    });  } else {    ContextRecovery.init();  }}
```

utils\debounce.ts
```ts
export function debounce<T extends (...args: any[]) => any>(  func: T,  wait: number,  immediate: boolean = false): (...args: Parameters<T>) => void {  let timeout: ReturnType<typeof setTimeout> | null = null;  return function(this: any, ...args: Parameters<T>) {    const later = () => {      timeout = null;      if (!immediate) {        func.apply(this, args);      }    };    const callNow = immediate && !timeout;    if (timeout) {      clearTimeout(timeout);    }    timeout = setTimeout(later, wait);    if (callNow) {      func.apply(this, args);    }  };}export function throttle<T extends (...args: any[]) => any>(  func: T,  limit: number): (...args: Parameters<T>) => void {  let inThrottle = false;  return function(this: any, ...args: Parameters<T>) {    if (!inThrottle) {      func.apply(this, args);      inThrottle = true;      setTimeout(() => {        inThrottle = false;      }, limit);    }  };}
```

utils\debugConfig.ts
```ts
/** * Debug Configuration for TweetCraft * Controls console logging verbosity throughout the extension */interface DebugConfig {  enabled: boolean;  logLevel: 'verbose' | 'info' | 'warning' | 'error';  categories: {    api: boolean;    cache: boolean;    dom: boolean;    messaging: boolean;    performance: boolean;    ui: boolean;    all: boolean;  };}class DebugManager {  private config: DebugConfig = {    enabled: false,     logLevel: 'info',    categories: {      api: true,      cache: true,      dom: true,      messaging: true,      performance: true,      ui: true,      all: false     }  };  constructor() {    this.loadSettings();    if (typeof window !== 'undefined') {      (window as any).tweetcraftDebug = {        enable: () => this.enable(),        disable: () => this.disable(),        setLevel: (level: string) => this.setLogLevel(level as any),        enableCategory: (category: string) => this.enableCategory(category),        disableCategory: (category: string) => this.disableCategory(category),        status: () => this.getStatus()      };    }  }  private loadSettings(): void {    try {      const saved = localStorage.getItem('tweetcraft_debug_config');      if (saved) {        const parsedConfig = JSON.parse(saved);        this.config = { ...this.config, ...parsedConfig };      }    } catch (error) {    }  }  private saveSettings(): void {    try {      localStorage.setItem('tweetcraft_debug_config', JSON.stringify(this.config));    } catch (error) {    }  }  enable(): void {    this.config.enabled = true;    this.saveSettings();    console.log('%c🐛 Debug Mode: ENABLED', 'color: #17BF63; font-weight: bold');  }  disable(): void {    this.config.enabled = false;    this.saveSettings();    console.log('%c🐛 Debug Mode: DISABLED', 'color: #DC3545; font-weight: bold');  }  setLogLevel(level: 'verbose' | 'info' | 'warning' | 'error'): void {    this.config.logLevel = level;    this.saveSettings();    console.log(`%c🐛 Log Level: ${level.toUpperCase()}`, 'color: #1DA1F2; font-weight: bold');  }  enableCategory(category: string): void {    if (category in this.config.categories) {      (this.config.categories as any)[category] = true;      this.saveSettings();      console.log(`%c🐛 Category Enabled: ${category}`, 'color: #17BF63');    }  }  disableCategory(category: string): void {    if (category in this.config.categories) {      (this.config.categories as any)[category] = false;      this.saveSettings();      console.log(`%c🐛 Category Disabled: ${category}`, 'color: #FFA500');    }  }  getStatus(): DebugConfig {    return { ...this.config };  }  shouldLog(category: keyof DebugConfig['categories'], level: 'verbose' | 'info' | 'warning' | 'error' = 'info'): boolean {    if (!this.config.enabled) return false;    if (!this.config.categories.all && !this.config.categories[category]) {      return false;    }    const levels = ['verbose', 'info', 'warning', 'error'];    const configLevelIndex = levels.indexOf(this.config.logLevel);    const messageLevelIndex = levels.indexOf(level);    return messageLevelIndex >= configLevelIndex;  }  /**   * Conditional console.log wrapper   */  log(category: keyof DebugConfig['categories'], level: 'verbose' | 'info' | 'warning' | 'error', ...args: any[]): void {    if (this.shouldLog(category, level)) {      console.log(...args);    }  }  /**   * Conditional console.warn wrapper   */  warn(category: keyof DebugConfig['categories'], ...args: any[]): void {    if (this.shouldLog(category, 'warning')) {      console.warn(...args);    }  }  /**   * Conditional console.error wrapper   */  error(category: keyof DebugConfig['categories'], ...args: any[]): void {    if (this.shouldLog(category, 'error')) {      console.error(...args);    }  }  /**   * Conditional console.group wrapper   */  group(category: keyof DebugConfig['categories'], label: string): void {    if (this.shouldLog(category, 'verbose')) {      console.group(label);    }  }  /**   * Conditional console.groupEnd wrapper   */  groupEnd(category: keyof DebugConfig['categories']): void {    if (this.shouldLog(category, 'verbose')) {      console.groupEnd();    }  }  /**   * Performance timing wrapper   */  time(category: keyof DebugConfig['categories'], label: string): void {    if (this.shouldLog(category, 'verbose')) {      console.time(label);    }  }  timeEnd(category: keyof DebugConfig['categories'], label: string): void {    if (this.shouldLog(category, 'verbose')) {      console.timeEnd(label);    }  }  /**   * Convenience methods for logging errors and warnings   */  logError(...args: any[]): void {    this.error('all', ...args);  }  logWarn(...args: any[]): void {    this.warn('all', ...args);  }}export const debug = new DebugManager();export const logAPI = (...args: any[]) => debug.log('api', 'info', ...args);export const logCache = (...args: any[]) => debug.log('cache', 'info', ...args);export const logDOM = (...args: any[]) => debug.log('dom', 'info', ...args);export const logMessage = (...args: any[]) => debug.log('messaging', 'info', ...args);export const logPerf = (...args: any[]) => debug.log('performance', 'verbose', ...args);export const logUI = (...args: any[]) => debug.log('ui', 'info', ...args);export const logError = (...args: any[]) => debug.error('all', ...args);export const logWarn = (...args: any[]) => debug.warn('all', ...args);/** * Debug Control from Browser Console: *  * Enable debug mode: *   tweetcraftDebug.enable() *  * Disable debug mode: *   tweetcraftDebug.disable() *  * Set log level ('verbose', 'info', 'warning', 'error'): *   tweetcraftDebug.setLevel('verbose') *  * Enable specific category: *   tweetcraftDebug.enableCategory('api') *  * Disable specific category: *   tweetcraftDebug.disableCategory('cache') *  * Check current status: *   tweetcraftDebug.status() */
```

utils\domBatcher.ts
```ts
/** * DOM Batching Utility for TweetCraft * Batch DOM updates for better performance */interface DOMOperation {  id: string;  type: 'create' | 'update' | 'delete' | 'style' | 'class';  element?: HTMLElement;  parent?: HTMLElement;  updates?: Partial<HTMLElement>;  styles?: Partial<CSSStyleDeclaration>;  classes?: { add?: string[]; remove?: string[] };  html?: string;  callback?: () => void;}interface BatchStats {  totalOperations: number;  batchesExecuted: number;  averageBatchSize: number;  totalExecutionTime: number;}export class DOMBatcher {  private pendingOperations: Map<string, DOMOperation> = new Map();  private batchTimeout: number | null = null;  private rafId: number | null = null;  private stats: BatchStats = {    totalOperations: 0,    batchesExecuted: 0,    averageBatchSize: 0,    totalExecutionTime: 0  };  private readonly BATCH_DELAY = 16;   private readonly MAX_BATCH_SIZE = 50;  private readonly USE_RAF = true;  constructor() {    console.log('%c🎯 DOMBatcher initialized', 'color: #1DA1F2; font-weight: bold');  }  /**   * Queue a DOM operation   */  queue(operation: DOMOperation): void {    if (this.pendingOperations.has(operation.id)) {      const existing = this.pendingOperations.get(operation.id)!;      this.mergeOperations(existing, operation);    } else {      this.pendingOperations.set(operation.id, operation);    }    this.scheduleBatch();  }  /**   * Create element with batching   */  createElement(    tag: string,    attributes?: Record<string, string>,    parent?: HTMLElement,    html?: string  ): string {    const id = `create_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;    this.queue({      id,      type: 'create',      parent,      html,      callback: () => {        const element = document.createElement(tag);        if (attributes) {          Object.entries(attributes).forEach(([key, value]) => {            element.setAttribute(key, value);          });        }        if (html) {          element.innerHTML = html;        }        if (parent) {          parent.appendChild(element);        }      }    });    return id;  }  /**   * Update element with batching   */  updateElement(element: HTMLElement, updates: Partial<HTMLElement>): void {    const id = `update_${element.id || element.className}_${Date.now()}`;    this.queue({      id,      type: 'update',      element,      updates    });  }  /**   * Update styles with batching   */  updateStyles(element: HTMLElement, styles: Partial<CSSStyleDeclaration>): void {    const id = `style_${element.id || element.className}_${Date.now()}`;    this.queue({      id,      type: 'style',      element,      styles    });  }  /**   * Update classes with batching   */  updateClasses(    element: HTMLElement,    add?: string[],    remove?: string[]  ): void {    const id = `class_${element.id || element.className}_${Date.now()}`;    this.queue({      id,      type: 'class',      element,      classes: { add, remove }    });  }  /**   * Delete element with batching   */  deleteElement(element: HTMLElement): void {    const id = `delete_${element.id || element.className}_${Date.now()}`;    this.queue({      id,      type: 'delete',      element    });  }  /**   * Batch update multiple elements   */  batchUpdate(updates: Array<{    element: HTMLElement;    changes: {      props?: Partial<HTMLElement>;      styles?: Partial<CSSStyleDeclaration>;      classes?: { add?: string[]; remove?: string[] };    };  }>): void {    updates.forEach(({ element, changes }, index) => {      const id = `batch_${index}_${Date.now()}`;      if (changes.props) {        this.queue({          id: `${id}_props`,          type: 'update',          element,          updates: changes.props        });      }      if (changes.styles) {        this.queue({          id: `${id}_styles`,          type: 'style',          element,          styles: changes.styles        });      }      if (changes.classes) {        this.queue({          id: `${id}_classes`,          type: 'class',          element,          classes: changes.classes        });      }    });  }  /**   * Merge operations for the same element   */  private mergeOperations(existing: DOMOperation, newOp: DOMOperation): void {    if (newOp.updates) {      existing.updates = { ...existing.updates, ...newOp.updates };    }    if (newOp.styles) {      existing.styles = { ...existing.styles, ...newOp.styles };    }    if (newOp.classes) {      if (!existing.classes) existing.classes = {};      if (newOp.classes.add) {        existing.classes.add = [          ...(existing.classes.add || []),          ...newOp.classes.add        ];      }      if (newOp.classes.remove) {        existing.classes.remove = [          ...(existing.classes.remove || []),          ...newOp.classes.remove        ];      }    }    if (newOp.callback) {      existing.callback = newOp.callback;    }  }  /**   * Schedule batch execution   */  private scheduleBatch(): void {    if (this.batchTimeout !== null) {      clearTimeout(this.batchTimeout);    }    if (this.rafId !== null) {      cancelAnimationFrame(this.rafId);    }    if (this.USE_RAF) {      this.rafId = requestAnimationFrame(() => this.executeBatch());    } else {      this.batchTimeout = window.setTimeout(() => this.executeBatch(), this.BATCH_DELAY);    }    if (this.pendingOperations.size >= this.MAX_BATCH_SIZE) {      this.executeBatch();    }  }  /**   * Execute all pending operations   */  private executeBatch(): void {    if (this.pendingOperations.size === 0) return;    const startTime = performance.now();    const operations = Array.from(this.pendingOperations.values());    console.log(`%c🎯 Executing batch: ${operations.length} operations`, 'color: #657786');    this.pendingOperations.clear();    this.batchTimeout = null;    this.rafId = null;    const grouped = this.groupOperations(operations);    this.executeGrouped(grouped);    const executionTime = performance.now() - startTime;    this.updateStats(operations.length, executionTime);    console.log(`%c🎯 Batch complete in ${executionTime.toFixed(2)}ms`, 'color: #17BF63');  }  /**   * Group operations by type   */  private groupOperations(operations: DOMOperation[]): Map<string, DOMOperation[]> {    const grouped = new Map<string, DOMOperation[]>();    operations.forEach(op => {      if (!grouped.has(op.type)) {        grouped.set(op.type, []);      }      grouped.get(op.type)!.push(op);    });    return grouped;  }  /**   * Execute grouped operations in optimal order   */  private executeGrouped(grouped: Map<string, DOMOperation[]>): void {    const order = ['delete', 'create', 'update', 'style', 'class'];    order.forEach(type => {      const ops = grouped.get(type);      if (ops) {        ops.forEach(op => this.executeOperation(op));      }    });  }  /**   * Execute a single operation   */  private executeOperation(op: DOMOperation): void {    try {      switch (op.type) {        case 'create':          if (op.callback) {            op.callback();          }          break;        case 'update':          if (op.element && op.updates) {            Object.assign(op.element, op.updates);          }          break;        case 'style':          if (op.element && op.styles) {            Object.assign(op.element.style, op.styles);          }          break;        case 'class':          if (op.element && op.classes) {            if (op.classes.add) {              op.element.classList.add(...op.classes.add);            }            if (op.classes.remove) {              op.element.classList.remove(...op.classes.remove);            }          }          break;        case 'delete':          if (op.element && op.element.parentNode) {            op.element.parentNode.removeChild(op.element);          }          break;      }      if (op.callback && op.type !== 'create') {        op.callback();      }    } catch (error) {      console.error('Error executing DOM operation:', error, op);    }  }  /**   * Update statistics   */  private updateStats(batchSize: number, executionTime: number): void {    this.stats.totalOperations += batchSize;    this.stats.batchesExecuted++;    this.stats.totalExecutionTime += executionTime;    this.stats.averageBatchSize =       this.stats.totalOperations / this.stats.batchesExecuted;  }  /**   * Force immediate execution   */  flush(): void {    if (this.pendingOperations.size > 0) {      console.log('%c🎯 Force flushing batch', 'color: #FFA500');      this.executeBatch();    }  }  /**   * Get batch statistics   */  getStats(): BatchStats {    return { ...this.stats };  }  /**   * Reset statistics   */  resetStats(): void {    this.stats = {      totalOperations: 0,      batchesExecuted: 0,      averageBatchSize: 0,      totalExecutionTime: 0    };  }  /**   * Clear all pending operations   */  clear(): void {    if (this.batchTimeout !== null) {      clearTimeout(this.batchTimeout);      this.batchTimeout = null;    }    if (this.rafId !== null) {      cancelAnimationFrame(this.rafId);      this.rafId = null;    }    this.pendingOperations.clear();    console.log('%c🎯 Cleared all pending operations', 'color: #FFA500');  }  /**   * Debug: Print pending operations   */  debug(): void {    console.group('%c🎯 DOMBatcher Debug', 'color: #1DA1F2; font-weight: bold');    console.log('Pending Operations:', this.pendingOperations.size);    console.log('Stats:', this.getStats());    if (this.pendingOperations.size > 0) {      console.group('Operations:');      this.pendingOperations.forEach((op, id) => {        console.log(`${id}: ${op.type}`, op);      });      console.groupEnd();    }    console.groupEnd();  }}export const domBatcher = new DOMBatcher();
```

utils\domCache.ts
```ts
/** * DOM Query Cache for performance optimization * Caches frequently accessed DOM elements with automatic invalidation */interface CacheEntry {  element: Element | null;  timestamp: number;  selector: string;}interface WeakCacheEntry {  timestamp: number;  selector: string;  parentRef?: any; }const hasWeakRef = typeof WeakRef !== 'undefined';export class DOMCache {  private static cache = new Map<string, CacheEntry>();  private static weakCache = new WeakMap<Element, Map<string, WeakCacheEntry>>();  private static elementQueryCache = hasWeakRef     ? new WeakMap<Element, Map<string, any>>()     : new WeakMap<Element, Map<string, Element>>();  private static readonly TTL = 5000;   private static mutationObserver: MutationObserver | null = null;  private static metrics = {    cacheHits: 0,    cacheMisses: 0,    weakCacheHits: 0,    weakCacheMisses: 0  };  /**   * Initialize the DOM cache with mutation observer for invalidation   */  static init(): void {    if (this.mutationObserver) return;    this.mutationObserver = new MutationObserver((mutations) => {      for (const mutation of mutations) {        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {          this.clearStaleEntries();        }      }    });    this.mutationObserver.observe(document.body, {      childList: true,      subtree: true    });  }  /**   * Query selector with caching (enhanced with WeakMap for element parents)   */  static querySelector<T extends Element>(selector: string, parent: Element | Document = document): T | null {    if (parent !== document && parent instanceof Element) {      return this.queryWithWeakCache<T>(selector, parent);    }    const cacheKey = `doc:${selector}`;    const cached = this.cache.get(cacheKey);    if (cached && Date.now() - cached.timestamp < this.TTL) {      if (cached.element && document.contains(cached.element)) {        this.metrics.cacheHits++;        return cached.element as T;      }    }    this.metrics.cacheMisses++;    const element = parent.querySelector<T>(selector);    this.cache.set(cacheKey, {      element,      timestamp: Date.now(),      selector    });    return element;  }  /**   * Query with WeakMap caching for element parents   */  private static queryWithWeakCache<T extends Element>(selector: string, parent: Element): T | null {    let parentCache = this.elementQueryCache.get(parent);    if (!parentCache) {      parentCache = new Map();      this.elementQueryCache.set(parent, parentCache);    }    if (hasWeakRef) {      const cachedRef = parentCache.get(selector);      if (cachedRef) {        const cached = cachedRef.deref();        if (cached && parent.contains(cached)) {          this.metrics.weakCacheHits++;          return cached as T;        }      }    } else {      const cached = parentCache.get(selector);      if (cached && parent.contains(cached)) {        this.metrics.weakCacheHits++;        return cached as T;      }    }    this.metrics.weakCacheMisses++;    const element = parent.querySelector<T>(selector);    if (element) {      if (hasWeakRef) {        parentCache.set(selector, new WeakRef(element));      } else {        parentCache.set(selector, element);      }    }    return element;  }  /**   * Query selector all with caching   */  static querySelectorAll<T extends Element>(selector: string, parent: Element | Document = document): NodeListOf<T> {    return parent.querySelectorAll<T>(selector);  }  /**   * Clear stale cache entries   */  private static clearStaleEntries(): void {    const now = Date.now();    for (const [key, entry] of this.cache.entries()) {      if (now - entry.timestamp > this.TTL || !document.contains(entry.element)) {        this.cache.delete(key);      }    }  }  /**   * Clear all cache entries   */  static clear(): void {    this.cache.clear();    this.resetMetrics();  }  /**   * Cleanup and destroy   */  static destroy(): void {    if (this.mutationObserver) {      this.mutationObserver.disconnect();      this.mutationObserver = null;    }    this.clear();  }  /**   * Get cache metrics   */  static getMetrics() {    const totalHits = this.metrics.cacheHits + this.metrics.weakCacheHits;    const totalMisses = this.metrics.cacheMisses + this.metrics.weakCacheMisses;    const hitRate = totalHits + totalMisses > 0       ? (totalHits / (totalHits + totalMisses) * 100).toFixed(2)       : 0;    return {      ...this.metrics,      totalHits,      totalMisses,      hitRate: `${hitRate}%`,      cacheSize: this.cache.size    };  }  /**   * Reset metrics   */  static resetMetrics(): void {    this.metrics = {      cacheHits: 0,      cacheMisses: 0,      weakCacheHits: 0,      weakCacheMisses: 0    };  }  /**   * Batch query multiple selectors efficiently   */  static batchQuery<T extends Element>(selectors: string[], parent: Element | Document = document): Map<string, T | null> {    const results = new Map<string, T | null>();    for (const selector of selectors) {      results.set(selector, this.querySelector<T>(selector, parent));    }    return results;  }}
```

utils\encryption.ts
```ts
/** * Encryption utilities for sensitive data * Uses Web Crypto API for secure encryption */import { logger } from '@/utils/logger';interface MigrationLock {  lockId: string;  timestamp: number;  holder: string;}export class EncryptionService {  private static readonly ALGORITHM = 'AES-GCM';  private static readonly KEY_LENGTH = 256;  private static readonly SALT_LENGTH = 16;   private static readonly MIGRATION_LOCK_KEY = 'tweetcraft_migration_lock';  private static readonly LOCK_TIMEOUT_MS = 30000;   private static readonly LOCK_RETRY_DELAY_MS = 100;   private static readonly LOCK_MAX_RETRIES = 50;   private static readonly LOCK_BACKOFF_MULTIPLIER = 1.2;   private static readonly DEADLOCK_DETECTION_MS = 60000;   private static migrationInProgress = new Map<string, Promise<string>>();  /**   * Derive a key from a passphrase with a unique salt   */  private static async deriveKey(passphrase: string, salt: Uint8Array): Promise<CryptoKey> {    const encoder = new TextEncoder();    const keyMaterial = await crypto.subtle.importKey(      'raw',      encoder.encode(passphrase),      { name: 'PBKDF2' },      false,      ['deriveBits', 'deriveKey']    );    return crypto.subtle.deriveKey(      {        name: 'PBKDF2',        salt: salt.buffer as ArrayBuffer,        iterations: 100000,        hash: 'SHA-256'      },      keyMaterial,      { name: this.ALGORITHM, length: this.KEY_LENGTH },      false,      ['encrypt', 'decrypt']    );  }  /**   * Encrypt a string   */  static async encrypt(text: string, passphrase?: string): Promise<{ ciphertext: string; iv: string; salt: string }> {    try {      const finalPassphrase = passphrase || chrome.runtime.id;      const salt = crypto.getRandomValues(new Uint8Array(this.SALT_LENGTH));      const key = await this.deriveKey(finalPassphrase, salt);      const encoder = new TextEncoder();      const data = encoder.encode(text);      const iv = crypto.getRandomValues(new Uint8Array(12));      const encrypted = await crypto.subtle.encrypt(        {          name: this.ALGORITHM,          iv: iv        },        key,        data      );      const ciphertext = btoa(String.fromCharCode(...new Uint8Array(encrypted)));      const ivBase64 = btoa(String.fromCharCode(...iv));      const saltBase64 = btoa(String.fromCharCode(...salt));      return { ciphertext, iv: ivBase64, salt: saltBase64 };    } catch (error) {      logger.error('Encryption failed:', error);      throw new Error('Failed to encrypt data');    }  }  /**   * Encrypt an API key (convenience method)   */  static async encryptApiKey(apiKey: string): Promise<string> {    const { ciphertext, iv, salt } = await this.encrypt(apiKey);    return `enc_${ciphertext}_${iv}_${salt}`;  }  /**   * Decrypt an API key (convenience method)   */  static async decryptApiKey(encryptedData: string): Promise<string> {    if (!encryptedData.startsWith('enc_')) {      return encryptedData;    }    const parts = encryptedData.substring(4).split('_');    if (parts.length !== 3) {      throw new Error('Invalid encrypted API key format');    }    const [ciphertext, iv, salt] = parts;    return this.decrypt(ciphertext, iv, salt);  }  /**   * Decrypt a string   */  static async decrypt(ciphertext: string, iv: string, salt: string, passphrase?: string): Promise<string> {    try {      const finalPassphrase = passphrase || chrome.runtime.id;      const saltArray = Uint8Array.from(atob(salt), c => c.charCodeAt(0));      const key = await this.deriveKey(finalPassphrase, saltArray);      const encryptedData = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));      const ivArray = Uint8Array.from(atob(iv), c => c.charCodeAt(0));      const decrypted = await crypto.subtle.decrypt(        {          name: this.ALGORITHM,          iv: ivArray        },        key,        encryptedData      );      const decoder = new TextDecoder();      return decoder.decode(decrypted);    } catch (error) {      logger.error('Decryption failed:', error);      throw new Error('Failed to decrypt data');    }  }  /**   * Acquire a migration lock with timeout and retry logic   */  private static async acquireMigrationLock(lockKey: string): Promise<string | null> {    const lockId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;    const holder = `${chrome.runtime.id}_${lockId}`;    const startTime = Date.now();    let retries = 0;    let delay = this.LOCK_RETRY_DELAY_MS;    while (retries < this.LOCK_MAX_RETRIES) {      try {        const elapsedTime = Date.now() - startTime;        if (elapsedTime > this.DEADLOCK_DETECTION_MS) {          logger.error('Deadlock detected in migration lock acquisition');          await this.forceReleaseLock(lockKey);          throw new Error('Migration deadlock detected - lock forcefully released');        }        const result = await chrome.storage.local.get(lockKey);        const existingLock = result[lockKey] as MigrationLock | undefined;        const now = Date.now();        if (!existingLock || (now - existingLock.timestamp) > this.LOCK_TIMEOUT_MS) {          const newLock: MigrationLock = {            lockId,            timestamp: now,            holder          };          await chrome.storage.local.set({ [lockKey]: newLock });          const verification = await chrome.storage.local.get(lockKey);          const verifiedLock = verification[lockKey] as MigrationLock;          if (verifiedLock && verifiedLock.holder === holder) {            logger.log(`Migration lock acquired: ${lockId} after ${elapsedTime}ms`);            return lockId;          }        }        retries++;        if (retries < this.LOCK_MAX_RETRIES) {          await new Promise(resolve => setTimeout(resolve, delay));          delay = Math.min(delay * this.LOCK_BACKOFF_MULTIPLIER, 500);         }      } catch (error) {        logger.error('Error acquiring migration lock:', error);        retries++;      }    }    logger.warn('Failed to acquire migration lock after retries');    return null;  }  /**   * Release a migration lock   */  private static async releaseMigrationLock(lockKey: string, lockId: string): Promise<void> {    try {      const result = await chrome.storage.local.get(lockKey);      const existingLock = result[lockKey] as MigrationLock | undefined;      if (existingLock && existingLock.lockId === lockId) {        await chrome.storage.local.remove(lockKey);        logger.log(`Migration lock released: ${lockId}`);      }    } catch (error) {      logger.error('Error releasing migration lock:', error);    }  }  /**   * Force release a lock (used for deadlock recovery)   */  private static async forceReleaseLock(lockKey: string): Promise<void> {    try {      await chrome.storage.local.remove(lockKey);      logger.warn(`Migration lock forcefully released: ${lockKey}`);    } catch (error) {      logger.error('Error force releasing migration lock:', error);    }  }  /**   * Clean up expired migration locks (safety mechanism)   * Call this periodically or on extension startup   */  static async cleanupExpiredLocks(): Promise<void> {    try {      const storage = await chrome.storage.local.get();      const now = Date.now();      const keysToRemove: string[] = [];      for (const key in storage) {        if (key.startsWith(this.MIGRATION_LOCK_KEY)) {          const lock = storage[key] as MigrationLock;          if (lock && (now - lock.timestamp) > this.LOCK_TIMEOUT_MS) {            keysToRemove.push(key);            logger.log(`Cleaning up expired migration lock: ${lock.lockId}`);          }        }      }      if (keysToRemove.length > 0) {        await chrome.storage.local.remove(keysToRemove);        logger.log(`Cleaned up ${keysToRemove.length} expired migration locks`);      }    } catch (error) {      logger.error('Error cleaning up expired locks:', error);    }  }  /**   * Store encrypted API key   */  static async storeApiKey(key: string, storageKey: string = 'openrouter_apiKey'): Promise<void> {    const encrypted = await this.encrypt(key);    await chrome.storage.local.set({      [`${storageKey}_encrypted`]: encrypted    });  }  /**   * Perform the actual migration of a legacy encrypted key   */  private static async performLegacyMigration(    ciphertext: string,     iv: string,     storageKey: string  ): Promise<string> {    const migrationKey = `${storageKey}_migration`;    const existingMigration = this.migrationInProgress.get(migrationKey);    if (existingMigration) {      logger.log('Migration already in progress, waiting for completion...');      return existingMigration;    }    const migrationPromise = (async () => {      const lockKey = `${this.MIGRATION_LOCK_KEY}_${storageKey}`;      let lockId: string | null = null;      try {        lockId = await this.acquireMigrationLock(lockKey);        if (!lockId) {          logger.warn('Could not acquire migration lock, checking if migration was completed...');          const recheckStored = await chrome.storage.local.get([`${storageKey}_encrypted`]);          const recheckedData = recheckStored[`${storageKey}_encrypted`];          if (recheckedData && recheckedData.salt) {            logger.log('Migration was completed by another process');            return await this.decrypt(recheckedData.ciphertext, recheckedData.iv, recheckedData.salt);          }          logger.warn('Falling back to legacy decryption without migration');          const legacySalt = btoa('tweetcraft-v1-salt');          return await this.decrypt(ciphertext, iv, legacySalt);        }        const doubleCheckStored = await chrome.storage.local.get([`${storageKey}_encrypted`]);        const currentData = doubleCheckStored[`${storageKey}_encrypted`];        if (currentData && currentData.salt) {          logger.log('Migration already completed, using new format');          return await this.decrypt(currentData.ciphertext, currentData.iv, currentData.salt);        }        logger.log('Performing legacy key migration with lock protection...');        const legacySalt = btoa('tweetcraft-v1-salt');        const decryptedKey = await this.decrypt(ciphertext, iv, legacySalt);        await this.storeApiKey(decryptedKey, storageKey);        logger.log('Successfully migrated API key to secure encryption format');        return decryptedKey;      } finally {        if (lockId) {          await this.releaseMigrationLock(lockKey, lockId);        }        this.migrationInProgress.delete(migrationKey);      }    })();    this.migrationInProgress.set(migrationKey, migrationPromise);    return migrationPromise;  }  /**   * Retrieve and decrypt API key   */  static async getApiKey(storageKey: string = 'openrouter_apiKey'): Promise<string | null> {    try {      const stored = await chrome.storage.local.get([`${storageKey}_encrypted`, storageKey]);      if (stored[`${storageKey}_encrypted`]) {        const { ciphertext, iv, salt } = stored[`${storageKey}_encrypted`];        if (salt) {          return await this.decrypt(ciphertext, iv, salt);        } else {          logger.warn('Legacy encryption format detected, initiating secure migration...');          return await this.performLegacyMigration(ciphertext, iv, storageKey);        }      }      if (stored[storageKey]) {        logger.log('Found unencrypted API key, migrating to encrypted storage...');        const lockKey = `${this.MIGRATION_LOCK_KEY}_unencrypted_${storageKey}`;        const lockId = await this.acquireMigrationLock(lockKey);        try {          const recheck = await chrome.storage.local.get([`${storageKey}_encrypted`, storageKey]);          if (recheck[`${storageKey}_encrypted`]) {            const { ciphertext, iv, salt } = recheck[`${storageKey}_encrypted`];            return salt               ? await this.decrypt(ciphertext, iv, salt)              : await this.performLegacyMigration(ciphertext, iv, storageKey);          }          if (recheck[storageKey]) {            await this.storeApiKey(recheck[storageKey], storageKey);            await chrome.storage.local.remove([storageKey]);            return recheck[storageKey];          }        } finally {          if (lockId) {            await this.releaseMigrationLock(lockKey, lockId);          }        }      }      return null;    } catch (error) {      logger.error('Failed to retrieve API key:', error);      return null;    }  }}
```

utils\errorHandler.ts
```ts
/** * Simplified Error Handler - Consumer-Focused * Streamlined error handling with clear recovery actions */interface ErrorContext {  action: string;  component?: string;  retryAction?: () => Promise<any>;  metadata?: Record<string, any>;}interface RecoveryAction {  label: string;  action: string;  primary?: boolean;  handler: () => void;}export class ErrorHandler {  /**   * Simple error handling with user-friendly messages   */  static handleUserFriendlyError(error: Error, context: ErrorContext, button?: HTMLElement): RecoveryAction[] {    console.log('%c🚨 TweetCraft Error:', 'color: #DC3545; font-weight: bold', error.message);    const userMessage = this.getUserFriendlyMessage(error);    const recoveryActions = this.getRecoveryActions(context);    if (button && (window as any).DOMUtils && 'showError' in (window as any).DOMUtils) {      (window as any).DOMUtils.showError(button, userMessage, 'error');    }    return recoveryActions;  }  /**   * Simple user-friendly error messages   */  private static getUserFriendlyMessage(error: Error): string {    const message = error.message.toLowerCase();    if (message.includes('network') || message.includes('fetch') ||         message.includes('connection') || message.includes('timeout')) {      return 'Connection issue - please check your internet and try again';    }    if (message.includes('api') || message.includes('key') ||         message.includes('401') || message.includes('403')) {      return 'Please check your OpenRouter API key in extension settings';    }    if (message.includes('context') || message.includes('extension') ||         message.includes('invalidated')) {      return 'Please refresh this Twitter page';    }    if (message.includes('rate') || message.includes('429')) {      return 'Please wait a moment and try again';    }    return 'Something went wrong - please try again';  }  /**   * Simple recovery actions - consumer focused   */  private static getRecoveryActions(context: ErrorContext): RecoveryAction[] {    return [      {        label: 'Try Again',        action: 'retry',        primary: true,        handler: context.retryAction || (() => window.location.reload())      }    ];  }}
```

utils\jsonExtractor.ts
```ts
/** * Robust JSON extraction utility * Handles nested objects and special characters */export class JSONExtractor {  /**   * Extract JSON from a string using a deterministic scanner   * Handles nested objects, arrays, and escaped characters   */  static extractJSON(text: string): string | null {    const fencedMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);    if (fencedMatch) {      return fencedMatch[1].trim();    }    let startIdx = -1;    let startChar = '';    for (let i = 0; i < text.length; i++) {      if (text[i] === '{' || text[i] === '[') {        startIdx = i;        startChar = text[i];        break;      }    }    if (startIdx === -1) {      return null;    }    let depth = 1;     let inString = false;    let escapeNext = false;    let endIdx = -1;    const endChar = startChar === '{' ? '}' : ']';    for (let i = startIdx + 1; i < text.length; i++) {      const char = text[i];      if (escapeNext) {        escapeNext = false;        continue;      }      if (char === '\\' && inString) {        escapeNext = true;        continue;      }      if (char === '"' && !escapeNext) {        inString = !inString;        continue;      }      if (!inString) {        if (startChar === '{') {          if (char === '{') {            depth++;          } else if (char === '}') {            depth--;            if (depth === 0) {              endIdx = i;              break;            }          }        } else if (startChar === '[') {          if (char === '[') {            depth++;          } else if (char === ']') {            depth--;            if (depth === 0) {              endIdx = i;              break;            }          }        }      }    }    if (endIdx === -1) {      return null;    }    return text.substring(startIdx, endIdx + 1);  }  /**   * Parse JSON safely with error handling   */  static parseJSON<T = any>(text: string): T | null {    try {      const jsonStr = this.extractJSON(text);      if (!jsonStr) {        return null;      }      return JSON.parse(jsonStr);    } catch (error) {      console.warn('Failed to parse JSON:', error);      return null;    }  }}
```

utils\keyboardShortcuts.ts
```ts
/** * Expanded Keyboard Shortcuts Manager * Provides power user shortcuts for quick access to features */import { StorageService } from '@/services/storage';export interface ShortcutConfig {  key: string;  alt?: boolean;  ctrl?: boolean;  shift?: boolean;  action: string;  description: string;}export class KeyboardShortcutManager {  private static shortcuts = new Map<string, ShortcutConfig>();  private static isInitialized = false;  private static callbacks = new Map<string, () => void>();  private static boundHandleKeydown: ((event: KeyboardEvent) => void) | null = null;  /**   * Default keyboard shortcuts   */  static readonly DEFAULT_SHORTCUTS: ShortcutConfig[] = [    { key: '1', alt: true, action: 'tone_professional', description: 'Professional tone' },    { key: '2', alt: true, action: 'tone_casual', description: 'Casual tone' },    { key: '3', alt: true, action: 'tone_witty', description: 'Witty tone' },    { key: '4', alt: true, action: 'tone_supportive', description: 'Supportive tone' },    { key: '5', alt: true, action: 'tone_excited', description: 'Excited tone' },    { key: '6', alt: true, action: 'tone_academic', description: 'Academic tone' },    { key: '7', alt: true, action: 'tone_counter', description: 'Counter-argument tone' },    { key: '8', alt: true, action: 'tone_skeptic', description: 'Skeptical tone' },    { key: '9', alt: true, action: 'tone_sarcastic', description: 'Sarcastic tone' },    { key: 'a', alt: true, action: 'open_arsenal', description: 'Open Arsenal Mode - pre-generated replies' },    { key: 'q', alt: true, action: 'quick_generate', description: 'Generate with default tone' },    { key: 'r', alt: true, action: 'regenerate', description: 'Regenerate with same tone' },    { key: 't', alt: true, action: 'open_templates', description: 'Open template selector' },    { key: 's', alt: true, action: 'switch_suggestion', description: 'Switch between suggestions' },    { key: 'd', alt: true, action: 'open_dropdown', description: 'Open tone dropdown' },    { key: 'c', alt: true, action: 'copy_reply', description: 'Copy generated reply' },    { key: 'e', alt: true, action: 'edit_mode', description: 'Edit generated reply' },    { key: 'ArrowLeft', alt: true, action: 'prev_suggestion', description: 'Previous suggestion' },    { key: 'ArrowRight', alt: true, action: 'next_suggestion', description: 'Next suggestion' },    { key: 'Escape', alt: false, action: 'close_all', description: 'Close all dropdowns' }  ];  /**   * Initialize keyboard shortcuts   */  static async init(): Promise<void> {    if (this.isInitialized) return;    console.log('%c⌨️ Keyboard Shortcuts: Initializing', 'color: #9146FF; font-weight: bold');    const customShortcuts = await this.loadCustomShortcuts();    const allShortcuts = [...this.DEFAULT_SHORTCUTS, ...customShortcuts];    allShortcuts.forEach(shortcut => {      const key = this.getShortcutKey(shortcut);      this.shortcuts.set(key, shortcut);    });    this.boundHandleKeydown = this.handleKeydown.bind(this);    document.addEventListener('keydown', this.boundHandleKeydown, true);    this.isInitialized = true;    console.log(`%c  Registered ${this.shortcuts.size} shortcuts`, 'color: #657786');  }  /**   * Handle keyboard events   */  private static handleKeydown(event: KeyboardEvent): void {    const parts: string[] = [];    if (event.ctrlKey) parts.push('ctrl');    if (event.altKey) parts.push('alt');    if (event.shiftKey) parts.push('shift');    parts.push(event.key.toLowerCase());    const shortcutKey = parts.join('+');    const shortcut = this.shortcuts.get(shortcutKey);    if (!shortcut) return;    const replyTextarea = document.querySelector('[data-testid^="tweetTextarea_"]');    if (!replyTextarea) return;    event.preventDefault();    event.stopPropagation();    console.log(`%c⌨️ Shortcut triggered: ${shortcut.description}`, 'color: #9146FF');    this.executeAction(shortcut.action, event);  }  /**   * Execute shortcut action   */  private static executeAction(action: string, _event: KeyboardEvent): void {    const callback = this.callbacks.get(action);    if (callback) {      callback();      return;    }    switch (action) {      case 'quick_generate':        this.triggerQuickGenerate();        break;      case 'regenerate':        this.triggerRegenerate();        break;      case 'open_templates':        this.openTemplateSelector();        break;      case 'open_dropdown':        this.openToneDropdown();        break;      case 'copy_reply':        this.copyGeneratedReply();        break;      case 'edit_mode':        this.enableEditMode();        break;      case 'open_arsenal':        this.openArsenalMode();        break;      case 'switch_suggestion':      case 'next_suggestion':        this.switchToNextSuggestion();        break;      case 'prev_suggestion':        this.switchToPrevSuggestion();        break;      case 'close_all':        this.closeAllDropdowns();        break;      default:        if (action.startsWith('tone_')) {          const tone = action.replace('tone_', '');          this.triggerToneGeneration(tone);        }    }  }  /**   * Register custom action callback   */  static registerAction(action: string, callback: () => void): void {    this.callbacks.set(action, callback);  }  /**   * Trigger quick generation with default tone   */  private static async triggerQuickGenerate(): Promise<void> {    const config = await StorageService.getConfig();    const defaultTone = config.defaultTone || 'professional';    const event = new CustomEvent('tweetcraft:generate-reply', {      detail: {        tone: defaultTone,        bypassCache: true      }    });    document.dispatchEvent(event);  }  /**   * Regenerate with the last used tone   */  private static async triggerRegenerate(): Promise<void> {    const lastTone = sessionStorage.getItem('tweetcraft_last_tone') || 'professional';    const event = new CustomEvent('tweetcraft:generate-reply', {      detail: {        tone: lastTone,        bypassCache: true,        regenerate: true      }    });    document.dispatchEvent(event);  }  /**   * Trigger generation with specific tone   */  private static triggerToneGeneration(tone: string): void {    const event = new CustomEvent('tweetcraft:generate-reply', {      detail: {        tone: tone,        bypassCache: true      }    });    document.dispatchEvent(event);  }  /**   * Open template selector   */  private static openTemplateSelector(): void {    const event = new CustomEvent('tweetcraft:open-templates');    document.dispatchEvent(event);  }  /**   * Open tone dropdown   */  private static openToneDropdown(): void {    const button = document.querySelector('.smart-reply-btn') as HTMLElement;    if (!button) {      return;    }    const dropdownToggle = button.parentElement?.querySelector('.dropdown-toggle') as HTMLElement;    if (dropdownToggle) {      dropdownToggle.click();    }  }  /**   * Copy generated reply to clipboard   */  private static copyGeneratedReply(): void {    const textarea = document.querySelector('[data-testid^="tweetTextarea_"]') as HTMLElement;    if (!textarea || !textarea.textContent) return;    navigator.clipboard.writeText(textarea.textContent).then(() => {      console.log('%c📋 Reply copied to clipboard', 'color: #17BF63');      const notification = document.createElement('div');      notification.className = 'tweetcraft-notification';      notification.textContent = '✅ Copied!';      notification.style.cssText = `        position: fixed;        bottom: 20px;        right: 20px;        background: rgb(34, 197, 94);        color: white;        padding: 12px 20px;        border-radius: 8px;        font-weight: 500;        z-index: 10000;        animation: slideIn 0.3s ease;      `;      document.body.appendChild(notification);      setTimeout(() => notification.remove(), 2000);    });  }  /**   * Enable edit mode for generated reply   */  private static enableEditMode(): void {    const textarea = document.querySelector('[data-testid^="tweetTextarea_"]') as HTMLElement;    if (!textarea) return;    textarea.focus();    const range = document.createRange();    const selection = window.getSelection();    range.selectNodeContents(textarea);    range.collapse(false);    selection?.removeAllRanges();    selection?.addRange(range);  }  /**   * Switch to next suggestion   */  private static switchToNextSuggestion(): void {    const event = new CustomEvent('tweetcraft:next-suggestion');    document.dispatchEvent(event);  }  /**   * Switch to previous suggestion   */  private static switchToPrevSuggestion(): void {    const event = new CustomEvent('tweetcraft:prev-suggestion');    document.dispatchEvent(event);  }  /**   * Close all dropdowns   */  private static closeAllDropdowns(): void {    const dropdowns = document.querySelectorAll('.smart-reply-dropdown');    dropdowns.forEach(dropdown => {      (dropdown as HTMLElement).style.display = 'none';    });  }  /**   * Load custom shortcuts from storage   */  private static async loadCustomShortcuts(): Promise<ShortcutConfig[]> {    try {      const stored = await chrome.storage.local.get('customShortcuts');      return stored.customShortcuts || [];    } catch {      return [];    }  }  /**   * Save custom shortcut   */  static async saveCustomShortcut(shortcut: ShortcutConfig): Promise<void> {    const shortcuts = await this.loadCustomShortcuts();    shortcuts.push(shortcut);    await chrome.storage.local.set({ customShortcuts: shortcuts });    this.isInitialized = false;    await this.init();  }  /**   * Get shortcut key string   */  private static getShortcutKey(shortcut: ShortcutConfig): string {    const parts: string[] = [];    if (shortcut.ctrl) parts.push('ctrl');    if (shortcut.alt) parts.push('alt');    if (shortcut.shift) parts.push('shift');    parts.push(shortcut.key.toLowerCase());    return parts.join('+');  }  /**   * Get all registered shortcuts   */  static getShortcuts(): ShortcutConfig[] {    return Array.from(this.shortcuts.values());  }  /**   * Open Arsenal Mode   */  private static openArsenalMode(): void {    console.log('%c⚔️ Opening Arsenal Mode', 'color: #1DA1F2; font-weight: bold');    const event = new CustomEvent('tweetcraft:open-arsenal');    document.dispatchEvent(event);    const arsenalButton = document.querySelector('.arsenal-mode-btn') as HTMLElement;    if (arsenalButton) {      arsenalButton.click();    }  }  /**   * Cleanup   */  static destroy(): void {    if (this.boundHandleKeydown) {      document.removeEventListener('keydown', this.boundHandleKeydown, true);      this.boundHandleKeydown = null;    }    this.shortcuts.clear();    this.callbacks.clear();    this.isInitialized = false;  }}
```

utils\loadingStateManager.ts
```ts
/** * Enhanced Loading State Manager * Provides rich loading feedback with progress indicators and animations */export interface LoadingStage {  stage: string;  message: string;  progress?: number;  icon?: string;}export class LoadingStateManager {  private static activeStates = new Map<string, LoadingStage>();  private static startTimes = new Map<string, number>();  /**   * Loading stage definitions with estimated durations   */  static readonly STAGES = {    PREPARING: {       stage: 'preparing',       message: 'Preparing request',       icon: '🔄',      estimatedMs: 100     },    VALIDATING: {       stage: 'validating',       message: 'Validating API',       icon: '🔐',      estimatedMs: 200     },    BUILDING: {       stage: 'building',       message: 'Building context',       icon: '🔨',      estimatedMs: 300     },    GENERATING: {       stage: 'generating',       message: 'Generating',       icon: '🤖',      estimatedMs: 3000     },    FINALIZING: {       stage: 'finalizing',       message: 'Finalizing response',       icon: '✨',      estimatedMs: 200     }  };  /**   * Start a loading operation with enhanced feedback   */  static startLoading(    button: HTMLElement,     operationId: string,    initialStage = this.STAGES.PREPARING  ): void {    this.startTimes.set(operationId, Date.now());    this.activeStates.set(operationId, initialStage);    button.classList.add('loading', 'loading-enhanced');    let container = button.querySelector('.loading-container') as HTMLElement;    if (!container) {      container = document.createElement('div');      container.className = 'loading-container';      button.appendChild(container);    }    container.innerHTML = `      <div class="loading-content">        <span class="loading-icon">${initialStage.icon}</span>        <span class="loading-message">${initialStage.message}...</span>      </div>      <div class="loading-progress-bar">        <div class="loading-progress-fill" style="width: 0%"></div>      </div>      <div class="loading-meta">        <span class="loading-time">0.0s</span>        <span class="loading-cancel" data-operation="${operationId}">Cancel</span>      </div>    `;    this.animateProgress(button, operationId, 0, 20);    this.startTimeUpdater(button, operationId);    const cancelBtn = container.querySelector('.loading-cancel') as HTMLElement;    if (cancelBtn) {      cancelBtn.addEventListener('click', (e) => {        e.stopPropagation();        this.cancelLoading(button, operationId);      });    }    (button as HTMLButtonElement).disabled = true;  }  /**   * Update loading stage with smooth transitions   */  static updateStage(    button: HTMLElement,    operationId: string,    newStage: LoadingStage,    progress?: number  ): void {    const currentStage = this.activeStates.get(operationId);    if (!currentStage) return;    this.activeStates.set(operationId, newStage);    const container = button.querySelector('.loading-container');    if (!container) return;    const iconEl = container.querySelector('.loading-icon') as HTMLElement;    const messageEl = container.querySelector('.loading-message') as HTMLElement;    if (iconEl && messageEl) {      iconEl.style.opacity = '0.5';      messageEl.style.opacity = '0.5';      setTimeout(() => {        iconEl.textContent = newStage.icon || '🔄';        messageEl.textContent = `${newStage.message}...`;        iconEl.style.opacity = '1';        messageEl.style.opacity = '1';      }, 150);    }    if (progress !== undefined) {      this.animateProgress(button, operationId, progress, progress + 20);    }  }  /**   * Animate progress bar smoothly   */  private static animateProgress(    button: HTMLElement,    operationId: string,    from: number,    to: number  ): void {    const progressFill = button.querySelector('.loading-progress-fill') as HTMLElement;    if (!progressFill) return;    to = Math.min(to, 95);    progressFill.style.transition = 'width 0.3s ease-out';    progressFill.style.width = `${to}%`;    const stage = this.activeStates.get(operationId);    if (stage) {      stage.progress = to;    }  }  /**   * Update elapsed time display   */  private static startTimeUpdater(button: HTMLElement, operationId: string): void {    const interval = setInterval(() => {      const startTime = this.startTimes.get(operationId);      if (!startTime || !this.activeStates.has(operationId)) {        clearInterval(interval);        return;      }      const elapsed = (Date.now() - startTime) / 1000;      const timeEl = button.querySelector('.loading-time') as HTMLElement;      if (timeEl) {        timeEl.textContent = `${elapsed.toFixed(1)}s`;        if (elapsed > 10) {          timeEl.style.color = '#FF6B6B';        } else if (elapsed > 5) {          timeEl.style.color = '#FFA500';        }      }    }, 100);  }  /**   * Complete loading with success animation   */  static completeLoading(    button: HTMLElement,    operationId: string,    message = 'Complete!'  ): void {    const startTime = this.startTimes.get(operationId);    const elapsed = startTime ? ((Date.now() - startTime) / 1000).toFixed(1) : '0.0';    const progressFill = button.querySelector('.loading-progress-fill') as HTMLElement;    if (progressFill) {      progressFill.style.width = '100%';    }    const container = button.querySelector('.loading-container');    if (container) {      setTimeout(() => {        container.innerHTML = `          <div class="loading-success">            <span class="success-icon">✅</span>            <span class="success-message">${message}</span>            <span class="success-time">${elapsed}s</span>          </div>        `;      }, 300);    }    setTimeout(() => {      this.resetButton(button, operationId);    }, 2000);  }  /**   * Cancel loading operation   */  static cancelLoading(button: HTMLElement, operationId: string): void {    const container = button.querySelector('.loading-container');    if (container) {      container.innerHTML = `        <div class="loading-cancelled">          <span class="cancel-icon">❌</span>          <span class="cancel-message">Cancelled</span>        </div>      `;    }    button.dispatchEvent(new CustomEvent('loading-cancelled', {       detail: { operationId }     }));    setTimeout(() => {      this.resetButton(button, operationId);    }, 1000);  }  /**   * Handle loading error   */  static errorLoading(    button: HTMLElement,    operationId: string,    error: string  ): void {    const container = button.querySelector('.loading-container');    if (container) {      container.innerHTML = `        <div class="loading-error">          <span class="error-icon">⚠️</span>          <span class="error-message">${error}</span>        </div>      `;    }    setTimeout(() => {      this.resetButton(button, operationId);    }, 3000);  }  /**   * Reset button to original state   */  private static resetButton(button: HTMLElement, operationId: string): void {    button.classList.remove('loading', 'loading-enhanced');    (button as HTMLButtonElement).disabled = false;    const container = button.querySelector('.loading-container');    if (container) {      container.remove();    }    const span = button.querySelector('span');    if (span) {      span.textContent = 'AI Reply';    }    this.activeStates.delete(operationId);    this.startTimes.delete(operationId);  }  /**   * Get estimated time remaining   */  static getEstimatedTime(operationId: string): number {    const stage = this.activeStates.get(operationId);    if (!stage) return 0;    const stages = Object.values(this.STAGES);    const currentIndex = stages.findIndex(s => s.stage === stage.stage);    let remaining = 0;    for (let i = currentIndex + 1; i < stages.length; i++) {      remaining += stages[i].estimatedMs;    }    return remaining / 1000;   }}
```

utils\logger.ts
```ts
/** * Enhanced production-aware logger utility * Provides compact, grouped logging with conditional output */const getIsProduction = (): boolean => {  try {    const manifest = chrome.runtime.getManifest();    return !!(manifest as any).update_url;  } catch {    return true;  }};const IS_PRODUCTION = getIsProduction();export enum LogLevel {  DEBUG = 0,  INFO = 1,  WARN = 2,  ERROR = 3}const CURRENT_LOG_LEVEL = IS_PRODUCTION ? LogLevel.ERROR : LogLevel.DEBUG;const COMPACT_MODE = true; const MAX_DATA_LENGTH = 100; const COLORS = {  primary: '#1DA1F2',     success: '#17BF63',     error: '#DC3545',       warning: '#FFA500',     info: '#9146FF',        debug: '#657786',     };/** * Truncate long strings/objects for compact mode */const truncate = (data: any, maxLength: number = MAX_DATA_LENGTH): string => {  const str = typeof data === 'object' ? JSON.stringify(data) : String(data);  if (str.length <= maxLength) return str;  return str.substring(0, maxLength - 3) + '...';};/** * Format log message with optional styling */const formatLog = (prefix: string, color: string, ...args: any[]): any[] => {  if (!COMPACT_MODE) return args;  const formattedArgs = args.map(arg => {    if (typeof arg === 'object' && arg !== null) {      return truncate(arg);    }    return arg;  });  return [`%c${prefix}`, `color: ${color}; font-weight: bold`, ...formattedArgs];};/** * Production-aware logger with conditional output */export const logger = {  /**   * Debug level logging - only in development   */  debug: (...args: any[]): void => {    if (CURRENT_LOG_LEVEL <= LogLevel.DEBUG && !IS_PRODUCTION) {      const logArgs = COMPACT_MODE ? formatLog('[DEBUG]', COLORS.debug, ...args) : args;      console.log(...logArgs);    }  },  /**   * Info level logging - only in development   */  log: (...args: any[]): void => {    if (CURRENT_LOG_LEVEL <= LogLevel.INFO && !IS_PRODUCTION) {      const logArgs = COMPACT_MODE ? formatLog('[LOG]', COLORS.primary, ...args) : args;      console.log(...logArgs);    }  },  /**   * Info level logging - only in development   */  info: (...args: any[]): void => {    if (CURRENT_LOG_LEVEL <= LogLevel.INFO && !IS_PRODUCTION) {      const logArgs = COMPACT_MODE ? formatLog('[INFO]', COLORS.info, ...args) : args;      console.info(...logArgs);    }  },  /**   * Warning level logging - only in development   */  warn: (...args: any[]): void => {    if (CURRENT_LOG_LEVEL <= LogLevel.WARN && !IS_PRODUCTION) {      const logArgs = COMPACT_MODE ? formatLog('[WARN]', COLORS.warning, ...args) : args;      console.warn(...logArgs);    }  },  /**   * Error level logging - always enabled   */  error: (...args: any[]): void => {    const logArgs = COMPACT_MODE ? formatLog('[ERROR]', COLORS.error, ...args) : args;    console.error(...logArgs);  },  /**   * Group logging - only in development   */  group: (...args: any[]): void => {    if (!IS_PRODUCTION) {      console.group(...args);    }  },  /**   * Group collapsed logging - only in development   */  groupCollapsed: (...args: any[]): void => {    if (!IS_PRODUCTION) {      console.groupCollapsed(...args);    }  },  /**   * Group end - only in development   */  groupEnd: (): void => {    if (!IS_PRODUCTION) {      console.groupEnd();    }  },  /**   * Table logging - only in development   */  table: (...args: any[]): void => {    if (!IS_PRODUCTION) {      console.table(...args);    }  },  /**   * Time logging - only in development   */  time: (label?: string): void => {    if (!IS_PRODUCTION) {      console.time(label);    }  },  /**   * Time end logging - only in development   */  timeEnd: (label?: string): void => {    if (!IS_PRODUCTION) {      console.timeEnd(label);    }  },  /**   * Check if logging is enabled   */  isEnabled: (): boolean => {    return !IS_PRODUCTION;  },  /**   * Get current environment   */  getEnvironment: (): string => {    return IS_PRODUCTION ? 'production' : 'development';  },  /**   * Success logging - only in development   */  success: (...args: any[]): void => {    if (!IS_PRODUCTION) {      const logArgs = COMPACT_MODE ? formatLog('[SUCCESS]', COLORS.success, ...args) : args;      console.log(...logArgs);    }  },  /**   * Compact logging for high-frequency events   */  compact: (category: string, message: string, data?: any): void => {    if (!IS_PRODUCTION) {      const truncatedData = data ? truncate(data, 50) : '';      console.log(`%c[${category}]`, `color: ${COLORS.primary}; font-size: 11px`, message, truncatedData);    }  },  /**   * Feature logging with styled output   */  feature: (name: string, details: Record<string, any>): void => {    if (!IS_PRODUCTION) {      console.log(`%c🚀 ${name}`, 'color: #1DA1F2; font-weight: bold; font-size: 14px');      Object.entries(details).forEach(([key, value]) => {        const displayValue = COMPACT_MODE && typeof value === 'object' ? truncate(value) : value;        console.log(`%c  ${key}:`, 'color: #657786', displayValue);      });    }  },  /**   * Performance timing helper   */  perf: (label: string, fn: () => void): void => {    if (!IS_PRODUCTION) {      const start = performance.now();      fn();      const duration = (performance.now() - start).toFixed(2);      console.log(`%c⚡ ${label}`, 'color: #FFA500; font-size: 11px', `${duration}ms`);    }  }};export default logger;
```

utils\memoryManager.ts
```ts
/** * Memory Management System for TweetCraft * Tracks and cleans up all resources to prevent memory leaks */interface MemoryStats {  listeners: number;  observers: number;  timers: number;  intervals: number;  abortControllers: number;  totalResources: number;}interface ListenerInfo {  element: Element | Document | Window;  event: string;  handler: EventListener;  options?: boolean | AddEventListenerOptions;}export class MemoryManager {  private listeners: Map<string, ListenerInfo> = new Map();  private observers: Set<MutationObserver> = new Set();  private timers: Set<number> = new Set();  private intervals: Set<number> = new Set();  private abortControllers: Set<AbortController> = new Set();  private cleanupCallbacks: Set<() => void> = new Set();  private isDestroyed = false;  constructor() {    this.addEventListener(window, 'beforeunload', () => this.cleanup());    this.addEventListener(window, 'pagehide', () => this.cleanup());    if (process.env.NODE_ENV === 'development') {      this.setInterval(() => {        const stats = this.getStats();        if (stats.totalResources > 0) {          console.log('[MemoryManager] Current resources:', stats);        }      }, 30000);     }  }  /**   * Add event listener with automatic tracking   */  addEventListener(    element: Element | Document | Window,    event: string,    handler: EventListener,    options?: boolean | AddEventListenerOptions  ): string {    if (this.isDestroyed) {      return '';    }    const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;    this.listeners.set(id, { element, event, handler, options });    element.addEventListener(event, handler, options);    console.log(`[MemoryManager] Added listener: ${event} (${id})`);    return id;  }  /**   * Remove specific event listener   */  removeEventListener(id: string): void {    const listener = this.listeners.get(id);    if (listener) {      const { element, event, handler, options } = listener;      element.removeEventListener(event, handler, options);      this.listeners.delete(id);      console.log(`[MemoryManager] Removed listener: ${event} (${id})`);    }  }  /**   * Create and track mutation observer   */  createObserver(callback: MutationCallback): MutationObserver {    if (this.isDestroyed) {      return new MutationObserver(() => {});    }    const observer = new MutationObserver(callback);    this.observers.add(observer);    console.log('[MemoryManager] Created mutation observer');    return observer;  }  /**   * Remove and disconnect observer   */  removeObserver(observer: MutationObserver): void {    if (this.observers.has(observer)) {      observer.disconnect();      this.observers.delete(observer);      console.log('[MemoryManager] Removed mutation observer');    }  }  /**   * Set timeout with tracking   */  setTimeout(callback: () => void, delay: number): number {    if (this.isDestroyed) {      console.warn('[MemoryManager] Attempted to set timeout after cleanup');      return 0;    }    const id = window.setTimeout(() => {      callback();      this.timers.delete(id);    }, delay);    this.timers.add(id);    return id;  }  /**   * Clear specific timeout   */  clearTimeout(id: number): void {    if (this.timers.has(id)) {      window.clearTimeout(id);      this.timers.delete(id);    }  }  /**   * Set interval with tracking   */  setInterval(callback: () => void, delay: number): number {    if (this.isDestroyed) {      console.warn('[MemoryManager] Attempted to set interval after cleanup');      return 0;    }    const id = window.setInterval(callback, delay);    this.intervals.add(id);    return id;  }  /**   * Clear specific interval   */  clearInterval(id: number): void {    if (this.intervals.has(id)) {      window.clearInterval(id);      this.intervals.delete(id);    }  }  /**   * Create abort controller for fetch requests   */  createAbortController(): AbortController {    if (this.isDestroyed) {      console.warn('[MemoryManager] Attempted to create abort controller after cleanup');      return new AbortController();    }    const controller = new AbortController();    this.abortControllers.add(controller);    return controller;  }  /**   * Remove abort controller   */  removeAbortController(controller: AbortController): void {    this.abortControllers.delete(controller);  }  /**   * Register a cleanup callback   */  registerCleanup(callback: () => void): void {    this.cleanupCallbacks.add(callback);  }  /**   * Unregister a cleanup callback   */  unregisterCleanup(callback: () => void): void {    this.cleanupCallbacks.delete(callback);  }  /**   * Get current memory statistics   */  getStats(): MemoryStats {    return {      listeners: this.listeners.size,      observers: this.observers.size,      timers: this.timers.size,      intervals: this.intervals.size,      abortControllers: this.abortControllers.size,      totalResources:         this.listeners.size +         this.observers.size +         this.timers.size +         this.intervals.size +         this.abortControllers.size    };  }  /**   * Check if manager has been destroyed   */  get destroyed(): boolean {    return this.isDestroyed;  }  /**   * Clean up all tracked resources   */  cleanup(): void {    if (this.isDestroyed) {      return;    }    console.log('[MemoryManager] Starting cleanup...');    const stats = this.getStats();    console.log('[MemoryManager] Resources before cleanup:', stats);    this.listeners.forEach(({ element, event, handler, options }) => {      try {        element.removeEventListener(event, handler, options);      } catch (e) {        console.warn('[MemoryManager] Error removing listener:', e);      }    });    this.listeners.clear();    this.observers.forEach(observer => {      try {        observer.disconnect();      } catch (e) {        console.warn('[MemoryManager] Error disconnecting observer:', e);      }    });    this.observers.clear();    this.timers.forEach(id => {      try {        window.clearTimeout(id);      } catch (e) {        console.warn('[MemoryManager] Error clearing timeout:', e);      }    });    this.timers.clear();    this.intervals.forEach(id => {      try {        window.clearInterval(id);      } catch (e) {        console.warn('[MemoryManager] Error clearing interval:', e);      }    });    this.intervals.clear();    this.abortControllers.forEach(controller => {      try {        controller.abort();      } catch (e) {        console.warn('[MemoryManager] Error aborting request:', e);      }    });    this.abortControllers.clear();    this.cleanupCallbacks.forEach(callback => {      try {        callback();      } catch (e) {        console.warn('[MemoryManager] Error in cleanup callback:', e);      }    });    this.cleanupCallbacks.clear();    this.isDestroyed = true;    console.log('[MemoryManager] Cleanup complete');  }  /**   * Reset the manager (useful for testing)   */  reset(): void {    this.cleanup();    this.isDestroyed = false;  }}export const memoryManager = new MemoryManager();if (typeof window !== 'undefined') {  (window as any).__tweetcraftMemoryManager = memoryManager;}
```

utils\performanceMonitor.ts
```ts
/** * Performance monitoring utility for tracking extension performance * Monitors API calls, DOM operations, and memory usage */import { LOG_COLORS, TIMING } from '@/config/constants';interface PerformanceMetric {  name: string;  duration: number;  timestamp: number;  metadata?: Record<string, any>;}interface PerformanceReport {  metrics: PerformanceMetric[];  averages: Record<string, number>;  totals: Record<string, number>;  counts: Record<string, number>;  memoryUsage?: MemoryInfo;  timestamp: number;}interface MemoryInfo {  usedJSHeapSize: number;  totalJSHeapSize: number;  jsHeapSizeLimit: number;}class PerformanceMonitor {  private metrics: PerformanceMetric[] = [];  private marks: Map<string, number> = new Map();  private readonly maxMetrics = 1000;  private readonly reportInterval = 60000;   private reportTimer: ReturnType<typeof setInterval> | null = null;  private enabled = true;  constructor() {    if (typeof performance === 'undefined') {      this.enabled = false;      console.warn('Performance API not available');      return;    }    this.startPeriodicReporting();  }  /**   * Start measuring a performance metric   */  start(name: string, metadata?: Record<string, any>): string | undefined {    if (!this.enabled) return undefined;    const markName = `${name}_${Date.now()}_${Math.random()}`;    this.marks.set(markName, performance.now());    if (metadata) {      (this.marks as any)[`${markName}_metadata`] = metadata;    }    return markName;  }  /**   * End measuring a performance metric   */  end(markName: string | undefined): number | undefined {    if (!this.enabled || !markName) return undefined;    const startTime = this.marks.get(markName);    if (startTime === undefined) {      console.warn(`Performance mark not found: ${markName}`);      return undefined;    }    const duration = performance.now() - startTime;    const name = markName.split('_')[0];    const metadata = (this.marks as any)[`${markName}_metadata`];    this.addMetric({      name,      duration,      timestamp: Date.now(),      metadata,    });    this.marks.delete(markName);    delete (this.marks as any)[`${markName}_metadata`];    if (duration > 1000) {      console.log(        `%c⚡ Performance: ${name} took ${duration.toFixed(2)}ms`,        `color: ${duration > 3000 ? LOG_COLORS.WARNING : LOG_COLORS.INFO}`      );    }    return duration;  }  /**   * Measure a function's execution time   */  measure<T>(name: string, fn: () => T, metadata?: Record<string, any>): T {    if (!this.enabled) return fn();    const mark = this.start(name, metadata);    try {      const result = fn();      if (result instanceof Promise) {        return result.finally(() => {          if (mark) this.end(mark);        }) as T;      }      if (mark) this.end(mark);      return result;    } catch (error) {      if (mark) this.end(mark);      throw error;    }  }  /**   * Measure an async function's execution time   */  async measureAsync<T>(    name: string,    fn: () => Promise<T>,    metadata?: Record<string, any>  ): Promise<T> {    if (!this.enabled) return fn();    const mark = this.start(name, metadata);    try {      const result = await fn();      if (mark) this.end(mark);      return result;    } catch (error) {      if (mark) this.end(mark);      throw error;    }  }  /**   * Add a metric   */  private addMetric(metric: PerformanceMetric): void {    this.metrics.push(metric);    if (this.metrics.length > this.maxMetrics) {      this.metrics = this.metrics.slice(-this.maxMetrics);    }  }  /**   * Get performance report   */  getReport(since?: number): PerformanceReport {    const cutoff = since || Date.now() - this.reportInterval;    const relevantMetrics = this.metrics.filter(m => m.timestamp > cutoff);    const aggregates: Record<string, { total: number; count: number; durations: number[] }> = {};    relevantMetrics.forEach(metric => {      if (!aggregates[metric.name]) {        aggregates[metric.name] = { total: 0, count: 0, durations: [] };      }      aggregates[metric.name].total += metric.duration;      aggregates[metric.name].count++;      aggregates[metric.name].durations.push(metric.duration);    });    const averages: Record<string, number> = {};    const totals: Record<string, number> = {};    const counts: Record<string, number> = {};    Object.entries(aggregates).forEach(([name, data]) => {      averages[name] = data.total / data.count;      totals[name] = data.total;      counts[name] = data.count;    });    let memoryUsage: MemoryInfo | undefined;    if ((performance as any).memory) {      memoryUsage = {        usedJSHeapSize: (performance as any).memory.usedJSHeapSize,        totalJSHeapSize: (performance as any).memory.totalJSHeapSize,        jsHeapSizeLimit: (performance as any).memory.jsHeapSizeLimit,      };    }    return {      metrics: relevantMetrics,      averages,      totals,      counts,      memoryUsage,      timestamp: Date.now(),    };  }  /**   * Log performance report   */  logReport(): void {    const report = this.getReport();    console.log(      '%c📊 Performance Report',      `color: ${LOG_COLORS.PRIMARY}; font-weight: bold; font-size: 14px`    );    const sortedByTotal = Object.entries(report.totals)      .sort(([, a], [, b]) => b - a)      .slice(0, 10);    console.log('%c  Top Operations by Total Time:', `color: ${LOG_COLORS.INFO}`);    sortedByTotal.forEach(([name, total]) => {      const avg = report.averages[name];      const count = report.counts[name];      console.log(        `    ${name}: ${total.toFixed(2)}ms total, ${avg.toFixed(2)}ms avg (${count} calls)`      );    });    if (report.memoryUsage) {      const used = (report.memoryUsage.usedJSHeapSize / 1024 / 1024).toFixed(2);      const total = (report.memoryUsage.totalJSHeapSize / 1024 / 1024).toFixed(2);      const limit = (report.memoryUsage.jsHeapSizeLimit / 1024 / 1024).toFixed(2);      console.log('%c  Memory Usage:', `color: ${LOG_COLORS.INFO}`);      console.log(`    Heap: ${used}MB / ${total}MB (limit: ${limit}MB)`);    }    const slowOps = report.metrics      .filter(m => m.duration > 1000)      .sort((a, b) => b.duration - a.duration)      .slice(0, 5);    if (slowOps.length > 0) {      console.log('%c  Slow Operations:', `color: ${LOG_COLORS.WARNING}`);      slowOps.forEach(op => {        console.log(          `    ${op.name}: ${op.duration.toFixed(2)}ms`,          op.metadata || ''        );      });    }  }  /**   * Start periodic reporting   */  private startPeriodicReporting(): void {    if (!this.enabled) return;    this.reportTimer = setInterval(() => {      this.logReport();    }, this.reportInterval);  }  /**   * Stop periodic reporting   */  stopPeriodicReporting(): void {    if (this.reportTimer) {      clearInterval(this.reportTimer);      this.reportTimer = null;    }  }  /**   * Track DOM operation   */  trackDOM(operation: string, element?: Element): void {    if (!this.enabled) return;    this.addMetric({      name: `DOM_${operation}`,      duration: 0,      timestamp: Date.now(),      metadata: {        elementType: element?.tagName,        elementId: element?.id,        elementClass: element?.className,      },    });  }  /**   * Track API call   */  trackAPI(endpoint: string, duration: number, success: boolean, metadata?: any): void {    if (!this.enabled) return;    this.addMetric({      name: `API_${endpoint}`,      duration,      timestamp: Date.now(),      metadata: {        success,        ...metadata,      },    });  }  /**   * Track cache operation   */  trackCache(operation: 'hit' | 'miss' | 'set' | 'clear', key?: string): void {    if (!this.enabled) return;    this.addMetric({      name: `Cache_${operation}`,      duration: 0,      timestamp: Date.now(),      metadata: { key },    });  }  /**   * Get performance score (0-100)   */  getPerformanceScore(): number {    const report = this.getReport();    let score = 100;    Object.entries(report.averages).forEach(([name, avg]) => {      if (name.startsWith('API_') && avg > 3000) {        score -= 10;      } else if (name.startsWith('DOM_') && avg > 100) {        score -= 5;      } else if (avg > 5000) {        score -= 15;      }    });    if (report.memoryUsage) {      const usage = report.memoryUsage.usedJSHeapSize / report.memoryUsage.jsHeapSizeLimit;      if (usage > 0.8) {        score -= 20;      } else if (usage > 0.6) {        score -= 10;      }    }    return Math.max(0, Math.min(100, score));  }  /**   * Clear all metrics   */  clear(): void {    this.metrics = [];    this.marks.clear();  }  /**   * Export metrics for analysis   */  export(): string {    const report = this.getReport(0);     return JSON.stringify(report, null, 2);  }  /**   * Destroy the performance monitor   */  destroy(): void {    this.stopPeriodicReporting();    this.clear();    this.enabled = false;  }}export const performanceMonitor = new PerformanceMonitor();export function trackPerformance(target: any, propertyName: string, descriptor: PropertyDescriptor) {  const originalMethod = descriptor.value;  descriptor.value = async function(...args: any[]) {    const className = target.constructor.name;    const methodName = `${className}.${propertyName}`;    return performanceMonitor.measureAsync(      methodName,      () => originalMethod.apply(this, args),      { args: args.slice(0, 2) }     );  };  return descriptor;}export const PERFORMANCE_THRESHOLDS = {  API_CALL: 3000,  DOM_OPERATION: 100,  CACHE_OPERATION: 10,  RENDER: 16,   SCRIPT_EXECUTION: 50,} as const;
```

utils\progressiveEnhancement.ts
```ts
/** * Progressive Enhancement System * Provides feature detection and graceful fallbacks for browser compatibility */import { debug, logError, logWarn } from '@/utils/debugConfig';interface FeatureSupport {  name: string;  supported: boolean;  fallback?: () => void;  version?: string;}interface BrowserCapabilities {  storage: {    localStorage: boolean;    sessionStorage: boolean;    indexedDB: boolean;    chrome: boolean;  };  apis: {    mutationObserver: boolean;    intersectionObserver: boolean;    resizeObserver: boolean;    webCrypto: boolean;    networkInformation: boolean;    clipboard: boolean;    notifications: boolean;  };  dom: {    shadowDOM: boolean;    customElements: boolean;    contentEditable: boolean;    execCommand: boolean;  };  css: {    grid: boolean;    flexbox: boolean;    cssVariables: boolean;    backdrop: boolean;  };}export class ProgressiveEnhancement {  private static capabilities: BrowserCapabilities | null = null;  private static featureFlags = new Map<string, boolean>();  private static fallbackHandlers = new Map<string, () => void>();  /**   * Initialize and detect browser capabilities   */  static async init(): Promise<BrowserCapabilities> {    if (this.capabilities) {      return this.capabilities;    }    console.log('%c🔍 Progressive Enhancement', 'color: #9146FF; font-weight: bold', 'Detecting browser capabilities...');    this.capabilities = {      storage: this.detectStorageSupport(),      apis: this.detectAPISupport(),      dom: this.detectDOMSupport(),      css: this.detectCSSSupport()    };    this.registerDefaultFallbacks();    this.logCapabilities();    return this.capabilities;  }  /**   * Detect storage capabilities   */  private static detectStorageSupport(): BrowserCapabilities['storage'] {    return {      localStorage: this.testFeature(() => {        const test = '__PE_TEST__';        localStorage.setItem(test, test);        localStorage.removeItem(test);        return true;      }),      sessionStorage: this.testFeature(() => {        const test = '__PE_TEST__';        sessionStorage.setItem(test, test);        sessionStorage.removeItem(test);        return true;      }),      indexedDB: this.testFeature(() => {        return 'indexedDB' in window && indexedDB !== null;      }),      chrome: this.testFeature(() => {        return typeof chrome !== 'undefined' &&                chrome.storage &&                chrome.storage.local !== undefined;      })    };  }  /**   * Detect API support   */  private static detectAPISupport(): BrowserCapabilities['apis'] {    return {      mutationObserver: 'MutationObserver' in window,      intersectionObserver: 'IntersectionObserver' in window,      resizeObserver: 'ResizeObserver' in window,      webCrypto: 'crypto' in window && 'subtle' in window.crypto,      networkInformation: 'connection' in navigator ||                           'mozConnection' in navigator ||                           'webkitConnection' in navigator,      clipboard: 'clipboard' in navigator && 'writeText' in navigator.clipboard,      notifications: 'Notification' in window    };  }  /**   * Detect DOM capabilities   */  private static detectDOMSupport(): BrowserCapabilities['dom'] {    return {      shadowDOM: 'attachShadow' in Element.prototype,      customElements: 'customElements' in window,      contentEditable: 'contentEditable' in document.createElement('div'),      execCommand: typeof document.execCommand === 'function'    };  }  /**   * Detect CSS capabilities   */  private static detectCSSSupport(): BrowserCapabilities['css'] {    const hasSupports = typeof CSS !== 'undefined' && typeof CSS.supports === 'function';    return {      grid: hasSupports ? CSS.supports('display', 'grid') : true,      flexbox: hasSupports ? CSS.supports('display', 'flex') : true,      cssVariables: hasSupports ? CSS.supports('--test', 'value') : false,      backdrop: hasSupports ? CSS.supports('backdrop-filter', 'blur(10px)') : false    };  }  /**   * Test a feature safely   */  private static testFeature(test: () => boolean): boolean {    try {      return test();    } catch {      return false;    }  }  /**   * Register default fallback handlers   */  private static registerDefaultFallbacks(): void {    this.registerFallback('localStorage', () => {      logWarn('localStorage not available, using in-memory storage');      (window as any).__PE_STORAGE__ = (window as any).__PE_STORAGE__ || {};    });    this.registerFallback('mutationObserver', () => {      logWarn('MutationObserver not available, using polling fallback');      this.startPollingFallback();    });    this.registerFallback('clipboard', () => {      logWarn('Clipboard API not available, using execCommand fallback');    });    this.registerFallback('networkInformation', () => {      console.log('Network Information API not available, using default timeouts');    });  }  /**   * Register a fallback handler for a feature   */  static registerFallback(feature: string, handler: () => void): void {    this.fallbackHandlers.set(feature, handler);  }  /**   * Check if a feature is supported with fallback   */  static isSupported(feature: string): boolean {    if (!this.capabilities) {      this.init();    }    const path = feature.split('.');    let current: any = this.capabilities;    for (const key of path) {      if (current && typeof current === 'object' && key in current) {        current = current[key];      } else {        return false;      }    }    return current === true;  }  /**   * Execute with fallback   */  static async executeWithFallback<T>(    feature: string,    mainFn: () => T | Promise<T>,    fallbackFn?: () => T | Promise<T>  ): Promise<T | null> {    if (this.isSupported(feature)) {      try {        return await mainFn();      } catch (error) {        logError(`Feature ${feature} failed, attempting fallback`, error);      }    }    const registeredFallback = this.fallbackHandlers.get(feature);    if (registeredFallback) {      registeredFallback();    }    if (fallbackFn) {      try {        return await fallbackFn();      } catch (error) {        logError(`Fallback for ${feature} also failed`, error);      }    }    return null;  }  /**   * Polling fallback for MutationObserver   */  private static startPollingFallback(): void {    let lastHTML = document.body.innerHTML;    setInterval(() => {      const currentHTML = document.body.innerHTML;      if (currentHTML !== lastHTML) {        window.dispatchEvent(new CustomEvent('pe-dom-change', {          detail: { timestamp: Date.now() }        }));        lastHTML = currentHTML;      }    }, 1000);   }  /**   * Get storage with fallback   */  static getStorage(): Storage | any {    if (this.isSupported('storage.localStorage')) {      return localStorage;    }    if (!(window as any).__PE_STORAGE__) {      (window as any).__PE_STORAGE__ = {};    }    return {      getItem: (key: string) => (window as any).__PE_STORAGE__[key] || null,      setItem: (key: string, value: string) => {        (window as any).__PE_STORAGE__[key] = value;      },      removeItem: (key: string) => {        delete (window as any).__PE_STORAGE__[key];      },      clear: () => {        (window as any).__PE_STORAGE__ = {};      }    };  }  /**   * Create observer with fallback   */  static createObserver(    callback: MutationCallback,    options?: MutationObserverInit  ): MutationObserver | null {    if (this.isSupported('apis.mutationObserver')) {      return new MutationObserver(callback);    }    window.addEventListener('pe-dom-change', () => {      callback([], null as any);    });    return null;  }  /**   * Copy to clipboard with fallback   */  static async copyToClipboard(text: string): Promise<boolean> {    return await this.executeWithFallback(      'apis.clipboard',      async () => {        await navigator.clipboard.writeText(text);        return true;      },      () => {        const textarea = document.createElement('textarea');        textarea.value = text;        textarea.style.position = 'fixed';        textarea.style.opacity = '0';        document.body.appendChild(textarea);        textarea.select();        try {          const success = document.execCommand('copy');          document.body.removeChild(textarea);          return success;        } catch {          document.body.removeChild(textarea);          return false;        }      }    ) || false;  }  /**   * Get network connection type with fallback   */  static getConnectionType(): string {    if (this.isSupported('apis.networkInformation')) {      const connection = (navigator as any).connection ||                         (navigator as any).mozConnection ||                         (navigator as any).webkitConnection;      return connection?.effectiveType || '4g';    }    return '4g';  }  /**   * Check if running in extension context   */  static isExtensionContext(): boolean {    return this.isSupported('storage.chrome') &&            typeof chrome.runtime !== 'undefined' &&           chrome.runtime.id !== undefined;  }  /**   * Log capabilities summary   */  private static logCapabilities(): void {    if (!this.capabilities) return;    const summary = {      storage: Object.entries(this.capabilities.storage)        .filter(([_, supported]) => supported)        .map(([name]) => name),      apis: Object.entries(this.capabilities.apis)        .filter(([_, supported]) => supported)        .map(([name]) => name),      dom: Object.entries(this.capabilities.dom)        .filter(([_, supported]) => supported)        .map(([name]) => name),      css: Object.entries(this.capabilities.css)        .filter(([_, supported]) => supported)        .map(([name]) => name)    };    console.log('%c✅ Capabilities Detected', 'color: #17BF63; font-weight: bold', summary);  }  /**   * Get full capabilities report   */  static getCapabilities(): BrowserCapabilities | null {    return this.capabilities;  }  /**   * Enable or disable a feature flag   */  static setFeatureFlag(feature: string, enabled: boolean): void {    this.featureFlags.set(feature, enabled);    console.log(`Feature flag '${feature}' set to`, enabled);  }  /**   * Check if a feature flag is enabled   */  static isFeatureFlagEnabled(feature: string): boolean {    return this.featureFlags.get(feature) ?? true;   }}if (typeof window !== 'undefined') {  ProgressiveEnhancement.init().catch(error => {    logError('Failed to initialize Progressive Enhancement', error);  });}
```

utils\promptConfigValidator.ts
```ts
/** * Configuration Validator for Prompt Architecture * Provides pre-validation and sanitization for PromptConfiguration objects */import { PromptConfiguration } from '../services/promptArchitecture';export interface ValidationResult {  isValid: boolean;  errors: string[];  warnings: string[];  sanitizedConfig?: PromptConfiguration;}export class PromptConfigValidator {  private static readonly VALID_TAB_TYPES = ['personas', 'all', 'smart', 'favorites', 'image_gen', 'custom'] as const;  private static readonly VALID_CONTEXT_MODES = ['none', 'single', 'thread'] as const;  private static readonly MIN_TEMPERATURE = 0.1;  private static readonly MAX_TEMPERATURE = 1.0;  private static readonly DEFAULT_TEMPERATURE = 0.7;  /**   * Validate and sanitize a PromptConfiguration object   */  static validate(config: PromptConfiguration): ValidationResult {    const errors: string[] = [];    const warnings: string[] = [];    const sanitized: PromptConfiguration = { ...config };    if (!config.tabType) {      errors.push('tabType is required');    } else if (!this.VALID_TAB_TYPES.includes(config.tabType as any)) {      errors.push(`Invalid tabType "${config.tabType}". Must be one of: ${this.VALID_TAB_TYPES.join(', ')}`);    }    if (config.temperature !== undefined) {      if (typeof config.temperature !== 'number') {        warnings.push(`Temperature must be a number, using default ${this.DEFAULT_TEMPERATURE}`);        sanitized.temperature = this.DEFAULT_TEMPERATURE;      } else if (config.temperature < this.MIN_TEMPERATURE || config.temperature > this.MAX_TEMPERATURE) {        const clamped = Math.max(this.MIN_TEMPERATURE, Math.min(this.MAX_TEMPERATURE, config.temperature));        warnings.push(`Temperature ${config.temperature} clamped to ${clamped}`);        sanitized.temperature = clamped;      }    } else {      sanitized.temperature = this.DEFAULT_TEMPERATURE;    }    if (config.contextMode && !this.VALID_CONTEXT_MODES.includes(config.contextMode)) {      errors.push(`Invalid contextMode "${config.contextMode}". Must be one of: ${this.VALID_CONTEXT_MODES.join(', ')}`);    }    if (config.tabType === 'personas') {      const result = this.validatePersonasTab(config, sanitized, errors, warnings);      if (result.sanitizedConfig) {        sanitized.personaConfig = result.sanitizedConfig.personaConfig;      }    } else if (config.tabType === 'all' || config.tabType === 'smart' || config.tabType === 'favorites') {      const result = this.validateAllTabStructure(config, sanitized, errors, warnings);      if (result.sanitizedConfig) {        sanitized.allTabConfig = result.sanitizedConfig.allTabConfig;      }    } else if (config.tabType === 'custom') {      const result = this.validateCustomTab(config, sanitized, errors, warnings);      if (result.sanitizedConfig) {        sanitized.customConfig = result.sanitizedConfig.customConfig;      }    }    if (config.context) {      this.validateContext(config.context, sanitized, warnings);    }    if (config.systemPrompt && typeof config.systemPrompt === 'string') {      sanitized.systemPrompt = config.systemPrompt.trim();    } else if (config.systemPrompt) {      warnings.push('systemPrompt must be a string, using default');      sanitized.systemPrompt = 'You are a helpful assistant';    }    return {      isValid: errors.length === 0,      errors,      warnings,      sanitizedConfig: errors.length === 0 ? sanitized : undefined    };  }  /**   * Validate PERSONAS tab configuration   */  private static validatePersonasTab(    config: PromptConfiguration,    sanitized: PromptConfiguration,    errors: string[],    warnings: string[]  ): Partial<ValidationResult> {    if (!config.personaConfig) {      errors.push('PERSONAS tab requires personaConfig');      return {};    }    const personaConfig = { ...config.personaConfig };    if (!personaConfig.personality) {      warnings.push('personaConfig.personality is missing, using default');      personaConfig.personality = 'Friendly and supportive';    }    if (!personaConfig.vocabulary) {      warnings.push('personaConfig.vocabulary is missing, using default');      personaConfig.vocabulary = 'Plain English with modern slang';    }    if (!personaConfig.rhetoricMove) {      warnings.push('personaConfig.rhetoricMove is missing, using default');      personaConfig.rhetoricMove = 'Agree and build upon the original point';    }    if (!personaConfig.lengthPacing) {      warnings.push('personaConfig.lengthPacing is missing, using default');      personaConfig.lengthPacing = 'Normal reply with 1-2 sentences';    }    if (!personaConfig.systemPrompt) {      errors.push('personaConfig.systemPrompt is required for PERSONAS tab');      return {};    }    personaConfig.personality = personaConfig.personality.trim();    personaConfig.vocabulary = personaConfig.vocabulary.trim();    personaConfig.rhetoricMove = personaConfig.rhetoricMove.trim();    personaConfig.lengthPacing = personaConfig.lengthPacing.trim();    personaConfig.systemPrompt = personaConfig.systemPrompt.trim();    return { sanitizedConfig: { ...sanitized, personaConfig } };  }  /**   * Validate ALL/SMART/FAVORITES tab configuration   */  private static validateAllTabStructure(    config: PromptConfiguration,    sanitized: PromptConfiguration,    errors: string[],    warnings: string[]  ): Partial<ValidationResult> {    if (!config.allTabConfig) {      errors.push(`${config.tabType?.toUpperCase()} tab requires allTabConfig`);      return {};    }    const allTabConfig = { ...config.allTabConfig };    if (!allTabConfig.personality) {      warnings.push('allTabConfig.personality is missing, using default');      allTabConfig.personality = 'Friendly and supportive';    }    if (!allTabConfig.vocabulary) {      warnings.push('allTabConfig.vocabulary is missing, using default');      allTabConfig.vocabulary = 'Plain English with modern slang';    }    if (!allTabConfig.rhetoric) {      warnings.push('allTabConfig.rhetoric is missing, using default');      allTabConfig.rhetoric = 'Agree and build upon the original point';    }    if (!allTabConfig.lengthPacing) {      warnings.push('allTabConfig.lengthPacing is missing, using default');      allTabConfig.lengthPacing = 'Normal reply with 1-2 sentences';    }    allTabConfig.personality = allTabConfig.personality.trim();    allTabConfig.vocabulary = allTabConfig.vocabulary.trim();    allTabConfig.rhetoric = allTabConfig.rhetoric.trim();    allTabConfig.lengthPacing = allTabConfig.lengthPacing.trim();    return { sanitizedConfig: { ...sanitized, allTabConfig } };  }  /**   * Validate CUSTOM tab configuration   */  private static validateCustomTab(    config: PromptConfiguration,    sanitized: PromptConfiguration,    errors: string[],    warnings: string[]  ): Partial<ValidationResult> {    if (!config.customConfig) {      errors.push('CUSTOM tab requires customConfig');      return {};    }    const customConfig = { ...config.customConfig };    if (!customConfig.style) {      warnings.push('customConfig.style is missing, using default');      customConfig.style = 'Professional and clear';    }    if (!customConfig.tone) {      warnings.push('customConfig.tone is missing, using default');      customConfig.tone = 'Friendly and approachable';    }    if (!customConfig.length) {      warnings.push('customConfig.length is missing, using default');      customConfig.length = 'Concise and to the point';    }    if (customConfig.temperature !== undefined) {      if (typeof customConfig.temperature !== 'number') {        warnings.push('customConfig.temperature must be a number, ignoring');        delete customConfig.temperature;      } else if (customConfig.temperature < this.MIN_TEMPERATURE || customConfig.temperature > this.MAX_TEMPERATURE) {        const clamped = Math.max(this.MIN_TEMPERATURE, Math.min(this.MAX_TEMPERATURE, customConfig.temperature));        warnings.push(`Custom temperature ${customConfig.temperature} clamped to ${clamped}`);        customConfig.temperature = clamped;      }    }    customConfig.style = customConfig.style.trim();    customConfig.tone = customConfig.tone.trim();    customConfig.length = customConfig.length.trim();    return { sanitizedConfig: { ...sanitized, customConfig } };  }  /**   * Validate context object   */  private static validateContext(    context: any,    sanitized: PromptConfiguration,    warnings: string[]  ): void {    const sanitizedContext: any = {};    if (context.tweetText) {      if (typeof context.tweetText === 'string') {        sanitizedContext.tweetText = context.tweetText.trim();      } else {        warnings.push('context.tweetText must be a string, ignoring');      }    }    if (context.authorHandle) {      if (typeof context.authorHandle === 'string') {        sanitizedContext.authorHandle = context.authorHandle.trim().replace(/^@/, '');      } else {        warnings.push('context.authorHandle must be a string, ignoring');      }    }    if (context.threadContext) {      if (Array.isArray(context.threadContext)) {        sanitizedContext.threadContext = context.threadContext          .filter((tweet: any) => tweet && typeof tweet.author === 'string' && typeof tweet.text === 'string')          .map((tweet: any) => ({            author: tweet.author.trim(),            text: tweet.text.trim()          }));        if (sanitizedContext.threadContext.length !== context.threadContext.length) {          warnings.push('Some invalid thread context entries were filtered out');        }      } else {        warnings.push('context.threadContext must be an array, ignoring');      }    }    if (context.images) {      if (Array.isArray(context.images)) {        sanitizedContext.images = context.images          .filter((url: any) => typeof url === 'string' && url.trim().length > 0)          .map((url: string) => url.trim());        if (sanitizedContext.images.length !== context.images.length) {          warnings.push('Some invalid image URLs were filtered out');        }      } else {        warnings.push('context.images must be an array, ignoring');      }    }    if (Object.keys(sanitizedContext).length > 0) {      sanitized.context = sanitizedContext;    }  }  /**   * Quick validation check without full sanitization   */  static isValid(config: PromptConfiguration): boolean {    const result = this.validate(config);    return result.isValid;  }  /**   * Get sanitized configuration or throw error   */  static sanitizeOrThrow(config: PromptConfiguration): PromptConfiguration {    const result = this.validate(config);    if (!result.isValid) {      const errorMessage = `Configuration validation failed:\n${result.errors.join('\n')}`;      console.error('%c❌ CONFIG VALIDATION ERROR', 'color: #DC3545; font-weight: bold');      result.errors.forEach(error => console.error('%c  •', 'color: #DC3545', error));      throw new Error(errorMessage);    }    if (result.warnings.length > 0) {      console.warn('%c⚠️ CONFIG VALIDATION WARNINGS', 'color: #FFA500; font-weight: bold');      result.warnings.forEach(warning => console.warn('%c  •', 'color: #FFA500', warning));    }    return result.sanitizedConfig!;  }  /**   * Log validation result for debugging   */  static logValidationResult(result: ValidationResult): void {    if (result.isValid) {      console.log('%c✅ CONFIG VALIDATION PASSED', 'color: #17BF63; font-weight: bold');    } else {      console.error('%c❌ CONFIG VALIDATION FAILED', 'color: #DC3545; font-weight: bold');    }    if (result.errors.length > 0) {      console.error('%c  Errors:', 'color: #DC3545; font-weight: bold');      result.errors.forEach(error => console.error('%c    •', 'color: #DC3545', error));    }    if (result.warnings.length > 0) {      console.warn('%c  Warnings:', 'color: #FFA500; font-weight: bold');      result.warnings.forEach(warning => console.warn('%c    •', 'color: #FFA500', warning));    }  }}
```

utils\textUtils.ts
```ts
/** * Text processing utilities for TweetCraft * Centralized text manipulation and cleaning functions */import { logger } from '@/utils/logger';/** * Clean up the generated reply text * Removes quotes, hashtags, and normalizes formatting */export function cleanupReply(text: string): string {  let cleaned = text.trim();  if ((cleaned.startsWith('"') && cleaned.endsWith('"')) ||       (cleaned.startsWith("'") && cleaned.endsWith("'"))) {    cleaned = cleaned.slice(1, -1).trim();  }  cleaned = cleaned.replace(/^["']|["']$/g, '');  cleaned = cleaned.replace(/^(Reply|Response|Answer|Tweet):\s*/i, '');  cleaned = cleaned.replace(/\s+/g, ' ').trim();  cleaned = cleaned.replace(/\s*#\w+(\s+#\w+)*\s*$/, '');  if (cleaned.startsWith('@')) {    cleaned = '.' + cleaned;   }  logger.debug('Reply cleaned up:', { original: text, cleaned });  return cleaned;}/** * Truncate text to a maximum length while preserving word boundaries */export function truncateText(text: string, maxLength: number): string {  if (text.length <= maxLength) {    return text;  }  const truncated = text.substring(0, maxLength);  const lastSpaceIndex = truncated.lastIndexOf(' ');  if (lastSpaceIndex > 0) {    return truncated.substring(0, lastSpaceIndex) + '...';  }  return truncated + '...';}/** * Escape special characters for safe HTML display */export function escapeHtml(text: string): string {  const escapeMap: { [key: string]: string } = {    '&': '&amp;',    '<': '&lt;',    '>': '&gt;',    '"': '&quot;',    "'": '&#x27;',    '/': '&#x2F;'  };  return text.replace(/[&<>"'/]/g, char => escapeMap[char]);}/** * Extract hashtags from text */export function extractHashtags(text: string): string[] {  const hashtagRegex = /#\w+/g;  const matches = text.match(hashtagRegex);  return matches ? matches.map(tag => tag.toLowerCase()) : [];}/** * Extract mentions from text */export function extractMentions(text: string): string[] {  const mentionRegex = /@\w+/g;  const matches = text.match(mentionRegex);  return matches ? matches.map(mention => mention.toLowerCase()) : [];}/** * Count characters for Twitter (considering special rules) */export function countTwitterCharacters(text: string): number {  const urlRegex = /https?:\/\/[^\s]+/g;  let charCount = text.length;  const urls = text.match(urlRegex);  if (urls) {    urls.forEach(url => {      charCount = charCount - url.length + 23;    });  }  return charCount;}/** * Check if text is within Twitter's character limit */export function isWithinTwitterLimit(text: string, limit: number = 280): boolean {  return countTwitterCharacters(text) <= limit;}/** * Remove emoji from text (useful for certain contexts) */export function removeEmoji(text: string): string {  return text.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F700}-\u{1F77F}]|[\u{1F780}-\u{1F7FF}]|[\u{1F800}-\u{1F8FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');}/** * Normalize line breaks for consistent display */export function normalizeLineBreaks(text: string): string {  return text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');}
```

utils\urlCleaner.ts
```ts
/** * Utility functions for cleaning URLs and removing tracking parameters */export class URLCleaner {  private static readonly TRACKING_PARAMS = new Set([    's', 't', 'ref_src', 'ref_url', 'ref', 'src', 'campaign',    'utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content',    'utm_id', 'utm_source_platform', 'utm_creative_format', 'utm_marketing_tactic',    'fbclid', 'fb_action_ids', 'fb_action_types', 'fb_source', 'fb_ref',    'tag', 'linkCode', 'linkId', 'ref_', 'pf_rd_p', 'pf_rd_r', 'pd_rd_r',     'pd_rd_w', 'pd_rd_wg', 'psc', 'refRID',    'feature', 'si', 'pp', 'ab_channel',    'gclid', 'dclid', 'gbraid', 'wbraid', 'msclkid', 'twclid',    'mc_cid', 'mc_eid', '_ga', 'gclsrc', 'yclid',    'mkt_tok', 'trk', 'trkInfo', 'oly_enc_id', 'oly_anon_id',    '_hsenc', '_hsmi', '__hstc', '__hssc', '__hsfp',    'igshid', 'share_id', 'share_token'  ]);  /**   * Clean a URL by removing tracking parameters   */  static cleanURL(url: string): string {    try {      const urlObj = new URL(url);      const params = new URLSearchParams(urlObj.search);      let hasChanges = false;      for (const param of Array.from(params.keys())) {        if (this.TRACKING_PARAMS.has(param.toLowerCase())) {          params.delete(param);          hasChanges = true;        }      }      if (hasChanges) {        urlObj.search = params.toString();        return urlObj.toString();      }      return url;    } catch (error) {      return url;    }  }  /**   * Clean all URLs found in text   */  static cleanTextURLs(text: string): string {    const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/gi;    return text.replace(urlRegex, (match) => {      return this.cleanURL(match);    });  }  /**   * Extract and clean URLs from text, returning both cleaned text and list of cleaned URLs   */  static extractAndCleanURLs(text: string): { cleanedText: string; urls: string[] } {    const urls: string[] = [];    const urlRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/gi;    const cleanedText = text.replace(urlRegex, (match) => {      const cleanedURL = this.cleanURL(match);      urls.push(cleanedURL);      return cleanedURL;    });    return {      cleanedText,      urls    };  }}
```
</files>

Assistant:
Looking at the codebase, I can see this is a comprehensive Twitter/X extension called TweetCraft. I'll add the requested features for generating original tweets from topics and trend-based content suggestions using APIs like Grok or EXA.

```typescript
// services/trendService.ts
import { API_CONFIG } from '@/config/apiConfig';
import { JSONExtractor } from '@/utils/jsonExtractor';

export interface TrendingTopic {
  topic: string;
  volume: number;
  category: 'news' | 'entertainment' | 'sports' | 'tech' | 'politics' | 'general';
  sentiment: 'positive' | 'negative' | 'neutral';
  keywords: string[];
  description?: string;
  relatedTopics?: string[];
}

export interface TrendAnalysis {
  topics: TrendingTopic[];
  timestamp: number;
  source: 'grok' | 'exa' | 'perplexity';
  region?: string;
}

export interface TweetSuggestion {
  text: string;
  topic: string;
  hook: string;
  cta?: string;
  hashtags: string[];
  confidence: number;
  reasoning: string;
}

export class TrendService {
  private static readonly CACHE_TTL = 300000; // 5 minutes
  private static trendCache = new Map<string, { data: TrendAnalysis; expires: number }>();
  private static readonly MAX_CACHE_SIZE = 10;

  /**
   * Get trending topics using available APIs
   */
  static async getTrendingTopics(region: string = 'global'): Promise<TrendAnalysis | null> {
    const cacheKey = `trends_${region}`;
    const cached = this.trendCache.get(cacheKey);
    
    if (cached && Date.now() < cached.expires) {
      console.log('%c📈 Using cached trends', 'color: #17BF63');
      return cached.data;
    }

    console.log('%c📈 FETCHING TRENDING TOPICS', 'color: #1DA1F2; font-weight: bold; font-size: 14px');
    console.log('%c  Region:', 'color: #657786', region);

    try {
      // Try Grok first, then Perplexity as fallback
      const analysis = await this.fetchWithGrok(region) || await this.fetchWithPerplexity(region);
      
      if (analysis) {
        this.updateCache(cacheKey, analysis);
        return analysis;
      }
    } catch (error) {
      console.error('Failed to fetch trending topics:', error);
    }

    return null;
  }

  /**
   * Fetch trends using Grok via OpenRouter
   */
  private static async fetchWithGrok(region: string): Promise<TrendAnalysis | null> {
    const apiKey = API_CONFIG.OPENROUTER_API_KEY;
    if (!apiKey || apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {
      console.log('%c⚠️ API key not configured', 'color: #FFA500');
      return null;
    }

    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'chrome-extension://tweetcraft',
          'X-Title': 'TweetCraft Trend Analysis'
        },
        body: JSON.stringify({
          model: 'x-ai/grok-2-1212',
          messages: [
            {
              role: 'system',
              content: 'You are a social media trend analyst. Analyze current trending topics and provide structured data for content creation.'
            },
            {
              role: 'user',
              content: `Analyze the current trending topics on social media platforms (Twitter/X, Reddit, news) for region: ${region}. 

Focus on topics that are:
1. Currently trending (last 24 hours)
2. Suitable for professional/personal commentary
3. Have engagement potential
4. Not overly controversial or sensitive

Return a JSON object with this exact structure:
{
  "topics": [
    {
      "topic": "Topic name",
      "volume": 85,
      "category": "tech",
      "sentiment": "positive",
      "keywords": ["keyword1", "keyword2"],
      "description": "Brief description",
      "relatedTopics": ["related1", "related2"]
    }
  ],
  "timestamp": ${Date.now()},
  "source": "grok",
  "region": "${region}"
}

Provide 8-12 diverse trending topics with accurate volume scores (1-100).`
            }
          ],
          temperature: 0.3,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        throw new Error(`Grok API error: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;

      if (content) {
        const analysis = JSONExtractor.parseJSON<TrendAnalysis>(content);
        if (analysis && analysis.topics?.length > 0) {
          console.log('%c✅ Grok trends fetched:', 'color: #17BF63', analysis.topics.length);
          return analysis;
        }
      }
    } catch (error) {
      console.error('Grok fetch error:', error);
    }

    return null;
  }

  /**
   * Fetch trends using Perplexity as fallback
   */
  private static async fetchWithPerplexity(region: string): Promise<TrendAnalysis | null> {
    const apiKey = API_CONFIG.OPENROUTER_API_KEY;
    if (!apiKey || apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {
      return null;
    }

    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'chrome-extension://tweetcraft',
          'X-Title': 'TweetCraft Trend Analysis'
        },
        body: JSON.stringify({
          model: 'perplexity/llama-3.1-sonar-large-128k-online',
          messages: [
            {
              role: 'user',
              content: `Search for and analyze current trending topics on social media and news for ${region}. Find topics that are trending in the last 24 hours and suitable for social media engagement.

Return exactly this JSON format:
{
  "topics": [
    {
      "topic": "Topic name",
      "volume": 75,
      "category": "news",
      "sentiment": "neutral",
      "keywords": ["key1", "key2"],
      "description": "What's happening"
    }
  ],
  "timestamp": ${Date.now()},
  "source": "perplexity",
  "region": "${region}"
}`
            }
          ],
          temperature: 0.2,
          max_tokens: 1200
        })
      });

      if (response.ok) {
        const data = await response.json();
        const content = data.choices[0]?.message?.content;
        
        if (content) {
          const analysis = JSONExtractor.parseJSON<TrendAnalysis>(content);
          if (analysis) {
            console.log('%c✅ Perplexity trends fetched:', 'color: #17BF63', analysis.topics?.length || 0);
            return analysis;
          }
        }
      }
    } catch (error) {
      console.error('Perplexity fetch error:', error);
    }

    return null;
  }

  /**
   * Generate original tweet suggestions based on trending topics
   */
  static async generateTweetSuggestions(
    topics: string[],
    style: 'professional' | 'casual' | 'witty' | 'thought-provoking' = 'professional',
    count: number = 5
  ): Promise<TweetSuggestion[]> {
    const apiKey = API_CONFIG.OPENROUTER_API_KEY;
    if (!apiKey || apiKey === 'sk-or-v1-YOUR_API_KEY_HERE') {
      return [];
    }

    console.log('%c🚀 GENERATING TWEET SUGGESTIONS', 'color: #9146FF; font-weight: bold; font-size: 14px');
    console.log('%c  Topics:', 'color: #657786', topics.slice(0, 3).join(', ') + (topics.length > 3 ? '...' : ''));
    console.log('%c  Style:', 'color: #657786', style);
    console.log('%c  Count:', 'color: #657786', count);

    try {
      const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'chrome-extension://tweetcraft',
          'X-Title': 'TweetCraft Tweet Generation'
        },
        body: JSON.stringify({
          model: 'anthropic/claude-3.5-sonnet',
          messages: [
            {
              role: 'system',
              content: `You are a social media content strategist specializing in creating engaging original tweets about trending topics.

Style Guidelines:
- Professional: Informative, authoritative, industry insights
- Casual: Conversational, relatable, personal observations  
- Witty: Clever, humorous, unexpected angles
- Thought-provoking: Questions, contrarian takes, deeper analysis

Tweet Structure:
- Hook: Attention-grabbing opening
- Body: Main insight or observation
- CTA: Optional call-to-action or question`
            },
            {
              role: 'user',
              content: `Create ${count} original tweet suggestions about these trending topics: ${topics.join(', ')}

Style: ${style}

Each tweet should be:
- 200-250 characters (leaving room for engagement)
- Original perspective, not just restating the trend
- Include 1-3 relevant hashtags
- Avoid controversial or sensitive angles
- Optimized for engagement

Return JSON array:
[
  {
    "text": "The actual tweet text with hashtags",
    "topic": "Main topic it addresses",
    "hook": "The opening hook strategy used",
    "cta": "Optional call to action if any",
    "hashtags": ["hashtag1", "hashtag2"],
    "confidence": 0.85,
    "reasoning": "Why this tweet should perform well"
  }
]`
            }
          ],
          temperature: 0.7,
          max_tokens: 2000
        })
      });

      if (!response.ok) {
        throw new Error(`Tweet generation failed: ${response.status}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;

      if (content) {
        const suggestions = JSONExtractor.parseJSON<TweetSuggestion[]>(content);
        if (Array.isArray(suggestions)) {
          console.log('%c✅ Tweet suggestions generated:', 'color: #17BF63', suggestions.length);
          return suggestions.filter(s => s.text && s.text.length <= 280);
        }
      }
    } catch (error) {
      console.error('Tweet generation error:', error);
    }

    return [];
  }

  /**
   * Get personalized content suggestions based on user interests
   */
  static async getPersonalizedSuggestions(
    userInterests: string[],
    recentActivity?: string[]
  ): Promise<TweetSuggestion[]> {
    const trends = await this.getTrendingTopics();
    if (!trends || !userInterests.length) return [];

    // Filter trends that match user interests
    const relevantTopics = trends.topics
      .filter(topic => 
        userInterests.some(interest => 
          topic.topic.toLowerCase().includes(interest.toLowerCase()) ||
          topic.keywords.some(keyword => keyword.toLowerCase().includes(interest.toLowerCase()))
        )
      )
      .slice(0, 5)
      .map(t => t.topic);

    if (relevantTopics.length === 0) {
      // Fallback to general suggestions
      return this.generateTweetSuggestions(trends.topics.slice(0, 3).map(t => t.topic));
    }

    return this.generateTweetSuggestions(relevantTopics, 'professional', 6);
  }

  /**
   * Update cache with new data
   */
  private static updateCache(key: string, data: TrendAnalysis): void {
    if (this.trendCache.size >= this.MAX_CACHE_SIZE) {
      const oldestKey = this.trendCache.keys().next().value;
      this.trendCache.delete(oldestKey);
    }

    this.trendCache.set(key, {
      data,
      expires: Date.now() + this.CACHE_TTL
    });
  }

  /**
   * Clear all cached data
   */
  static clearCache(): void {
    this.trendCache.clear();
    console.log('%c🧹 Trend cache cleared', 'color: #FFA500');
  }

  /**
   * Get cache statistics
   */
  static getCacheStats(): {
    size: number;
    entries: Array<{ key: string; age: number; topics: number }>;
  } {
    const now = Date.now();
    const entries = Array.from(this.trendCache.entries()).map(([key, value]) => ({
      key,
      age: now - (value.expires - this.CACHE_TTL),
      topics: value.data.topics.length
    }));

    return { size: this.trendCache.size, entries };
  }
}
```

```typescript
// content/tweetComposer.ts  
import { TrendService, TweetSuggestion, TrendingTopic } from '@/services/trendService';
import { visualFeedback } from '@/ui/visualFeedback';

export class TweetComposer {
  private container: HTMLElement | null = null;
  private isVisible = false;
  private currentSuggestions: TweetSuggestion[] = [];
  private currentTopics: TrendingTopic[] = [];

  constructor() {
    console.log('%c✍️ TweetComposer initialized', 'color: #1DA1F2; font-weight: bold');
  }

  /**
   * Create and show the tweet composer interface
   */
  async show(): Promise<void> {
    if (this.isVisible) return;

    console.log('%c✍️ TWEET COMPOSER: Opening', 'color: #1DA1F2; font-weight: bold');
    
    await this.createContainer();
    await this.loadInitialData();
    this.attachEventListeners();
    this.isVisible = true;

    visualFeedback.slideIn(this.container!, 'bottom');
  }

  /**
   * Create the composer UI container
   */
  private async createContainer(): Promise<void> {
    this.container = document.createElement('div');
    this.container.className = 'tweetcraft-composer';
    this.container.innerHTML = `
      <div class="composer-header">
        <h3>🚀 Original Tweet Generator</h3>
        <button class="close-btn">&times;</button>
      </div>
      
      <div class="composer-body">
        <div class="trends-section">
          <h4>📈 Trending Now</h4>
          <div class="trends-loading">
            <span class="loading-spinner">🔄</span>
            <span>Loading trending topics...</span>
          </div>
          <div class="trends-container" style="display: none;"></div>
        </div>

        <div class="style-section">
          <h4>🎨 Style</h4>
          <div class="style-buttons">
            <button class="style-btn active" data-style="professional">Professional</button>
            <button class="style-btn" data-style="casual">Casual</button>
            <button class="style-btn" data-style="witty">Witty</button>
            <button class="style-btn" data-style="thought-provoking">Deep</button>
          </div>
        </div>

        <div class="custom-topic-section">
          <h4>💭 Custom Topic</h4>
          <input type="text" class="custom-topic-input" placeholder="Enter your own topic or trend...">
          <button class="generate-custom-btn">Generate</button>
        </div>

        <div class="suggestions-section">
          <h4>✨ Suggestions</h4>
          <div class="suggestions-container">
            <div class="no-suggestions">
              Select trending topics or enter a custom topic to generate tweet suggestions.
            </div>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(this.container);
    this.applyStyles();
  }

  /**
   * Load initial trending topics
   */
  private async loadInitialData(): Promise<void> {
    try {
      const trends = await TrendService.getTrendingTopics();
      if (trends) {
        this.currentTopics = trends.topics;
        this.renderTrends(trends.topics);
      } else {
        this.showTrendsError();
      }
    } catch (error) {
      console.error('Failed to load trends:', error);
      this.showTrendsError();
    }
  }

  /**
   * Render trending topics
   */
  private renderTrends(topics: TrendingTopic[]): void {
    const container = this.container?.querySelector('.trends-container') as HTMLElement;
    const loading = this.container?.querySelector('.trends-loading') as HTMLElement;
    
    if (!container) return;

    loading.style.display = 'none';
    container.style.display = 'block';
    
    container.innerHTML = topics.slice(0, 8).map(topic => `
      <div class="trend-item" data-topic="${topic.topic}">
        <div class="trend-header">
          <span class="trend-emoji">${this.getCategoryEmoji(topic.category)}</span>
          <span class="trend-title">${topic.topic}</span>
          <span class="trend-volume">${topic.volume}🔥</span>
        </div>
        <div class="trend-description">${topic.description || 'Trending topic'}</div>
        <div class="trend-keywords">
          ${topic.keywords.slice(0, 3).map(keyword => `<span class="keyword">#${keyword}</span>`).join('')}
        </div>
      </div>
    `).join('');
  }

  /**
   * Show trends loading error
   */
  private showTrendsError(): void {
    const loading = this.container?.querySelector('.trends-loading') as HTMLElement;
    if (loading) {
      loading.innerHTML = `
        <span class="error-icon">⚠️</span>
        <span>Unable to load trends. Try the custom topic feature below.</span>
      `;
    }
  }

  /**
   * Attach event listeners
   */
  private attachEventListeners(): void {
    if (!this.container) return;

    // Close button
    this.container.querySelector('.close-btn')?.addEventListener('click', () => {
      this.hide();
    });

    // Style buttons
    this.container.querySelectorAll('.style-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        this.container?.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
        target.classList.add('active');
      });
    });

    // Trend items
    this.container.addEventListener('click', async (e) => {
      const trendItem = (e.target as HTMLElement).closest('.trend-item') as HTMLElement;
      if (trendItem) {
        const topic = trendItem.dataset.topic;
        if (topic) {
          this.container?.querySelectorAll('.trend-item').forEach(item => item.classList.remove('selected'));
          trendItem.classList.add('selected');
          await this.generateSuggestions([topic]);
        }
      }
    });

    // Custom topic generation
    const customBtn = this.container.querySelector('.generate-custom-btn');
    const customInput = this.container.querySelector('.custom-topic-input') as HTMLInputElement;
    
    customBtn?.addEventListener('click', async () => {
      const topic = customInput?.value.trim();
      if (topic) {
        await this.generateSuggestions([topic]);
      }
    });

    customInput?.addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        const topic = customInput.value.trim();
        if (topic) {
          await this.generateSuggestions([topic]);
        }
      }
    });

    // Click outside to close
    document.addEventListener('click', (e) => {
      if (this.isVisible && !this.container?.contains(e.target as Node)) {
        this.hide();
      }
    });
  }

  /**
   * Generate tweet suggestions
   */
  private async generateSuggestions(topics: string[]): Promise<void> {
    const suggestionsContainer = this.container?.querySelector('.suggestions-container') as HTMLElement;
    const activeStyle = this.container?.querySelector('.style-btn.active')?.getAttribute('data-style') as any;

    if (!suggestionsContainer) return;

    suggestionsContainer.innerHTML = `
      <div class="suggestions-loading">
        <span class="loading-spinner">🤖</span>
        <span>Generating creative tweets...</span>
      </div>
    `;

    try {
      console.log('%c✍️ Generating suggestions for:', 'color: #9146FF', topics);
      
      const suggestions = await TrendService.generateTweetSuggestions(
        topics,
        activeStyle || 'professional',
        5
      );

      this.currentSuggestions = suggestions;
      this.renderSuggestions(suggestions);

    } catch (error) {
      console.error('Failed to generate suggestions:', error);
      suggestionsContainer.innerHTML = `
        <div class="suggestions-error">
          <span class="error-icon">❌</span>
          <span>Failed to generate suggestions. Please try again.</span>
        </div>
      `;
    }
  }

  /**
   * Render tweet suggestions
   */
  private renderSuggestions(suggestions: TweetSuggestion[]): void {
    const container = this.container?.querySelector('.suggestions-container') as HTMLElement;
    if (!container) return;

    if (suggestions.length === 0) {
      container.innerHTML = `
        <div class="no-suggestions">
          No suggestions generated. Try a different topic or style.
        </div>
      `;
      return;
    }

    container.innerHTML = suggestions.map((suggestion, index) => `
      <div class="suggestion-item" data-index="${index}">
        <div class="suggestion-header">
          <span class="suggestion-topic">${suggestion.topic}</span>
          <span class="suggestion-confidence">${Math.round(suggestion.confidence * 100)}%</span>
        </div>
        <div class="suggestion-text">${suggestion.text}</div>
        <div class="suggestion-meta">
          <span class="suggestion-hook">Hook: ${suggestion.hook}</span>
          <div class="suggestion-hashtags">
            ${suggestion.hashtags.map(tag => `<span class="hashtag">${tag}</span>`).join('')}
          </div>
        </div>
        <div class="suggestion-actions">
          <button class="copy-btn" data-text="${this.escapeHtml(suggestion.text)}">📋 Copy</button>
          <button class="compose-btn" data-text="${this.escapeHtml(suggestion.text)}">✍️ Compose</button>
          <button class="edit-btn" data-index="${index}">✏️ Edit</button>
        </div>
        <div class="suggestion-reasoning">${suggestion.reasoning}</div>
      </div>
    `).join('');

    this.attachSuggestionListeners();
  }

  /**
   * Attach suggestion-specific event listeners
   */
  private attachSuggestionListeners(): void {
    // Copy buttons
    this.container?.querySelectorAll('.copy-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const text = (e.target as HTMLElement).dataset.text || '';
        try {
          await navigator.clipboard.writeText(text);
          visualFeedback.showToast('Tweet copied to clipboard!', { type: 'success' });
        } catch (error) {
          console.error('Copy failed:', error);
          visualFeedback.showToast('Copy failed', { type: 'error' });
        }
      });
    });

    // Compose buttons - integrate with Twitter compose
    this.container?.querySelectorAll('.compose-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const text = (e.target as HTMLElement).dataset.text || '';
        this.openTwitterCompose(text);
      });
    });

    // Edit buttons
    this.container?.querySelectorAll('.edit-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt((e.target as HTMLElement).dataset.index || '0');
        this.openEditMode(index);
      });
    });
  }

  /**
   * Open Twitter's compose dialog with pre-filled text
   */
  private openTwitterCompose(text: string): void {
    // Try to find Twitter's compose button and click it
    const composeButton = document.querySelector('[data-testid="SideNav_NewTweet_Button"]') as HTMLElement ||
                         document.querySelector('[data-testid="tweetButtonInline"]') as HTMLElement ||
                         document.querySelector('a[href="/compose/tweet"]') as HTMLElement;
    
    if (composeButton) {
      composeButton.click();
      
      // Wait for compose dialog and fill in text
      setTimeout(() => {
        const tweetBox = document.querySelector('[data-testid="tweetTextarea_0"]') as HTMLElement ||
                         document.querySelector('[contenteditable="true"][role="textbox"]') as HTMLElement;
        
        if (tweetBox) {
          tweetBox.focus();
          tweetBox.textContent = text;
          
          // Trigger input event to notify Twitter
          tweetBox.dispatchEvent(new InputEvent('input', { bubbles: true }));
          
          visualFeedback.showToast('Tweet loaded in composer!', { type: 'success' });
          this.hide();
        }
      }, 500);
    } else {
      // Fallback: copy to clipboard and notify user
      navigator.clipboard.writeText(text).then(() => {
        visualFeedback.showToast('Tweet copied! Open Twitter compose to paste.', { type: 'info' });
      });
    }
  }

  /**
   * Open edit mode for a suggestion
   */
  private openEditMode(index: number): void {
    const suggestion = this.currentSuggestions[index];
    if (!suggestion) return;

    const modal = document.createElement('div');
    modal.className = 'tweetcraft-edit-modal';
    modal.innerHTML = `
      <div class="edit-modal-content">
        <h3>Edit Tweet</h3>
        <textarea class="edit-textarea" maxlength="280">${suggestion.text}</textarea>
        <div class="edit-actions">
          <button class="save-edit-btn">Save</button>
          <button class="cancel-edit-btn">Cancel</button>
        </div>
        <div class="char-counter">
          <span class="current-count">${suggestion.text.length}</span>/280
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    
    const textarea = modal.querySelector('.edit-textarea') as HTMLTextAreaElement;
    const charCount = modal.querySelector('.current-count') as HTMLElement;
    
    textarea.focus();
    
    // Update character count
    textarea.addEventListener('input', () => {
      charCount.textContent = textarea.value.length.toString();
      if (textarea.value.length > 280) {
        charCount.style.color = '#DC3545';
      } else {
        charCount.style.color = '#657786';
      }
    });

    // Save changes
    modal.querySelector('.save-edit-btn')?.addEventListener('click', () => {
      const newText = textarea.value.trim();
      if (newText && newText.length <= 280) {
        this.currentSuggestions[index].text = newText;
        this.renderSuggestions(this.currentSuggestions);
        modal.remove();
        visualFeedback.showToast('Tweet updated!', { type: 'success' });
      }
    });

    // Cancel edit
    modal.querySelector('.cancel-edit-btn')?.addEventListener('click', () => {
      modal.remove();
    });
  }

  /**
   * Get emoji for topic category
   */
  private getCategoryEmoji(category: TrendingTopic['category']): string {
    const emojis = {
      'news': '📰',
      'entertainment': '🎬',
      'sports': '⚽',
      'tech': '💻',
      'politics': '🏛️',
      'general': '💬'
    };
    return emojis[category] || '💬';
  }

  /**
   * Escape HTML for safe rendering
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Hide the composer
   */
  hide(): void {
    if (!this.isVisible || !this.container) return;

    visualFeedback.fade(this.container, false).then(() => {
      this.container?.remove();
      this.container = null;
      this.isVisible = false;
    });
  }

  /**
   * Apply styles
   */
  private applyStyles(): void {
    if (document.querySelector('#tweetcraft-composer-styles')) return;

    const style = document.createElement('style');
    style.id = 'tweetcraft-composer-styles';
    style.textContent = `
      .tweetcraft-composer {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 600px;
        max-width: 90vw;
        max-height: 90vh;
        background: #15202b;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 16px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        z-index: 10000;
        color: #e7e9ea;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .composer-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(139, 152, 165, 0.3);
        background: rgba(29, 161, 242, 0.1);
      }

      .composer-header h3 {
        margin: 0;
        color: #1d9bf0;
        font-size: 18px;
      }

      .close-btn {
        background: none;
        border: none;
        color: #8b98a5;
        font-size: 24px;
        cursor: pointer;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s;
      }

      .close-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #e7e9ea;
      }

      .composer-body {
        padding: 20px;
        overflow-y: auto;
        flex: 1;
      }

      .composer-body h4 {
        margin: 0 0 12px 0;
        color: #e7e9ea;
        font-size: 16px;
        font-weight: 600;
      }

      .composer-body > div {
        margin-bottom: 24px;
      }

      .trends-loading, .suggestions-loading {
        display: flex;
        align-items: center;
        gap: 12px;
        color: #8b98a5;
        padding: 20px;
        text-align: center;
        justify-content: center;
      }

      .loading-spinner {
        animation: spin 1s linear infinite;
      }

      .trends-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 12px;
        max-height: 300px;
        overflow-y: auto;
      }

      .trend-item {
        padding: 12px;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .trend-item:hover {
        border-color: #1d9bf0;
        background: rgba(29, 161, 242, 0.05);
      }

      .trend-item.selected {
        border-color: #1d9bf0;
        background: rgba(29, 161, 242, 0.1);
      }

      .trend-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }

      .trend-emoji {
        font-size: 16px;
      }

      .trend-title {
        font-weight: 600;
        flex: 1;
        color: #e7e9ea;
      }

      .trend-volume {
        color: #ff6b35;
        font-size: 12px;
      }

      .trend-description {
        color: #8b98a5;
        font-size: 13px;
        margin-bottom: 8px;
      }

      .trend-keywords {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .keyword {
        background: rgba(29, 161, 242, 0.2);
        color: #1d9bf0;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
      }

      .style-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .style-btn {
        padding: 8px 16px;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 20px;
        background: transparent;
        color: #8b98a5;
        cursor: pointer;
        transition: all 0.2s;
      }

      .style-btn:hover, .style-btn.active {
        border-color: #1d9bf0;
        color: #1d9bf0;
        background: rgba(29, 161, 242, 0.1);
      }

      .custom-topic-section {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .custom-topic-input {
        padding: 12px;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        color: #e7e9ea;
        font-size: 14px;
      }

      .custom-topic-input::placeholder {
        color: #8b98a5;
      }

      .custom-topic-input:focus {
        outline: none;
        border-color: #1d9bf0;
      }

      .generate-custom-btn {
        padding: 10px 20px;
        background: #1d9bf0;
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 600;
        align-self: flex-start;
        transition: all 0.2s;
      }

      .generate-custom-btn:hover {
        background: #1a8cd8;
        transform: translateY(-1px);
      }

      .suggestion-item {
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
        background: rgba(255, 255, 255, 0.02);
      }

      .suggestion-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }

      .suggestion-topic {
        color: #1d9bf0;
        font-weight: 600;
        font-size: 14px;
      }

      .suggestion-confidence {
        color: #17bf63;
        font-size: 12px;
        font-weight: 600;
      }

      .suggestion-text {
        color: #e7e9ea;
        font-size: 16px;
        line-height: 1.4;
        margin-bottom: 12px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 8px;
        border-left: 3px solid #1d9bf0;
      }

      .suggestion-meta {
        margin-bottom: 12px;
      }

      .suggestion-hook {
        color: #8b98a5;
        font-size: 12px;
        display: block;
        margin-bottom: 8px;
      }

      .suggestion-hashtags {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .hashtag {
        background: rgba(29, 161, 242, 0.2);
        color: #1d9bf0;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 12px;
      }

      .suggestion-actions {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }

      .suggestion-actions button {
        padding: 6px 12px;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 16px;
        background: transparent;
        color: #8b98a5;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }

      .copy-btn:hover {
        border-color: #17bf63;
        color: #17bf63;
      }

      .compose-btn:hover {
        border-color: #1d9bf0;
        color: #1d9bf0;
      }

      .edit-btn:hover {
        border-color: #ffa500;
        color: #ffa500;
      }

      .suggestion-reasoning {
        color: #657786;
        font-size: 11px;
        font-style: italic;
        padding-top: 8px;
        border-top: 1px solid rgba(139, 152, 165, 0.1);
      }

      .tweetcraft-edit-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .edit-modal-content {
        background: #15202b;
        border-radius: 12px;
        padding: 20px;
        width: 500px;
        max-width: 90vw;
        color: #e7e9ea;
      }

      .edit-textarea {
        width: 100%;
        height: 120px;
        padding: 12px;
        border: 1px solid rgba(139, 152, 165, 0.3);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        color: #e7e9ea;
        font-family: inherit;
        font-size: 14px;
        resize: vertical;
        margin: 12px 0;
      }

      .edit-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .edit-actions button {
        padding: 8px 16px;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 600;
      }

      .save-edit-btn {
        background: #1d9bf0;
        color: white;
      }

      .cancel-edit-btn {
        background: #536471;
        color: white;
      }

      .char-counter {
        text-align: right;
        color: #657786;
        font-size: 12px;
        margin-top: 8px;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
    `;
    
    document.head.appendChild(style);
  }
}

export const tweetComposer = new TweetComposer();
```

```typescript
// Add to content/smartReply.ts - new method in SmartReplyWidget class

/**
 * Add tweet composer button to the interface
 */
private addTweetComposerButton(): void {
  if (this.container.querySelector('.tweet-composer-btn')) return;

  const composerBtn = document.createElement('button');
  composerBtn.className = 'tweet-composer-btn';
  composerBtn.innerHTML = '🚀 Original Tweet';
  composerBtn.title = 'Generate original tweets from trending topics';

  composerBtn.addEventListener('click', async (e) => {
    e.stopPropagation();
    const { tweetComposer } = await import('@/content/tweetComposer');
    await tweetComposer.show();
  });

  const buttonContainer = this.container.querySelector('.smart-reply-buttons');
  if (buttonContainer) {
    buttonContainer.appendChild(composerBtn);
  }
}

// Update the createMainInterface method to include the new button:
private createMainInterface(): void {
  // ... existing code ...
  
  this.addTweetComposerButton(); // Add this line
}
```

```scss
// Add to popup/popup.scss - new styles for tweet composer button

.tweet-composer-btn {
  background: linear-gradient(135deg, #9146FF, #7C3AED);
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
  margin-top: 8px;

  &:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(145, 70, 255, 0.3);
    background: linear-gradient(135deg, #8B3BFF, #7C3AED);
  }

  &:active {
    transform: translateY(0);
  }
}
```

The implementation includes:

## 🚀 Original Tweet Generation
- **Trending Topics**: Fetches real-time trends using Grok/Perplexity APIs
- **Multiple Styles**: Professional, Casual, Witty, Thought-provoking
- **Custom Topics**: Users can input their own topics
- **Smart Suggestions**: AI-generated tweets optimized for engagement

## 📈 Trend-Based Content Suggestions  
- **Real-time Trends**: Uses Grok API (with Perplexity fallback)
- **Categorized Topics**: News, Tech, Sports, Entertainment, etc.
- **Volume Scoring**: Shows trending intensity (1-100)
- **Personalized**: Filters based on user interests

## 🎨 Features
- **Visual Interface**: Clean, Twitter-like design
- **One-click Integration**: Direct composition in Twitter
- **Edit Mode**: Customize generated tweets
- **Copy & Paste**: Easy clipboard integration
- **Performance Optimized**: Caching and efficient API usage

## 🔧 Architecture
- **Service Layer**: `TrendService` handles all API interactions
- **UI Component**: `TweetComposer` provides the interface
- **Integration**: Seamlessly works with existing SmartReply system
- **Error Handling**: Graceful fallbacks and user feedback

The features are 100% compatible with the existing architecture and maintain the same code style and patterns used throughout the extension.